---
title: "A fast algorithm to compute a curve of confidence upper bounds for the False Discovery Proportion using a reference family with a forest structure"
# subtitle: ""
author:
  - name: Guillermo Durand
    corresponding: true
    email: guillermo.durand@universite-paris-saclay.fr
    url: https://durandg12.github.io/
    orcid: 0000-0003-4056-5631
    affiliations:
      - name: Université Paris-Saclay
        department: Laboratoire de Mathématiques d'Orsay
        url: https://www.imo.universite-paris-saclay.fr/fr/
date: last-modified
date-modified: last-modified
abstract: >+
  This paper presents a new algorithm (and an additional trick) that allows to compute fastly an entire curve of post hoc bounds for the False Discovery Proportion when the underlying bound $V^*_{\mathfrak{R}}$ construction is based on a reference family $\mathfrak{R}$ with a forest structure à la @MR4178188. By an entire curve, we mean the values $V^*_{\mathfrak{R}}(S_1),\dotsc,V^*_{\mathfrak{R}}(S_m)$ computed on a path of increasing selection sets $S_1\subsetneq\dotsb\subsetneq S_m$, $|S_t|=t$. The new algorithm leverages the fact that going from $S_t$ to $S_{t+1}$ is done by adding only one hypothesis.
keywords: [multiple testing, algorithmic, post hoc inference, false discovery proportion, confidence bound]
citation:
  type: article-journal
  container-title: "Computo"
  doi: "xxxx"
  url: https://computo.sfds.asso.fr/algo-curve
  publisher: "Société Française de Statistique"
  issn: "2824-7795"
bibliography: algo-curve.bib
github-user: durandg12
repo: "algo-curve"
draft: true # set to false once the build is running
published: false # will be set to true once accepted
number-sections: true
format:
  computo-html: 
    html-math-method: mathjax
    include-in-header:
      - text: |
          <script>
          window.MathJax = {
            tex: {
              tags: 'ams'
            }
          };
          </script>
    crossrefs-hover: false
  computo-pdf: 
    include-in-header:
      - text: |
          \usepackage{amsmath}
    cite-method: natbib
    natbiboptions: round
    keep-tex: true
    crossrefs-hover: false
---

::: {.hidden}
 \newcommand{\comp}[1]{{#1}^{\mathsf{c}}}
 \newcommand{\Pro}[1]{\mathbb{P}\left(#1\right)} 
 \newcommand{\Esp}[1]{\mathbb{E}\left[ #1 \right]}
 \newcommand{\ind}[1]{\mathbb{1}_{\left\{#1 \right\}}}
 \newcommand{\cH}{\mathcal{H}}
 \newcommand{\cK}{\mathcal{K}}
 \newcommand{\cP}{\mathcal{P}}
 \newcommand{\FDP}{\mathrm{FDP}}
 \newcommand{\FDR}{\mathrm{FDR}}
 \newcommand{\JER}{\mathrm{JER}}
 \newcommand{\Rfam}{\mathfrak{R}}
 \newcommand{\Hoi}{H_{0,i}}
 \newcommand{\Vhat}{\widehat V}
 \newcommand{\Vstar}{V^*_{\Rfam}}
 \newcommand{\Nm}{\mathbb{N}_m}
 \newcommand{\pr}{\mathfrak{pr}}
 \newcommand{\kth}[2]{k^{(#1,#2)}}
 \newcommand{\RR}{\mathbb{R}}
 \newcommand{\telque}{\,:\,}
:::

# Introduction

Multiple testing theory is often used for exploratory analysis, like Genome-Wide Association Studies, where multiple features are tested to find promising ones. Classical multiple testing theory like Family-Wise Error Rate (FWER) control or False Discovery Rate (FDR) control [@MR1325392] can be used, but a more recent trend consists in the computation of post hoc bounds, also named post selection bounds or confidence envelopes, for the number of false positives, or, equivalently, for the False Discovery Proportion (FDP). This approach is notably advocated for in the context of exploratory research by [@MR2951390, Section 1]. 

Mathematically speaking, a confidence upper bound (we prefer to say upper bound instead of envelope for obvious reasons) is a function $\Vhat : \cP(\Nm^*) \to \Nm$, where $\Nm=\{0,\dotsc,m\}$, $\Nm^*=\{1,\dotsc,m\}$ and $m$ is the number of hypotheses, such that 
\begin{equation}
\forall \alpha \in ]0,1[, \Pro{\forall S \subseteq \Nm^*, |S\cap \cH_0|\leq \Vhat(S)}\geq 1-\alpha.
\label{eq_confidence}
\end{equation}
Here, $\alpha$ is a target error rate and $\cH_0$ is the set of hypotheses indices that are true null hypotheses. Note that the construction of $\Vhat$ depends on $\alpha$ and on the random data $X$ and the dependence is omitted to lighten notation and because there is no ambiguity. The meaning of Equation \eqref{eq_confidence} is that $\Vhat$ provides an upper bound of the number of null hypotheses in $S$ for any selection set $S\subseteq \Nm^*$, which allows the user to perform post hoc selection on their data without breaching the statistical guarantee. Also note that by dividing by $|S|\vee 1$ in Equation \eqref{eq_confidence} we also get a confidence bound for the FDP:
\begin{equation}
\forall \alpha \in ]0,1[, \Pro{\forall S \subseteq \Nm^*, \FDP(S)\leq \frac{\Vhat(S)}{|S|\vee 1}}\geq 1-\alpha.
\label{eq_confidence_fdp}
\end{equation}
So post hoc bounds provide ways to construct FDP-controlling sets instead of FDR-controlling sets, which is much more desirable given the nature of the FDR as an expected value. See for example [@MR3418717, Figure 4] for a credible example where the FDR is controlled but the FDP has a highly undesirable behavior (either 0 because no discoveries at all are made, either higher than the target level).

The first confidence bounds are found in @MR2279468 and @MR2279639, although, in the latter, only for selection sets of the form $\{i\in\Nm : P_i\leq t\}$ where $P_i$ is the $p$-value associated to the null hypothesis $\Hoi$. In @MR2951390 the authors re-wrote the generic construction of @MR2279468 in terms of closed testing @MR468056, proposed several practical constructions and sparked a new interest in multiple testing procedures based on confidence envelopes. This work was followed by a prolific series of works like @MR3305943 or @MR4731977. In @MR4124323, the authors introduce the new point of view of references families (see @sec-reference-fam) to construct post hoc bounds, and show the links between this meta-technique and the closed testing one, along with new bounds. 

Following the reference family trail, in @MR4178188 the authors introduce new reference families with a special set-theoretic constraint that allows an efficient computation of the bound denoted by $\Vstar$ on a single selection set $S$. The problem is that one often wants to compute $\Vstar$ on a whole path of selection sets $(S_t)_{t\in\Nm^*}$, for example the hypotheses attached to the $t$ smallest $p$-values. Whereas the algorithm provided in the aforementioned work [@MR4178188, Algorithm 1], which is reproduced here, see @alg-vstar, is fast for a single evaluation, it is slow and inefficient to repeatedly call it to compute each $\Vstar(S_t)$. If the $S_t$'s are nested, and growing by one, that is $S_1\subsetneq\dotsb\subsetneq S_m$ and $|S_t|=t$, there is a way to efficiently compute $\left(\Vstar(S_t)\right)_{t\in\Nm}$ by leveraging the nested structure. 

This is the main contribution of the present paper: a new and fast algorithm computing the curve $\left(\Vstar(S_t)\right)_{t\in\Nm}$ for a nested path of selection sets, that is presented in @sec-fast-curve. An additional algorithm that can speed up computations both for the single-evaluation algorithm and the new curve-evaluation algorithm is also presented, in @sec-pruning. A detailed example illustrating how the new algorithms work is provided in @sec-example, and the proof that the fast algorithm indeed computes correctly the curve is in @sec-proof. In @sec-notation, all necessary notation and vocabulary is re-introduced, most of it being the same as in @MR4178188. In @sec-implementation we discuss the current implementations of all the presented algorithms in the `R` [@R-base] package `sanssouci` [@sanssouci]. Finally, a few numerical experiments are presented in Section @sec-numeric to demonstrate the computation time gain.

# Notation and reference family methodology

## Multiple testing notation {#sec-notation}

As is usual in multiple testing theory, we consider a probability space $(\Omega,\mathcal A, \mathbb P)$, a model $\mathcal{P}$ on a measurable space $(\mathcal{X},\mathfrak{X})$, and data that is represented by a random variable $X:(\Omega,\mathcal A)\to(\mathcal{X},\mathfrak{X})$ with $X\sim P\in \mathcal{P}$, that is, the law of $X$ is comprised in the model $\mathcal{P}$.

Then we consider $m\geq1$ null hypotheses $H_{0,1}, \dotsc, H_{0,m}$ which formally are submodels, that is subsets of $\mathcal{P}$. The associated alternative hypotheses $H_{1,1}, \dotsc, H_{1,m}$ are submodels such that $\Hoi\cap H_{1,i}=\varnothing$ for all $i\in\Nm^*$. We denote by $\cH_0=\cH_0(P)$ (the dependence in $P$ will be dropped when there is no ambiguity) the set of all null hypotheses that are true, that is $\cH_0(P)=\{i\in\Nm^* : P\in \Hoi\}$. In other words, $\Hoi$ is true if and only if $i\in\cH_0$. For testing each $\Hoi, i\in\Nm^*$, we have at hand a $p$-value $p_i=p_i(X)$ (the dependence in $X$ will be dropped when there is no ambiguity) which is a random variable with the following property : if $i\in\cH_0$, then the law of $p_i$ is super-uniform, which is sometimes denoted $\mathcal L(p_i)\succeq \mathcal{U}([0,1])$. This means that in such case, the cumulative distribution function (cdf) of $p_i$ is always smaller than or equal to the cdf of a random variable $U\sim \mathcal{U}([0,1])$ :
\begin{equation}
\forall x \in \RR, \Pro{p_i\leq x}\leq \Pro{U\leq x} = 0\vee(x\wedge 1).
\label{eq_super_unif}
\end{equation}

For every subset of hypotheses $S\subseteq\Nm^*$, let $V(S)=|S\cap\cH_0|$. If we think of $S$ as a selection set of hypotheses deemed significant, $V(S)$ is then the number of false positives (FP) in $S$. $V(S)$ is our main object of interest and the quantity that we wish to over-estimate with confidence upper bounds (see Equation \eqref{eq_confidence} or the more formal Equation \eqref{eq_confidence_formal} below).

Finally let us consider the following toy example, that will be re-used in the remainder of the paper.

::: {#exm-gauss}

## Gaussian one-sided

In this case we assume that $X=(X_1,\dotsc,X_m)$ is a Gaussian vector and the null hypotheses refer to the nullity of the means in contrast to their positivity. That is, formally, $(\mathcal{X},\mathfrak{X})=(\mathbb R^m, \mathcal B\left(\mathbb R^m  \right))$, $\mathcal P=\{ \mathcal N(\boldsymbol{\mu}, \Sigma) : \forall j \in\Nm^*, \mu_j\geq 0, \Sigma \text{ positive semidefinite}  \}$, for each $i\in\Nm^*$, $\Hoi= \{ \mathcal N(\boldsymbol{\mu}, \Sigma) \in \mathcal P :\mu_i=0 \}$ and $H_{1,i}=\{ \mathcal N(\boldsymbol{\mu}, \Sigma) \in \mathcal P :\mu_i>0 \}$. Then we can construct $p$-values by letting $p_i(X)=\bar\Phi(X_i)=1-\Phi(X_i)$, where $\Phi$ denotes the cdf of $\mathcal N(0,1)$ and $\bar\Phi$ the associated survival function.
:::

## Post hoc bounds with reference families {#sec-reference-fam}

With the formalism introduced in last section, a confidence upper bound is a functional $\Vhat :\mathcal X\times ]0,1[\to(\mathcal P(\Nm^*) \to \Nm)$  such that,
\begin{equation}
\forall P\in\mathcal P, \forall X\sim P, \forall \alpha \in ]0,1[, \Pro{\forall S \subseteq \Nm^*, V(S)\leq \Vhat(X,\alpha)(S)}\geq 1-\alpha.
\label{eq_confidence_formal}
\end{equation}
In the remainder, the dependence in $(X,\alpha)$ will be dropped when there is no ambiguity and $\Vhat(X,\alpha)$ will simply be written $\Vhat$.

As said in the Introduction, many constructions, ultimately theoretically equivalent but differing by the practical steps involved, exist, and in this paper we focus on the meta-construction of @MR4124323 based on reference families. A reference family is a family $\Rfam=\Rfam(X,\alpha)=(R_k,\zeta_k)_{k\in \mathcal K}$ with $|\mathcal K|\leq 2^m$, $R_k\subseteq\Nm^*$, $\zeta_k\in\left\{0,\dotsc,|R_k|\right\}$ where everything (that is, $\mathcal K$ and all the $R_k$ and $\zeta_k$) depends on $(X,\alpha)$ but the dependency is not explicitly written. The $R_k$ are all distinct. We also define the following error criterion for a reference family, named Joint Error Rate (JER):
\begin{equation}
\JER(\Rfam) = \Pro{\exists k\in\mathcal K, |R_k\cap\cH_0| > \zeta_k } = \Pro{\exists k\in\mathcal K, V(R_k) > \zeta_k }.
\label{eq_jer}
\end{equation}
In the following, we are only interested in reference families that control the JER at level $\alpha$:
\begin{equation}
\forall P\in\mathcal P, \forall X\sim P, \forall \alpha \in ]0,1[, 1-\JER(\Rfam(X,\alpha))=\Pro{\forall k\in\mathcal K, V(R_k)\leq \zeta_k} \geq 1-\alpha.
\label{eq_jer_control}
\end{equation}
Note that Equation \eqref{eq_jer_control} is really similar to Equation \eqref{eq_confidence_formal} except that the uniform guarantee, instead of being over all $S\subseteq \Nm^*$, is only over all the $R_k\subseteq \Nm^*, k\in\mathcal K$, with $\mathcal K$ having cardinality potentially much smaller than $2^m$. A global confidence bound is then derived from a JER-controlling reference family by interpolation. Let 
\begin{equation}
\mathcal A(\Rfam)= \left\{A\subseteq \Nm^*:  \forall k\in\mathcal K, |R_k\cap A| \leq \zeta_k \right\}.
\label{eq_a}
\end{equation}
What says the JER control is that $\cH_0\in\mathcal A(\Rfam)$. We leverage this information with the following confidence bound construction:
\begin{equation}
\Vstar(S) = \max_{A\in\mathcal A(\Rfam)}|S\cap A|
\label{eq-vstar}
\end{equation}
which optimally uses the information provided by the JER control of the reference family, as proven by Proposition 2.1 of @MR4124323. Because of the $\max_{A\in\mathcal A(\Rfam)}$, the computation of $\Vstar(S)$ is generally intractable (see Proposition 2.2 of @MR4124323), but for specific structures of reference families, a polynomial computation can be derived. This is the topic of @MR4178188 and of next section.

## Regions with a forest structure {#sec-forest-structure}

The core concept of this section is to assume that the regions $R_k$'s of the reference family are what we called in @MR4178188 a forest structure, that is two regions are either disjoint or nested:
\begin{equation}
\forall k,k'\in\mathcal{K} , R_k \cap R_{k'} \in \{ R_k,  R_{k'} , \varnothing \}.
\label{eq-forest}
\end{equation}
Representing the $R_k$'s with a directed graph, where there is an oriented edge $R_k \leftarrow R_{k'}$ if and only if $R_k \subset R_{k'}$ and there is no $R_{k''}$ such that $R_k \subsetneq R_{k''}\subsetneq R_{k'}$ gives a forest, hence the name. See @exm-toy-forest and its representation in @fig-forest-exm.

We also need to introduce the notion of depth with the following function:
\begin{equation}
\phi \:  : \: \left\{
\begin{array}{l  c l  }
 \cK & \to & \mathbb{N}^*\\
k & \mapsto & 1 + \left| \{k'\in\cK: R_k\subsetneq R_{k'} \} \right|   .
\end{array}
\right.
\label{eq-depth}
\end{equation}

::: {#exm-toy-forest}

Let $m=25$, $R_1 = \{1, \dotsc , 20 \}$, $R_2  =  \{1, 2  \}$, $R_3   =   \{3 , \dotsc , 10 \}$, $R_4  =    \{11, \dotsc , 20 \}$, $R_5 =  \{5, \dotsc , 10 \}$, $R_6   =     \{11, \dotsc , 16 \}$, $R_7  =   \{17, \dotsc ,20  \}$, $R_8=\{21,22\}$, $R_9 = \{22\}$. This is the same example as Example 2 of @MR4178188 and it is graphically depicted in @fig-forest-exm. The sets $R_1$, $R_8$ are of depth $1$; the sets $R_2,R_3,R_4,R_9$ are of depth $2$; the sets $R_5,R_6,R_7$ are of depth $3$.
:::

:::{#fig-forest-exm}

``` tikz
%%| filename: ../figure-tikz/fig-tikz-01
\begin{tikzpicture}[scale=1]
 \tikzstyle{quadri}=[circle,draw,text=black, thick]
 \tikzstyle{estun}=[->,>=latex,very thick]
 \node[quadri] (R1) at (0,3) {$R_1$};
 \node[quadri] (R2) at (-2,1) {$R_2$};
 \node[quadri] (R3) at (0,1) {$R_3$};
 \node[quadri] (R4) at (2,1) {$R_4$};
 \node[quadri] (R5) at (0,-1) {$R_5$};
 \node[quadri] (R6) at (1.5,-1) {$R_6$};
 \node[quadri] (R7) at (2.5,-1) {$R_7$};
 \node[quadri] (R8) at (4,3) {$R_8$};
 \node[quadri] (R9) at (4,1) {$R_9$};
 \draw[estun] (R1)--(R2);
 \draw[estun] (R1)--(R3);
 \draw[estun] (R1)--(R4);
 \draw[estun] (R3)--(R5);
 \draw[estun] (R4)--(R6);
 \draw[estun] (R4)--(R7);
 \draw[estun] (R8)--(R9);
\end{tikzpicture}
```

The regions of @exm-toy-forest.

:::

Another tool of @MR4178188 that will be used is its Lemma 2, that is the identification of $\Rfam$ with a set $\mathcal C\subset \left\{(i,j)\in \left({\mathbb N_N}^*\right)^2 \: : i\leq j\right\}$ such that for $(i,j), (i',j')\in\mathcal C$, $\{i,\dotsc, j\}\cap\{i',\dotsc,j'\}\in\left\{\varnothing, \{i,\dotsc, j\},\{i',\dotsc j'\}  \right\}$. With this identification, each $R_k=R_{(i,j)}$ can be written as $P_{i:j}=\bigcup_{i\leq n\leq j}P_n$ where $(P_n)_{1\leq n \leq N}$ is a partition of $\Nm^*$. The $P_n$'s were called atoms in @MR4178188 because they have the thinnest granularity in the structure, but to continue the analogy with graphs, forests and trees, they can also be called leafs. See @exm-toy-leaves for a concrete example.

::: {#exm-toy-leaves}

## Continuation of @exm-toy-forest

For the reference family given in @exm-toy-forest, a partition of atoms is given by $P_1 =R_2$, $P_2  =   R_3\setminus R_5$, $P_3  =   R_5$, $P_4=R_6$, $P_5=R_7$, $P_6=R_8\setminus R_9$, $P_7=R_9$, $P_8=\Nm^* \setminus \{R_1 \cup R_8 \}$. Then $R_1=P_{1:5}$, $R_3=P_{2:3}$, $R_4=P_{4:5}$ and $R_8=P_{6:7}$. Note that not all atoms are regions of the family. Those new labels are graphically depicted in @fig-leaves-exm. The nodes that correspond to atoms that are not in the family are depicted with a dashed circle, and all atoms are depicted in gray. This is the same example as Example 3 of @MR4178188.
:::

:::{#fig-leaves-exm}

``` tikz 
%%| filename: ../figure-tikz/fig-tikz-02
\begin{tikzpicture}[scale=1]
 \tikzstyle{quadri}=[circle,draw,text=black,thick]
 \tikzstyle{estun}=[->,>=latex,very thick]
 \node[quadri] (R1) at (0,3) {$P_{1:5}$};
 \node[quadri, fill=gray!25] (R2) at (-2,1) {$P_1$};
 \node[quadri] (R3) at (0,1) {$P_{2:3}$};
 \node[quadri] (R4) at (2,1) {$P_{4:5}$};
 \node[quadri, dashed,fill=gray!25] (P2) at (-0.5,-1) {$P_2$};
 \node[quadri,fill=gray!25] (R5) at (0.5,-1) {$P_3$};
 \node[quadri,fill=gray!25] (R6) at (1.5,-1) {$P_4$};
 \node[quadri,fill=gray!25] (R7) at (2.5,-1) {$P_5$};
 \node[quadri] (R8) at (4,3) {$P_{6:7}$};
 \node[quadri,dashed,fill=gray!25] (P6) at (3.5,1) {$P_6$};
 \node[quadri,fill=gray!25] (R9) at (4.5,1) {$P_7$};
 \node[quadri,dashed,fill=gray!25] (P8) at (6,3) {$P_8$};
 \draw[estun] (R1)--(R2);
 \draw[estun] (R1)--(R3);
 \draw[estun] (R1)--(R4);
 \draw[estun] (R3)--(R5);
 \draw[estun,dashed,thick] (R3)--(P2);
 \draw[estun] (R4)--(R6);
 \draw[estun] (R4)--(R7);
 \draw[estun] (R8)--(R9);
 \draw[estun,dashed,thick] (R8)--(P6);
\end{tikzpicture}
```

The regions of @exm-toy-forest but with the labels of @exm-toy-leaves.

:::

When all leaves are regions of the family, it is said that the family is complete. If this is not the case, the family can easily be completed by adding the missing leaves (and using their cardinality as associated $\zeta$) without changing the value $\Vstar$. See Definition 2, Lemma 6 and Algorithm 2 of @MR4178188 for the details.

@MR4178188 also proved in their Theorem 1 that: 
\begin{equation}
V^*_{\Rfam}(S)=\min_{Q\subseteq\cK}\left(\sum_{k'\in Q}\zeta_{k'}\wedge|S\cap R_{k'}|+\left| S\setminus\bigcup_{k'\in Q} R_{k'}   \right|\right)
\label{eq_vstar_Q} 
\end{equation}
and, even better, in their Corollary 1 *(iii)* that:
\begin{equation}
\Vstar(S) = \min_{Q\in \mathfrak P}\sum_{k'\in Q}\zeta_{k'}\wedge|S\cap R_{k'}|,
\label{eq_vstar_Qpartition}
\end{equation}
provided that the family is complete. Here, $\mathfrak P \subseteq \mathcal P(\cK)$ is the set of subsets of $\cK$ that realize a partition, that is, the set of $Q\subseteq\cK$ such that the $R_k$, $k\in Q$, form a partition of $\Nm^*$. So the minimum in Equation \eqref{eq_vstar_Qpartition} is over way less elements than in Equation \eqref{eq_vstar_Q}.

Finally, that paper provides a polynomial algorithm to $V^*_{\Rfam}(S)$ for a single $S\subseteq\Nm^*$, which we reproduce here in @alg-vstar. The family is assumed complete, otherwise the first step would be to complete it. In the original paper, $\cK^h$ used to designate the elements of $\cK$ at depth $h$ plus the atoms at depth $\leq h$. Actually one can realize that the last assumption is not needed for this algorithm to perform exactly the same, with the added benefit of not repeating computations at the atoms that don't have the maximal depth. The only change is that sometimes $Succ_k$ can be empty, in which case we simply let $newVec_k=\zeta_k\wedge|S\cap R_k|$. Thus, here in this paper, we define $\cK^h$ as only the elements of $\cK$ at depth $h$ (the previous intricate definition may still be necessary for the proof of Theorem 1 of @MR4178188): $\cK^h=\{ (i,j)\in\cK : \phi(i,j)=h      \}, \:\:\:h\geq 1.$ This is the only deviation from the notation of @MR4178188. Finally note that in the ongoing analogy with graph theory, the elements of $\cK^1$ are the roots of the different trees making up the forest.

::: {.content-visible when-format="html"}
```pseudocode
#| label: alg-vstar
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Computation of a given $V^*_{\mathfrak{R}}(S)$}
\begin{algorithmic}
\Procedure{Vstar}{S, $\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete}
  \State $ H \gets \max_{k\in\mathcal{K}} \phi(k)  $ \Comment{maximum depth}
  \For{$h = H-1, \dotsc, 1$}
    \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h  \}$
    \State $newVec\gets (0)_{k \in  \mathcal{K}^h}$
    \For{$k \in  \mathcal{K}^h$}
      \State $Succ_k \gets \{ k' \in  \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$
      \If{$Succ_k=\varnothing$}
        \State $newVec_k \gets \zeta_k\wedge|S\cap R_k|$
      \Else
        \State $newVec_k \gets \min\left( \zeta_{k}\wedge|S\cap R_k| ,  \sum_{k'\in Succ_k} Vec_{k'}   \right)$
      \EndIf
    \EndFor
    \State $Vec\gets newVec$
  \EndFor
  \Return $\sum_{k\in\mathcal{K}^1} Vec_k  $
\EndProcedure
\end{algorithmic}
\end{algorithm}
```
:::
::: {.content-hidden when-format="html"}
```pseudocode
#| label: alg-vstar
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Computation of a given $V^*_{\mathfrak{R}}(S)$}
\begin{algorithmic}
\Procedure{Vstar}{S, $\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete}
  \State $ H \gets \max_{k\in\mathcal{K}} \phi(k)  $ \Comment{maximum depth}
  \For{$h = H-1, \dotsc, 1$}
    \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h  \}$
    \State $newVec\gets (0)_{k \in  \mathcal{K}^h}$
    \For{$k \in  \mathcal{K}^h$}
      \State $Succ_k \gets \{ k' \in  \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$
      \If{$Succ_k=\varnothing$}
        \State $newVec_k \gets \zeta_k\wedge|S\cap R_k|$
      \Else
        \State $newVec_k \gets \min\left( \zeta_{k}\wedge|S\cap R_k| ,  \sum_{k'\in Succ_k} Vec_{k'}   \right)$
      \EndIf
    \EndFor
    \State $Vec\gets newVec$
  \EndFor
  \State\Return $\sum_{k\in\mathcal{K}^1} Vec_k  $
\EndProcedure
\end{algorithmic}
\end{algorithm}
```
:::

::: {.callout-tip}

In the practical implementation of this algorithm (and of the following @alg-pruning), $Vec$ and $newVec$ are always of size $N$ (the number of leaves) instead of the cardinality of $\cK^h$. And the sum $\sum_{k'\in Succ_k} Vec_{k'}$ is really easy to compute: if $R_k= R_{(i_0,i_{p}-1)}= \bigcup_{ j=1}^{p} R_{(i_{ j-1}, i_{ j}-1)}=\bigcup_{i_0\leq n\leq i_{p}-1}P_n\in\cK^h$ for some $p\geq2$, a strictly increasing sequence $(i_0,\dotsc,i_{p})$ and $R_{(i_{ j-1}, i_{ j}-1)}\in\cK^{h+1}$ for all $1\leq j\leq p$, then we simply sum $Vec$ over the indices from $i_{0}$ to $i_{p}-1$. After that, the computed quantity is set in $newVec$ at index $i_0$. So actually computing $Succ_k$ is not needed and not done.
:::

The computation time of the algorithm is in $O(m|\cK|)$, which is fast for a single evaluation, but calling it repeatedly on a path of selection sets $(S_t)_{t\in\Nm^*}$ has complexity $O(m^2|\cK|)$ which is not desirable and makes computations difficult in practice, hence the need for a new, faster algorithm.

::: {#rem-zeta}

The specific computation of the $R_k$'s and the $\zeta_k$'s such that Equation \eqref{eq_jer_control} holds is outside the scope of the present paper, but different constructions can be found in @MR4124323, @MR4178188 or @blain22notip for example.

:::

# New algorithms

## Pruning the forest {#sec-pruning}

We remark the simple fact that if, for example, $(1,1), (2,2), (1,2)\in\cK$, and $\zeta_{(1,2)}\geq \zeta_{(1,1)}+\zeta_{(2,2)}$, then $R_{(1,2)}$ never contributes to the computation of any $\Vstar(S)$ and it could just be removed from $\Rfam$. We now formalize and prove this pruning scheme.

::: {#def-pruning}

## Pruning

We define by $\cK^{\pr}$ ($\cK$ pruned) the set of elements of $\cK$ such that we removed all $(i,i')$ such that there exists $p\geq2$ and integers $i_1,\dotsc,i_{p-1}$ such that, when setting $i_0=i$ and $i_{p}=i'+1$, the sequence $(i_0,\dotsc,i_{p})$ is strictly increasing, $(i_{j-1},i_{j}-1)\in\cK$ for all $1\leq j\leq p$ and finally $\zeta_{(i,i')}=\zeta_{(i_0,i_{p}-1)}\geq \sum_{j=1}^{p} \zeta_{(i_{j-1}, i_{j}-1)}$.

:::

An important note is that for a removed $(i,i')\in\cK\setminus\cK^{\pr}$, we can always choose the indices $i_1,\dotsc,i_{p-1}$ such that actually $(i_j,i_{j+1}-1)\in\cK^{\pr}$ and not only $\cK$, because if  $(i_j,i_{j+1}-1)\in\cK\setminus\cK^{\pr}$ it can itself be fragmented, and this decreasing recursion eventually ends (the later possible being at the atoms of the forest structure). Also note that removing elements from $\cK$ does not alter the fact that we have at hand a forest structure, that is, the reference family defined by $\Rfam^{\pr}=(R_k,\zeta_k)_{k\in\cK^{\pr}}$ has a forest structure. Because pruning a forest structure does not touch the atoms, note finally that if $\cK$ is complete then so is $\cK^{\pr}$.

The following proposition states that pruning the forest does not alter the bound.

::: {#prp-pruning}

For any $S\subseteq \Nm^*$, $\Vstar(S)=V^*_{\Rfam^{\pr}}(S)$.

:::

::: {.proof}

Recall Equation \eqref{eq_vstar_Q} and, because $\Rfam^{\pr}$ also has a forest structure,
\begin{equation}
V^*_{\Rfam^{\pr}}(S)=\min_{Q\subseteq\cK^{\pr}}\left(\sum_{k'\in Q}\zeta_{k'}\wedge|S\cap R_{k'}|+\left| S\setminus\bigcup_{k'\in Q} R_{k'}   \right|\right),
\label{eq_vstarpruned_Q}
\end{equation}
so we immediately get that $\Vstar(S)\leq V^*_{\Rfam^{\pr}}(S)$. 

Let any $Q\subseteq \cK$. We split $Q$ in $A$ elements of $\cK\setminus\cK^{\pr}$, denoted $(i_{0,a}, i_{p_a,a}-1)$, $1\leq a\leq A$ for some $p_a\geq2$, and $B$ elements of $\cK^{\pr}$, simply denoted $k_b$, $1\leq b\leq B$. By the definition of $\cK^{\pr}$ and the previous remarks, for any $1\leq a \leq A$, there exist integers $i_{1,a},\dotsc,i_{p_a-1,a}$ such that $i_{0,a}<i_{1,a}<\dotsb<i_{p_a-1,a} < i_{p_a,a}$, $(i_{j-1,a},i_{j,a}-1)\in\cK^{\pr}$ for all $1\leq j\leq p_a$, and $\zeta_{(i_{0,a}, i_{p_a,a}-1)}\geq \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)}$. Now let
\begin{equation}
Q^{\pr}=\{k_b : 1\leq b\leq B \} \cup \{ (i_{j-1,a},i_{j,a}-1) :  1\leq a\leq A, 1\leq j\leq p_a  \}.
\label{eq_Qpr}
\end{equation}
We have that $Q^{\pr}\subseteq \cK^{\pr}$ and $\bigcup_{k\in Q}R_k=\bigcup_{k\in Q^{\pr}}R_k$. Then,
\begin{align*}
\sum_{k\in Q}\zeta_k\wedge|S\cap R_k|+\left| S\setminus\bigcup_{k\in Q} R_k   \right|&=\sum_{b=1}^B\zeta_{k_b}\wedge|S\cap R_{k_b}| \\
&\qquad+\sum_{a=1}^A\zeta_{(i_{0,a}, i_{p_a,a}-1)}\wedge |S\cap R_{(i_{0,a}, i_{p_a,a}-1)}| \\
&\qquad+ \left| S\setminus\bigcup_{k\in Q} R_k   \right|    , 
\end{align*}
but  for all $1\leq a\leq A$,
\begin{align*}
\zeta_{(i_{0,a}, i_{p_a,a}-1)}&\geq  \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} \\
&\geq   \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} \wedge |S\cap R_{(i_{j-1,a}, i_{j,a}-1)}| ,
\end{align*}
so the term $\sum_{a=1}^A\zeta_{(i_{0,a}, i_{p_a,a}-1)}\wedge |S\cap R_{(i_{0,a}, i_{p_a,a}-1)}|$ is greater than or equal to 
\begin{equation*}
\sum_{a=1}^A\left(  \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} \wedge |S\cap R_{(i_{j-1,a}, i_{j,a}-1)}| \right)\wedge |S\cap R_{(i_{0,a}, i_{p_a,a}-1)}| ,
\end{equation*}
 which is simply equal to
\begin{equation*}
 \sum_{a=1}^A  \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} \wedge |S\cap R_{(i_{j-1,a}, i_{j,a}-1)}|.
\end{equation*}
Furthermore $\left|S\setminus\bigcup_{k\in Q} R_k\right|= \left|S\setminus\bigcup_{k\in Q^{\pr}} R_k\right|$ so finally:
\begin{align}
\sum_{k\in Q}\zeta_k\wedge|S\cap R_k|+\left| S\setminus\bigcup_{k\in Q} R_k   \right| &\geq \sum_{k\in Q^{\pr}}\zeta_k\wedge|S\cap R_k|+\left| S\setminus\bigcup_{k\in Q^{\pr}} R_k   \right|   \label{pruning_ineq}\\
&\geq V^*_{\Rfam^{\pr}}(S). \notag
\end{align}
Note that Equation \eqref{pruning_ineq} is true even if there are some $b\in\{ 1,\dotsc,B\}, a\in\{ 1,\dotsc,A\}, j\in\{ 1,\dotsc,p_a\}$ such that $k_b=(i_{j-1,a}, i_{j,a}-1)$.
We minimize over all $Q$ to get that $\Vstar(S)\geq V^*_{\Rfam^{\pr}}(S)$. $\square$
:::

This gives a practical way to speed up computations by first pruning the family before computing any $\Vstar(S)$, because $\cK^{\pr}$ is smaller than $\cK$, and by the above Proposition there is no theoretical loss in doing so. 

Furthermore, pruning can be done really simply by following @alg-vstar for $S=\Nm^*$, and pruning when appropriate. This gives the following @alg-pruning, assuming, for simplicity, that the family is complete. The computation time of the algorithm is the same as @alg-vstar, that is $O(m|\cK|)$. Note that the only differences between @alg-pruning and @alg-vstar are the pruning step and $\zeta_k$ replacing $\zeta_k\wedge|S\cap R_k|$, because $\zeta_k\leq|R_k|$ and here $S=\Nm^*$, so $\zeta_k\wedge|\Nm^*\cap R_k|=\zeta_k$. Also note that the algorithm returns $\Vstar(\Nm^*)$ as a by-product. The following proposition states that @alg-pruning indeed produces the pruned region as in @def-pruning. 

::: {.content-visible when-format="html"}
```pseudocode
#| label: alg-pruning
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Pruning of $\mathfrak{R}$}
\begin{algorithmic}
\Procedure{Pruning}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete}
  \State $\mathcal{L}\gets\mathcal{K}$
  \State $ H \gets \max_{k\in\mathcal{K}} \phi(k)  $ \Comment{maximum depth}
  \For{$h = H-1, \dotsc, 1$}
    \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h  \}$
    \State $newVec\gets (0)_{k \in  \mathcal{K}^h}$
    \For{$k \in  \mathcal{K}^h$}
      \State $Succ_k \gets \{ k' \in  \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$
      \If{$Succ_k=\varnothing$}
        \State $newVec_k \gets \zeta_k$
      \Else
        \If{$\zeta_{k} \geq  \sum_{k'\in Succ_k} Vec_{k'}$}
          \State $\mathcal{L}\gets \mathcal{L}\setminus \{ k \}$ \Comment{pruning of the region indexed by $k$}
        \EndIf
        \State $newVec_k \gets \min\left( \zeta_{k} ,  \sum_{k'\in Succ_k} Vec_{k'}   \right)$
      \EndIf
    \EndFor
    \State $Vec\gets newVec$
  \EndFor
  \Return $(\mathcal{L},\sum_{k\in\mathcal{K}^1} Vec_k  )$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```
:::
::: {.content-hidden when-format="html"}
```pseudocode
#| label: alg-pruning
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Pruning of $\mathfrak{R}$}
\begin{algorithmic}
\Procedure{Pruning}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete}
  \State $\mathcal{L}\gets\mathcal{K}$
  \State $ H \gets \max_{k\in\mathcal{K}} \phi(k)  $ \Comment{maximum depth}
  \For{$h = H-1, \dotsc, 1$}
    \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h  \}$
    \State $newVec\gets (0)_{k \in  \mathcal{K}^h}$
    \For{$k \in  \mathcal{K}^h$}
      \State $Succ_k \gets \{ k' \in  \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$
      \If{$Succ_k=\varnothing$}
        \State $newVec_k \gets \zeta_k$
      \Else
        \If{$\zeta_{k} \geq  \sum_{k'\in Succ_k} Vec_{k'}$}
          \State $\mathcal{L}\gets \mathcal{L}\setminus \{ k \}$ \Comment{pruning of the region indexed by $k$}
        \EndIf
        \State $newVec_k \gets \min\left( \zeta_{k} ,  \sum_{k'\in Succ_k} Vec_{k'}   \right)$
      \EndIf
    \EndFor
    \State $Vec\gets newVec$
  \EndFor
  \State\Return $(\mathcal{L},\sum_{k\in\mathcal{K}^1} Vec_k  )$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```
:::

::: {#prp-pruning-correct}

The final $\mathcal{L}$ returned by @alg-pruning is equal to $\cK^{\pr}$: $\mathcal{L}=\cK^{\pr}$.

:::

::: {.proof}
First, $\cK\setminus\mathcal{L}\subseteq\cK\setminus\cK^{\pr}$ is trivial: a $k$ such that $\zeta_{k} \geq  \sum_{k'\in Succ_k} Vec_{k'}$ obviously satisfies the condition of @def-pruning to be pruned.

Now let $(i,i')\in \cK\setminus\cK^{\pr}$ an element that is pruned by @def-pruning, so there exists $p\geq2$ and integers $i_1,\dotsc,i_{p-1}$ such that, when setting $i_0=i$ and $i_{p}=i'+1$, the sequence $(i_0,\dotsc,i_{p})$ is strictly increasing, $(i_{j-1},i_{j}-1)\in\cK$ for all $1\leq j\leq p$ and finally $\zeta_{(i,i')}=\zeta_{(i_0,i_{p}-1)}\geq \sum_{j=1}^{p} \zeta_{(i_{j-1}, i_{j}-1)}$. Then by the proof of Theorem 1 of @MR4178188 but applied to $S=R_{(i,i')}$ we have that $\sum_{j=1}^{p} \zeta_{(i_{j-1}, i_{j}-1)}\geq  \sum_{k'\in Succ_{(i,i')}} Vec_{k'}$ (see the unnumbered line just above Equation (A4) in that paper) and so $\zeta_{(i,i')}\geq \sum_{k'\in Succ_{(i,i')}} Vec_{k'}$ hence $(i,i')$ is pruned by @alg-pruning and $\cK\setminus\cK^{\pr}\subseteq\cK\setminus\mathcal{L}$.

In the end, $\cK\setminus\cK^{\pr}=\cK\setminus\mathcal{L}$ so $\cK^{\pr}=\mathcal{L}$. $\square$
:::


## Fast algorithm to compute a curve of confidence bounds on a path of selection sets {#sec-fast-curve}

Let $(i_1,\dotsc, i_m)$ a permutation of $\Nm^*$, eventually random, and, for all $t\in\Nm^*$, let $S_t=\{i_1,\dotsc,i_t\}$ and $S_0=\varnothing$. For example, $(i_1,\dotsc, i_m)$ can be the permutation ordering the $p$-values in increasing order and in that case $S_t$ becomes the set of indices of the $t$ smallest $p$-values. Assume that we want to compute all $\Vstar(S_t)$ for all $t\in\{ 0,\dotsc,m\}$, this is what we call the curve of confidence bounds indexed by $(i_1,\dotsc, i_m)$. Applying @alg-vstar to compute $\Vstar(S_t)$ for a given $t$ has complexity $O(t|\cK|)$, so using it to sequentially compute the full curve has complexity $O\left(\sum_{t=0}^m t |\cK|\right)=O\left(m^2|\cK|\right)$. In this section, we present a new algorithm that computes the curve with a $O\left(m|\cK|\right)$ complexity. The algorithm will need that $\Rfam$ is complete, so if that is not the case we first need to complete $\Rfam$ following the Algorithm 2 of @MR4178188, which has a $O(m|\cK|)$ complexity. In the remainder of this section we assume that $\Rfam$ is complete.

We first recall and introduce some notation. Recall that $\phi$ is the depth function inside of $\Rfam$, that $\mathfrak P \subseteq \mathcal P(\cK)$ is the set of subsets of $\cK$ that realize a partition, recall the important result stated by Equation \eqref{eq_vstar_Qpartition}, and that $\cK^h=\{ k\in\cK : \phi(k)=h  \}$ for all $1\leq h\leq H$ where $H=\max_{k\in\cK}\phi(k)$. For any $t\in\Nm^*$ and $1\leq h\leq H$, we denote by $\kth{t}{h}$ the element of $\cK^h$ such that $i_t\in R_{\kth{t}{h}}$ if it exists, and we denote by $h_{\max}(t)$ the highest $h$ such that $\kth{t}{h}$ exists.

::: {#exm-kth}

## Continuation of @exm-toy-forest and @exm-toy-leaves

Assume that the reference family of @exm-toy-forest has been labeled as in @exm-toy-leaves and completed. Let $(i_1,\dotsc, i_{25})$ such that $i_1=7$, $i_2=1$ and $i_3=24$. Then for $t=1$, $\kth{t}{1}=(1,5)$, $\kth{t}{2}=(2,3)$, $\kth{t}{3}=(3,3)$ and $h_{\max}(t)=H=3$. For $t=2$, $\kth{t}{1}=(1,5)$, $\kth{t}{2}=(1,1)$, $\kth{t}{3}$ does not exist and $h_{\max}(t)=2$. For $t=3$, $\kth{t}{1}=(8,8)$, $\kth{t}{2}$ does not exist and $h_{\max}(t)=1$.

:::

Now we can finally present the new algorithm and the proof that it computes the curve $(\Vstar(S_t))_{t\in\Nm}$. We present two versions of the algorithm (strictly equivalent): one very formal (@alg-formal-curve), to introduce additional notation used in the proof of @thm-curve-path, and, later, a simpler version that is the one actually implemented (@alg-curve). Recall that a detailed illustration of the steps of the algorithms will be provided in @sec-example.

::: {.content-visible when-format="html"}
```pseudocode
#| label: alg-formal-curve
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Formal computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}
\begin{algorithmic}
\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}
  \State $\mathcal{P}^0\gets\{(i,i): 1\leq i \leq n\}$ \Comment{the set of all atoms indices}
  \State $\mathcal{K}^-_0\gets\{k\in\mathcal{K} : \zeta_k=0  \}$
  \State $\eta^0_k\gets0$ for all $k\in\mathcal{K}$
  \For{$t=1,\dotsc, m$}
    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-_{t-1}}R_k$}
      \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$
      \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$
      \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$
    \Else
      \For{$h=1,\dotsc,h_{\max}(t)$}
        \State $\eta^t_{k^{(t,h)}}\gets\eta^{t-1}_{k^{(t,h)}} + 1$
        \If{$\eta^t_{k^{(t,h)}}<\zeta_k$}
          \State Pass
        \Else
          \State $h^f_t \gets h$ \Comment{final depth}
          \State $\mathcal{P}^t \gets\left( \mathcal{P}^{t-1}\setminus \{ k\in \mathcal{P}^{t-1} : R_k\subseteq R_{k^{(t,h^f_t)}} \}\right)\cup \{ k^{(t,h^f_t)} \}$
          \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1} \cup \{k^{(t,h^f_t)}\}$
          \State Break the loop
        \EndIf
      \EndFor
      \If{the loop has been broken}
        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h^f_t   \}$
      \Else
        \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$
        \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$
        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h_{\max}(t)   \}$
      \EndIf
    \EndIf
  \EndFor
  \Return $\mathcal{P}^t, \eta^t_k$ for all $t=1,\dotsc, m$ and $k\in\mathcal{K}$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```
:::
::: {.content-hidden when-format="html"}
```pseudocode
#| label: alg-formal-curve
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Formal computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}
\begin{algorithmic}
\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}
  \State $\mathcal{P}^0\gets\{(i,i): 1\leq i \leq n\}$ \Comment{the set of all atoms indices}
  \State $\mathcal{K}^-_0\gets\{k\in\mathcal{K} : \zeta_k=0  \}$
  \State $\eta^0_k\gets0$ for all $k\in\mathcal{K}$
  \For{$t=1,\dotsc, m$}
    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-_{t-1}}R_k$}
      \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$
      \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$
      \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$
    \Else
      \For{$h=1,\dotsc,h_{\max}(t)$}
        \State $\eta^t_{k^{(t,h)}}\gets\eta^{t-1}_{k^{(t,h)}} + 1$
        \If{$\eta^t_{k^{(t,h)}}<\zeta_k$}
          \State Pass
        \Else
          \State $h^f_t \gets h$ \Comment{final depth}
          \State $\mathcal{P}^t \gets\left( \mathcal{P}^{t-1}\setminus \{ k\in \mathcal{P}^{t-1} : R_k\subseteq R_{k^{(t,h^f_t)}} \}\right)\cup \{ k^{(t,h^f_t)} \}$
          \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1} \cup \{k^{(t,h^f_t)}\}$
          \State Break the loop
        \EndIf
      \EndFor
      \If{the loop has been broken}
        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h^f_t   \}$
      \Else
        \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$
        \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$
        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h_{\max}(t)   \}$
      \EndIf
    \EndIf
  \EndFor
  \State\Return $\mathcal{P}^t, \eta^t_k$ for all $t=1,\dotsc, m$ and $k\in\mathcal{K}$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```
:::
The core idea of the algorithm is that, as we increase $t$ and add new hypotheses in $S_t$, we inflate a counter $\eta_k^t$ for each region $R_k$, by 1 if $i_t\in R_k$ (line 12), by 0 if not (lines 23 and 27), but only until the counter reaches $\zeta_k$ (line 13). After this point, the hypotheses in $R_k$ don't contribute to $\Vstar(S_t)$, we keep track of those hypotheses with $\cK^-_t$ (line 6), so as soon as $\eta^t_{\kth th}=\zeta_k$ we update $\cK^-_t$ by adding $\kth th$ (line 18) to it and we update $\cP^t$ accordingly (line 17). 

We will see in the following @thm-curve-path how this algorithm allows to compute $\Vstar(S_t)$. We first need a final notation. Let
\begin{equation*}
\cK_t=\{k\in\cK : \exists k'\in \cP^t : R_{k'}\subseteq R_k   \}.
\end{equation*}
The elements of $\cK_t$ index the regions of the forest that ``are above'' the regions of the current partition-realizing $\cP^t$. In particular, we always have, for any $t\in\Nm$, $\cK^1\subseteq\cK_t$ and $\cP^t\subseteq \cK_t$. We can also remark that the sequence $(\cK_t)_{0\leq t \leq m}$ is non-increasing for the inclusion relation, and that $\cK_0=\cK$.

::: {#thm-curve-path}

## Fast curve computation

Let any $t\in\Nm$. Then, $\cP^t\in\mathfrak P$, and for all $k\in\cK_t$, we have
\begin{equation}
\Vstar(S_t\cap R_k) = \eta_k^t
\label{eq_vstar_inter_Rk_equal_eta}
\end{equation}
and
\begin{equation}
\Vstar(S_t\cap R_k) = \sum_{\substack{k'\in \cP^t\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge|S_t \cap R_{k'}|.
\label{eq_Pt_good_partition}
\end{equation}
Furthermore,
\begin{equation}
\Vstar(S_t)  = \sum_{{k\in \cP^t}} \zeta_{k}\wedge|S_t \cap R_{k}|= \sum_{k\in\cK^1} \eta_k^t.
\label{eq_vstar_equal_sum_eta}
\end{equation}
:::

The proof of this Theorem is postponed to @sec-proof. The first equality of Equation \eqref{eq_vstar_equal_sum_eta} states that the minimum in \eqref{eq_vstar_Qpartition} is realized on the partition $\cP^t$, and the last equality of the same Equation is the basis of the following light corollary.

::: {#cor-easy-impl}

## Easy computation

For $t\in\{0,\dotsc, m-1 \}$, $V^*_{\Rfam}(S_{t+1})=V^*_{\Rfam}(S_{t})$ if $i_{t+1}\in \bigcup_{k\in\cK^-_t}R_k$, and  $V^*_{\Rfam}(S_{t+1})=V^*_{\Rfam}(S_{t}) + 1$ if not.

:::
::: {.proof}
From \eqref{eq_vstar_equal_sum_eta}, $V^*_{\Rfam}(S_{t+1})=\sum_{k\in\cK^1} \eta_k^{t+1}$ and $V^*_{\Rfam}(S_{t})=\sum_{k\in\cK^1} \eta_k^{t}$. If $i_{t+1}\in \bigcup_{k\in\cK^-_t}R_k$, $\eta_k^{t+1}=\eta_k^{t}$ for all $k\in\cK^1$. If not, $\eta_k^{t+1}=\eta_k^{t}$ for all $k\in\cK^1$, $k\neq \kth{t+1}{1}$, whereas for $k= \kth{t+1}{1}$, $\eta_k^{t+1}=\eta_k^{t}+1$. $\square$
:::

We note that, from @thm-curve-path and @cor-easy-impl, if one is only interested in the computation of the curve $\left(V^*_{\Rfam}(S_{t})\right)_{1\leq t\leq m}$, tracking $\cP^t$ is actually useless, what is important is to track and update $\cK^-_t$ correctly. Hence the simpler, alternative  @alg-curve. Note that @alg-curve is less formal than @alg-formal-curve: as in @alg-vstar and @alg-pruning, it recycles notation (mimicking the actual code implementation) so the $t$ subscript or superscript is dropped from the $\cK^-_t$ and the $\eta_k^t$. In @alg-curve, the notation $V_t$ is actually equal to $V^*_{\Rfam}(S_{t})$ by @cor-easy-impl.

::: {.content-visible when-format="html"}
```pseudocode
#| label: alg-curve
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Practical computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}
\begin{algorithmic}
\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}
  \State $V_0\gets 0$
  \State $\mathcal{K}^-\gets\{k\in\mathcal{K} : \zeta_k=0  \}$
  \State $\eta_k\gets 0$ for all $k\in\mathcal{K}$
  \For{$t=1,\dotsc, m$}
    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-}R_k$}
      \State $V_{t}\gets V_{t-1}$
    \Else
      \For{$h=1,\dotsc,h_{\max}(t)$}
        \State find $k^{(t,h)}\in\mathcal{K}^{h}$ such that $i_t\in R_{k^{(t,h)}}$
        \State $\eta_{k^{(t,h)}}\gets\eta_{k^{(t,h)}} + 1$
        \If{$\eta_{k^{(t,h)}}<\zeta_k$}
          \State pass
        \Else
          \State $\mathcal{K}^- \gets \mathcal{K}^-\cup \{ k^{(t,h)} \}$
          \State break the loop
        \EndIf
      \EndFor
     \State $V_{t}\gets V_{t-1} + 1$
    \EndIf
  \EndFor
  \Return $(V_t)_{1\leq t \leq m}$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```
:::
::: {.content-hidden when-format="html"}
```pseudocode
#| label: alg-curve
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Practical computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}
\begin{algorithmic}
\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}
  \State $V_0\gets 0$
  \State $\mathcal{K}^-\gets\{k\in\mathcal{K} : \zeta_k=0  \}$
  \State $\eta_k\gets 0$ for all $k\in\mathcal{K}$
  \For{$t=1,\dotsc, m$}
    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-}R_k$}
      \State $V_{t}\gets V_{t-1}$
    \Else
      \For{$h=1,\dotsc,h_{\max}(t)$}
        \State find $k^{(t,h)}\in\mathcal{K}^{h}$ such that $i_t\in R_{k^{(t,h)}}$
        \State $\eta_{k^{(t,h)}}\gets\eta_{k^{(t,h)}} + 1$
        \If{$\eta_{k^{(t,h)}}<\zeta_k$}
          \State pass
        \Else
          \State $\mathcal{K}^- \gets \mathcal{K}^-\cup \{ k^{(t,h)} \}$
          \State break the loop
        \EndIf
      \EndFor
     \State $V_{t}\gets V_{t-1} + 1$
    \EndIf
  \EndFor
  \State\Return $(V_t)_{1\leq t \leq m}$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```
:::

It is easy to see that each step $t$ has a complexity in $O(|\cK|)$ hence the total complexity is in $O(m|\cK|)$. This is because, if the regions are carefully stocked in memory, especially if their bounds (in terms of hypothesis index) are stocked, then finding $\kth th$ has a complexity in $O(|\cK^h|)$ and checking if $i_t\in\bigcup_{k\in\cK^-_{t-1}}R_k$ has a complexity in $O(|\cK|)$.

## Illustration on a detailed example {#sec-example}

We still continue @exm-toy-forest and @exm-toy-leaves. Recall that $m=25$, $P_{1:5}=R_1 = \{1, \dotsc , 20 \}$, $P_1=R_2  =  \{1, 2  \}$, $P_{2:3}=R_3   =   \{3 , \dotsc , 10 \}$, $P_{4:5}=R_4  =    \{11, \dotsc , 20 \}$, $P_2=\{3,4\}$, $P_3=R_5 =  \{5, \dotsc , 10 \}$, $P_4=R_6   =     \{11, \dotsc , 16 \}$, $P_5=R_7  =   \{17, \dotsc ,20  \}$, $P_{6:7}=R_8=\{21,22\}$, $P_6=\{21\}$, $P_7=R_9 = \{22\}$ and $P_8=\{23,24,25\}$. 

Now assume that we have the following values for the $\zeta_k$'s: $\zeta_{(1,5)}=6$, $\zeta_{(1, 1)}=2$, $\zeta_{(2, 3)}=1$, $\zeta_{(3, 3)}=4$, $\zeta_{(4, 5)}=4$, $\zeta_{(4, 4)}=2$, $\zeta_{(5, 5)}=3$, $\zeta_{(6, 7)}=2$, $\zeta_{(7, 7)}=0$. Because $P_2$, $P_6$ and $P_8$ come from the completion operation (see @sec-forest-structure), we also have $\zeta_{(2, 2)}=|P_2|=2$, $\zeta_{(6, 6)}=|P_6|=1$ and $\zeta_{(8, 8)}=|P_8|=3$. Theses values are summarized in @fig-zetas.

:::{#fig-zetas}

``` tikz
%%| filename: ../figure-tikz/fig-tikz-03
\begin{tikzpicture}[scale=1]
 \tikzstyle{quadri}=[circle, draw, text=black, thick, align=center]
 \tikzstyle{estun}=[->, >=latex, very thick]
 %
 \node[quadri] (P15) at (0, 3) {$P_{1:5}$\\$\zeta_{(1, 5)}=6$};
 \node[quadri] (P67) at (7.5, 3) {$P_{6:7}$\\$\zeta_{(6, 7)}=2$};
 \node[quadri] (P8) at (10.5, 3) {$P_8$\\$\zeta_{(8, 8)}=3$};
 %
 \node[quadri] (P1) at (-3, 0) {$P_1$\\$\zeta_{(1, 1)}=2$};
 \node[quadri] (P23) at (0, 0) {$P_{2:3}$\\$\zeta_{(2, 3)}=1$};
 \node[quadri] (P45) at (3, 0) {$P_{4:5}$\\$\zeta_{(4, 5)}=4$};
 \node[quadri] (P6) at (6, 0) {$P_6$\\$\zeta_{(6, 6)}=1$};
 \node[quadri] (P7) at (9, 0) {$P_7$\\$\zeta_{(7, 7)}=0$};
 %
 \node[quadri] (P2) at (-2, -3) {$P_2$\\$\zeta_{(2, 2)}=2$};
 \node[quadri] (P3) at (0.25, -3) {$P_3$\\$\zeta_{(3, 3)}=4$};
 \node[quadri] (P4) at (2.75, -3) {$P_4$\\$\zeta_{(4, 4)}=2$};
 \node[quadri] (P5) at (5, -3) {$P_5$\\$\zeta_{(5, 5)}=3$};
 %%
 \draw[estun] (P15)--(P1);
 \draw[estun] (P15)--(P23);
 \draw[estun] (P15)--(P45);
 \draw[estun] (P23)--(P3);
 \draw[estun] (P23)--(P2);
 \draw[estun] (P45)--(P4);
 \draw[estun] (P45)--(P5);
 \draw[estun] (P67)--(P7);
 \draw[estun] (P67)--(P6);
\end{tikzpicture}
```

The regions of @exm-toy-forest with the $\zeta_k$ values.

:::

We want to compute the curve $\left(\Vstar\left(S_t\right)\right)_{1\leq t\leq 9}$ with $S_t=\{i_1,\dotsc, i_t\}$ and $i_1=11$, $i_2=17$, $i_3=12$, $i_4=13$, $i_5=18$, $i_6=3$, $i_7=19$, $i_8=22$ and $i_9=5$.

First, we apply @alg-pruning to the family. This results in pruning $P_{6:7}$ (and only this region), because $2=\zeta_{(6, 7)}\geq \zeta_{(6, 6)}+\zeta_{(7, 7)}=1+0$. This gives @fig-pruned.

:::{#fig-pruned}

``` tikz
%%| filename: ../figure-tikz/fig-tikz-04
\begin{tikzpicture}[scale=1]
 \tikzstyle{quadri}=[circle, draw, text=black, thick, align=center]
 \tikzstyle{estun}=[->, >=latex, very thick]
 %
 \node[quadri] (P15) at (0, 3) {$P_{1:5}$\\$\zeta_{(1, 5)}=6$};
 \node[quadri] (P8) at (11, 3) {$P_8$\\$\zeta_{(8, 8)}=3$};
 %
 \node[quadri] (P1) at (-3, 0) {$P_1$\\$\zeta_{(1, 1)}=2$};
 \node[quadri] (P23) at (0, 0) {$P_{2:3}$\\$\zeta_{(2, 3)}=1$};
 \node[quadri] (P45) at (3, 0) {$P_{4:5}$\\$\zeta_{(4, 5)}=4$};
 \node[quadri] (P6) at (5, 3) {$P_6$\\$\zeta_{(6, 6)}=1$};
 \node[quadri] (P7) at (8, 3) {$P_7$\\$\zeta_{(7, 7)}=0$};
 %
 \node[quadri] (P2) at (-2, -3) {$P_2$\\$\zeta_{(2, 2)}=2$};
 \node[quadri] (P3) at (0.25, -3) {$P_3$\\$\zeta_{(3, 3)}=4$};
 \node[quadri] (P4) at (2.75, -3) {$P_4$\\$\zeta_{(4, 4)}=2$};
 \node[quadri] (P5) at (5, -3) {$P_5$\\$\zeta_{(5, 5)}=3$};
 %%
 \draw[estun] (P15)--(P1);
 \draw[estun] (P15)--(P23);
 \draw[estun] (P15)--(P45);
 \draw[estun] (P23)--(P3);
 \draw[estun] (P23)--(P2);
 \draw[estun] (P45)--(P4);
 \draw[estun] (P45)--(P5);
\end{tikzpicture}
```

The regions of @exm-toy-forest after pruning.

:::

Now we initialize @alg-formal-curve, that is we let $t=0$. Because $\zeta_{(7,7)}=0$, $(7, 7)$ is added to $\cK^-_t$: $\cK^-_0=\{(7, 7)\}$. Furthermore, all $\eta_k^t$ are set to 0. The initial state of @alg-formal-curve is shown in @fig-t0, with $(7, 7)$ being in red to show that it will not contribute to the computations.

:::{#fig-t0}

``` tikz
%%| filename: ../figure-tikz/fig-tikz-05
\begin{tikzpicture}[scale=1]
 \tikzstyle{quadri}=[circle, draw, text=black, thick, align=center]
 \tikzstyle{estun}=[->, >=latex, very thick]
 %
 \node[quadri] (P15) at (0, 3) {$P_{1:5}$\\$\zeta_{(1, 5)}=6$\\$\eta_{(1, 5)}^0=0$};
 \node[quadri] (P8) at (11, 3) {$P_8$\\$\zeta_{(8, 8)}=3$\\$\eta_{(8, 8)}^0=0$};
 %
 \node[quadri] (P1) at (-3, 0) {$P_1$\\$\zeta_{(1, 1)}=2$\\$\eta_{(1, 1)}^0=0$};
 \node[quadri] (P23) at (0, 0) {$P_{2:3}$\\$\zeta_{(2, 3)}=1$\\$\eta_{(2, 3)}^0=0$};
 \node[quadri] (P45) at (3, 0) {$P_{4:5}$\\$\zeta_{(4, 5)}=4$\\$\eta_{(4, 5)}^0=0$};
 \node[quadri] (P6) at (5, 3) {$P_6$\\$\zeta_{(6, 6)}=1$\\$\eta_{(6, 6)}^0=0$};
 \node[quadri, red] (P7) at (8, 3) {$P_7$\\$\zeta_{(7, 7)}=0$\\$\eta_{(7, 7)}^0=0$};
 %
 \node[quadri] (P2) at (-3, -3) {$P_2$\\$\zeta_{(2, 2)}=2$\\$\eta_{(2, 2)}^0=0$};
 \node[quadri] (P3) at (-0, -3) {$P_3$\\$\zeta_{(3, 3)}=4$\\$\eta_{(3, 3)}^0=0$};
 \node[quadri] (P4) at (3, -3) {$P_4$\\$\zeta_{(4, 4)}=2$\\$\eta_{(4, 4)}^0=0$};
 \node[quadri] (P5) at (6, -3) {$P_5$\\$\zeta_{(5, 5)}=3$\\$\eta_{(5, 5)}^0=0$};
 %%
 \draw[estun] (P15)--(P1);
 \draw[estun] (P15)--(P23);
 \draw[estun] (P15)--(P45);
 \draw[estun] (P23)--(P3);
 \draw[estun] (P23)--(P2);
 \draw[estun] (P45)--(P4);
 \draw[estun] (P45)--(P5);
\end{tikzpicture}
```

The regions of @exm-toy-forest at $t=0$ in @alg-formal-curve.

:::

We move on to $t=1$, with $i_1=11$. $i_1\in P_4\subseteq P_{4:5}\subseteq P_{1:5}$. The appropriate $\eta_k^t$ are increased by one, and by \eqref{eq_vstar_equal_sum_eta} we have $\Vstar(S_1)=\eta_{(1, 5)}^1+\eta_{(6, 6)}^1+\eta_{(7, 7)}^1+\eta_{(8, 8)}^1=1+0+0+0=1$. The state of the step is summarized in @fig-t1.

:::{#fig-t1}

``` tikz
%%| filename: ../figure-tikz/fig-tikz-06
\begin{tikzpicture}[scale=1]
 \tikzstyle{quadri}=[circle, draw, text=black, thick, align=center]
 \tikzstyle{estun}=[->, >=latex, very thick]
 %
 \node[quadri] (P15) at (0, 3) {$P_{1:5}$\\$\zeta_{(1, 5)}=6$\\$\eta_{(1, 5)}^1=1$};
 \node[quadri] (P8) at (11, 3) {$P_8$\\$\zeta_{(8, 8)}=3$\\$\eta_{(8, 8)}^1=0$};
 %
 \node[quadri] (P1) at (-3, 0) {$P_1$\\$\zeta_{(1, 1)}=2$\\$\eta_{(1, 1)}^1=0$};
 \node[quadri] (P23) at (0, 0) {$P_{2:3}$\\$\zeta_{(2, 3)}=1$\\$\eta_{(2, 3)}^1=0$};
 \node[quadri] (P45) at (3, 0) {$P_{4:5}$\\$\zeta_{(4, 5)}=4$\\$\eta_{(4, 5)}^1=1$};
 \node[quadri] (P6) at (5, 3) {$P_6$\\$\zeta_{(6, 6)}=1$\\$\eta_{(6, 6)}^1=0$};
 \node[quadri, red] (P7) at (8, 3) {$P_7$\\$\zeta_{(7, 7)}=0$\\$\eta_{(7, 7)}^1=0$};
 %
 \node[quadri] (P2) at (-3, -3) {$P_2$\\$\zeta_{(2, 2)}=2$\\$\eta_{(2, 2)}^1=0$};
 \node[quadri] (P3) at (-0, -3) {$P_3$\\$\zeta_{(3, 3)}=4$\\$\eta_{(3, 3)}^1=0$};
 \node[quadri] (P4) at (3, -3) {$P_4$\\$\zeta_{(4, 4)}=2$\\$\eta_{(4, 4)}^1=1$};
 \node[quadri] (P5) at (6, -3) {$P_5$\\$\zeta_{(5, 5)}=3$\\$\eta_{(5, 5)}^1=0$};
 %%
 \draw[estun] (P15)--(P1);
 \draw[estun] (P15)--(P23);
 \draw[estun] (P15)--(P45);
 \draw[estun] (P23)--(P3);
 \draw[estun] (P23)--(P2);
 \draw[estun] (P45)--(P4);
 \draw[estun] (P45)--(P5);
\end{tikzpicture}
```

The regions of @exm-toy-forest at $t=1$ in @alg-formal-curve.

:::

We move on to $t=2$, with $i_2=17$. $i_1\in P_5\subseteq P_{4:5}\subseteq P_{1:5}$. The appropriate $\eta_k^t$ are increased by one, and by \eqref{eq_vstar_equal_sum_eta} we have $\Vstar(S_2)=2$. The state of the step is summarized in @fig-t2.

:::{#fig-t2}

``` tikz
%%| filename: ../figure-tikz/fig-tikz-07
\begin{tikzpicture}[scale=1]
 \tikzstyle{quadri}=[circle, draw, text=black, thick, align=center]
 \tikzstyle{estun}=[->, >=latex, very thick]
 %
 \node[quadri] (P15) at (0, 3) {$P_{1:5}$\\$\zeta_{(1, 5)}=6$\\$\eta_{(1, 5)}^2=2$};
 \node[quadri] (P8) at (11, 3) {$P_8$\\$\zeta_{(8, 8)}=3$\\$\eta_{(8, 8)}^2=0$};
 %
 \node[quadri] (P1) at (-3, 0) {$P_1$\\$\zeta_{(1, 1)}=2$\\$\eta_{(1, 1)}^2=0$};
 \node[quadri] (P23) at (0, 0) {$P_{2:3}$\\$\zeta_{(2, 3)}=1$\\$\eta_{(2, 3)}^2=0$};
 \node[quadri] (P45) at (3, 0) {$P_{4:5}$\\$\zeta_{(4, 5)}=4$\\$\eta_{(4, 5)}^2=2$};
 \node[quadri] (P6) at (5, 3) {$P_6$\\$\zeta_{(6, 6)}=1$\\$\eta_{(6, 6)}^2=0$};
 \node[quadri, red] (P7) at (8, 3) {$P_7$\\$\zeta_{(7, 7)}=0$\\$\eta_{(7, 7)}^2=0$};
 %
 \node[quadri] (P2) at (-3, -3) {$P_2$\\$\zeta_{(2, 2)}=2$\\$\eta_{(2, 2)}^2=0$};
 \node[quadri] (P3) at (-0, -3) {$P_3$\\$\zeta_{(3, 3)}=4$\\$\eta_{(3, 3)}^2=0$};
 \node[quadri] (P4) at (3, -3) {$P_4$\\$\zeta_{(4, 4)}=2$\\$\eta_{(4, 4)}^2=1$};
 \node[quadri] (P5) at (6, -3) {$P_5$\\$\zeta_{(5, 5)}=3$\\$\eta_{(5, 5)}^2=1$};
 %%
 \draw[estun] (P15)--(P1);
 \draw[estun] (P15)--(P23);
 \draw[estun] (P15)--(P45);
 \draw[estun] (P23)--(P3);
 \draw[estun] (P23)--(P2);
 \draw[estun] (P45)--(P4);
 \draw[estun] (P45)--(P5);
\end{tikzpicture}
```

The regions of @exm-toy-forest at $t=2$ in @alg-formal-curve.

:::

We move on to $t=3$, with $i_3=12$. $i_3\in P_4\subseteq P_{4:5}\subseteq P_{1:5}$. The appropriate $\eta_k^t$ are increased by one, and we notice that $\eta_{(4, 4)}^3=2=\zeta_{(4, 4)}$. So $P_4$ will stop contributing, we add it to $\cK^-_t$: $\cK^-_3=\{(4, 4), (7, 7)\}$. By \eqref{eq_vstar_equal_sum_eta}, we have $\Vstar(S_3)=3$. The state of the step is summarized in @fig-t3, with $P_4$ now also in red.

:::{#fig-t3}

``` tikz
%%| filename: ../figure-tikz/fig-tikz-08
\begin{tikzpicture}[scale=1]
 \tikzstyle{quadri}=[circle, draw, text=black, thick, align=center]
 \tikzstyle{estun}=[->, >=latex, very thick]
 %
 \node[quadri] (P15) at (0, 3) {$P_{1:5}$\\$\zeta_{(1, 5)}=6$\\$\eta_{(1, 5)}^3=3$};
 \node[quadri] (P8) at (11, 3) {$P_8$\\$\zeta_{(8, 8)}=3$\\$\eta_{(8, 8)}^3=0$};
 %
 \node[quadri] (P1) at (-3, 0) {$P_1$\\$\zeta_{(1, 1)}=2$\\$\eta_{(1, 1)}^3=0$};
 \node[quadri] (P23) at (0, 0) {$P_{2:3}$\\$\zeta_{(2, 3)}=1$\\$\eta_{(2, 3)}^3=0$};
 \node[quadri] (P45) at (3, 0) {$P_{4:5}$\\$\zeta_{(4, 5)}=4$\\$\eta_{(4, 5)}^3=3$};
 \node[quadri] (P6) at (5, 3) {$P_6$\\$\zeta_{(6, 6)}=1$\\$\eta_{(6, 6)}^3=0$};
 \node[quadri, red] (P7) at (8, 3) {$P_7$\\$\zeta_{(7, 7)}=0$\\$\eta_{(7, 7)}^3=0$};
 %
 \node[quadri] (P2) at (-3, -3) {$P_2$\\$\zeta_{(2, 2)}=2$\\$\eta_{(2, 2)}^3=0$};
 \node[quadri] (P3) at (-0, -3) {$P_3$\\$\zeta_{(3, 3)}=4$\\$\eta_{(3, 3)}^3=0$};
 \node[quadri, red] (P4) at (3, -3) {$P_4$\\$\zeta_{(4, 4)}=2$\\$\eta_{(4, 4)}^3=2$};
 \node[quadri] (P5) at (6, -3) {$P_5$\\$\zeta_{(5, 5)}=3$\\$\eta_{(5, 5)}^3=1$};
 %%
 \draw[estun] (P15)--(P1);
 \draw[estun] (P15)--(P23);
 \draw[estun] (P15)--(P45);
 \draw[estun] (P23)--(P3);
 \draw[estun] (P23)--(P2);
 \draw[estun] (P45)--(P4);
 \draw[estun] (P45)--(P5);
\end{tikzpicture}
```

The regions of @exm-toy-forest at $t=3$ in @alg-formal-curve.

:::

We move on to $t=4$, with $i_4=13$. $i_4\in P_4\in \bigcup_{k\in\cK^-_3}R_k$. No $\eta_k^t$ is increased (see line 9 of @alg-formal-curve), and by \eqref{eq_vstar_equal_sum_eta}, we have $\Vstar(S_4)=3$.

We move on to $t=5$, with $i_5=18$. $i_5\in P_5\subseteq P_{4:5}\subseteq P_{1:5}$. We first increase $\eta_{(1,5)}^t$: $\eta_{(1,5)}^5=4<\zeta_{(1,5)}$, then $\eta_{(4,5)}^t$: $\eta_{(4,5)}^5=4$, and we stop there because $\eta_{(4,5)}^5=4=\zeta_{(4,5)}$. $P_{4:5}$ will stop contributing, we add it to $\cK^-_t$: $\cK^-_5=\{(4,5), (4, 4), (7, 7)\}$. Note that $\eta_{(5,5)}^t$ is not updated because we stopped the loop before, see line 23 of @alg-formal-curve. By \eqref{eq_vstar_equal_sum_eta}, we have $\Vstar(S_5)=4$. The state of the step is summarized in @fig-t5, with $P_{4:5}$ now also in red.

:::{#fig-t5}

``` tikz
%%| filename: ../figure-tikz/fig-tikz-09
\begin{tikzpicture}[scale=1]
 \tikzstyle{quadri}=[circle, draw, text=black, thick, align=center]
 \tikzstyle{estun}=[->, >=latex, very thick]
 %
 \node[quadri] (P15) at (0, 3) {$P_{1:5}$\\$\zeta_{(1, 5)}=6$\\$\eta_{(1, 5)}^5=4$};
 \node[quadri] (P8) at (11, 3) {$P_8$\\$\zeta_{(8, 8)}=3$\\$\eta_{(8, 8)}^5=0$};
 %
 \node[quadri] (P1) at (-3, 0) {$P_1$\\$\zeta_{(1, 1)}=2$\\$\eta_{(1, 1)}^5=0$};
 \node[quadri] (P23) at (0, 0) {$P_{2:3}$\\$\zeta_{(2, 3)}=1$\\$\eta_{(2, 3)}^5=0$};
 \node[quadri, red] (P45) at (3, 0) {$P_{4:5}$\\$\zeta_{(4, 5)}=4$\\$\eta_{(4, 5)}^5=4$};
 \node[quadri] (P6) at (5, 3) {$P_6$\\$\zeta_{(6, 6)}=1$\\$\eta_{(6, 6)}^5=0$};
 \node[quadri, red] (P7) at (8, 3) {$P_7$\\$\zeta_{(7, 7)}=0$\\$\eta_{(7, 7)}^5=0$};
 %
 \node[quadri] (P2) at (-3, -3) {$P_2$\\$\zeta_{(2, 2)}=2$\\$\eta_{(2, 2)}^5=0$};
 \node[quadri] (P3) at (-0, -3) {$P_3$\\$\zeta_{(3, 3)}=4$\\$\eta_{(3, 3)}^5=0$};
 \node[quadri, red] (P4) at (3, -3) {$P_4$\\$\zeta_{(4, 4)}=2$\\$\eta_{(4, 4)}^5=2$};
 \node[quadri] (P5) at (6, -3) {$P_5$\\$\zeta_{(5, 5)}=3$\\$\eta_{(5, 5)}^5=1$};
 %%
 \draw[estun] (P15)--(P1);
 \draw[estun] (P15)--(P23);
 \draw[estun] (P15)--(P45);
 \draw[estun] (P23)--(P3);
 \draw[estun] (P23)--(P2);
 \draw[estun] (P45)--(P4);
 \draw[estun] (P45)--(P5);
\end{tikzpicture}
```

The regions of @exm-toy-forest at $t=5$ in @alg-formal-curve.

:::

We move on to $t=6$, with $i_6=3$. $i_6\in P_3\subseteq P_{2:3}\subseteq P_{1:5}$. We first increase $\eta_{(1,5)}^t$: $\eta_{(1,5)}^6=5<\zeta_{(1,5)}$, then $\eta_{(2,3)}^t$: $\eta_{(2,3)}^6=1$, and we stop there because $\eta_{(2,3)}^6=1=\zeta_{(2,3)}$. $P_{2:3}$ will stop contributing, we add it to $\cK^-_t$: $\cK^-_6=\{(2,3), (4,5), (4, 4), (7, 7)\}$. Note that $\eta_{(3,3)}^t$ is not updated because we stopped the loop before, see line 23 of @alg-formal-curve. By \eqref{eq_vstar_equal_sum_eta}, we have $\Vstar(S_6)=5$. The state of the step is summarized in @fig-t6, with $P_{2:3}$ now also in red.

:::{#fig-t6}

``` {.tikz opt-additional-packages="\usetikzlibrary{arrows}"}
%%| filename: ../figure-tikz/fig-tikz-10
\begin{tikzpicture}[scale=1]
 \tikzstyle{quadri}=[circle, draw, text=black, thick, align=center]
 \tikzstyle{estun}=[->, >=latex, very thick]
 %
 \node[quadri] (P15) at (0, 3) {$P_{1:5}$\\$\zeta_{(1, 5)}=6$\\$\eta_{(1, 5)}^6=5$};
 \node[quadri] (P8) at (11, 3) {$P_8$\\$\zeta_{(8, 8)}=3$\\$\eta_{(8, 8)}^6=0$};
 %
 \node[quadri] (P1) at (-3, 0) {$P_1$\\$\zeta_{(1, 1)}=2$\\$\eta_{(1, 1)}^6=0$};
 \node[quadri, red] (P23) at (0, 0) {$P_{2:3}$\\$\zeta_{(2, 3)}=1$\\$\eta_{(2, 3)}^6=1$};
 \node[quadri, red] (P45) at (3, 0) {$P_{4:5}$\\$\zeta_{(4, 5)}=4$\\$\eta_{(4, 5)}^6=4$};
 \node[quadri] (P6) at (5, 3) {$P_6$\\$\zeta_{(6, 6)}=1$\\$\eta_{(6, 6)}^6=0$};
 \node[quadri, red] (P7) at (8, 3) {$P_7$\\$\zeta_{(7, 7)}=0$\\$\eta_{(7, 7)}^6=0$};
 %
 \node[quadri] (P2) at (-3, -3) {$P_2$\\$\zeta_{(2, 2)}=2$\\$\eta_{(2, 2)}^6=0$};
 \node[quadri] (P3) at (-0, -3) {$P_3$\\$\zeta_{(3, 3)}=4$\\$\eta_{(3, 3)}^6=0$};
 \node[quadri, red] (P4) at (3, -3) {$P_4$\\$\zeta_{(4, 4)}=2$\\$\eta_{(4, 4)}^6=2$};
 \node[quadri] (P5) at (6, -3) {$P_5$\\$\zeta_{(5, 5)}=3$\\$\eta_{(5, 5)}^6=1$};
 %%
 \draw[estun] (P15)--(P1);
 \draw[estun] (P15)--(P23);
 \draw[estun] (P15)--(P45);
 \draw[estun] (P23)--(P3);
 \draw[estun] (P23)--(P2);
 \draw[estun] (P45)--(P4);
 \draw[estun] (P45)--(P5);
\end{tikzpicture}
```

The regions of @exm-toy-forest at $t=6$ in @alg-formal-curve.

:::

We move on to the remaining steps. $i_7=19\in P_{4:5}$, $i_8=22\in P_{7}$ and $i_9=5\in P_{2:3}$ are all in $\bigcup_{k\in\cK^-_6}R_k$ so no $\eta_k^t$ is increased at their step (see line 9 of @alg-formal-curve), and by \eqref{eq_vstar_equal_sum_eta}, we have $\Vstar(S_7)=\Vstar(S_8)=\Vstar(S_9)=5$.

## Proof of @thm-curve-path {#sec-proof}

### Derivation of \eqref{eq_vstar_equal_sum_eta}

We first derive \eqref{eq_vstar_equal_sum_eta} from \eqref{eq_vstar_inter_Rk_equal_eta} and \eqref{eq_Pt_good_partition}. First note that for all $Q\in\mathfrak P$, 
\begin{equation}
Q=\bigcup_{k\in\cK^1}\{ k' \in Q : R_{k'}\subseteq R_k\}
\label{eq_part_K1}
\end{equation}
and the union is disjoint. From \eqref{eq_vstar_Qpartition}, let $Q^*\in\mathfrak P$ such that $\Vstar(S_t) = \sum_{k'\in Q^*} \zeta_{k'}\wedge |S_t\cap R_{k'}|$. Then by \eqref{eq_part_K1},
\begin{align}
\Vstar(S_t) &= \sum_{k'\in Q^*} \zeta_{k'}\wedge |S_t\cap R_{k'}|\notag\\
&=\sum_{k\in\cK^1}  \sum_{\substack{k'\in Q^*\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_t\cap R_{k'}|\notag \\
&=\sum_{k\in\cK^1}  \sum_{\substack{k'\in Q^*\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_t\cap (R_{k}\cap R_{k'})| \notag\\
&=\sum_{k\in\cK^1}  \sum_{k'\in Q^*} \zeta_{k'}\wedge |(S_t\cap R_{k})\cap R_{k'}| \label{eq_delicate} \\
&\geq \sum_{k\in\cK^1} \Vstar(S_t\cap R_k),\label{eq_delicate_vstar}
\end{align}
where the equality in \eqref{eq_delicate} comes from the fact that if $R_{k'}\not\subseteq R_k$, then $R_{k'}\cap R_k=\varnothing$, that is, $R_{k}\subseteq R_{k'}$ is impossible because $k\in\mathcal K^1$. Furthermore, \eqref{eq_delicate_vstar} holds again by \eqref{eq_vstar_Qpartition}. 

Because $\cK^1\subseteq\cK_t$, by \eqref{eq_Pt_good_partition}, $\Vstar(S_t\cap R_k) = \sum_{\substack{k'\in \cP^t\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge|S_t \cap R_{k'}|$ for all $k\in\cK^1$. Then,
\begin{align*}
 \sum_{k\in\cK^1} \Vstar(S_t\cap R_k)&=  \sum_{k\in\cK^1}\sum_{\substack{k'\in \cP^t\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge|S_t \cap R_{k'}|\\
 &=\sum_{k\in\cP^t} \zeta_{k}\wedge |S_t\cap R_{k}| \text{ by \eqref{eq_part_K1}}\\
 &\geq \Vstar(S_t) \text{ by \eqref{eq_vstar_Qpartition}}.\\
\end{align*}
So we proved that $\Vstar(S_t)= \sum_{k\in\cP^t} \zeta_{k}\wedge |S_t\cap R_{k}|= \sum_{k\in\cK^1} \Vstar(S_t\cap R_k)$ and finally $\Vstar(S_t)=\sum_{k\in\cK^1} \Vstar(S_t\cap R_k)= \sum_{k\in\cK^1}  \eta_k^t$ by \eqref{eq_vstar_inter_Rk_equal_eta}, again because $\cK^1\subseteq\cK_t$. Every equality in \eqref{eq_vstar_equal_sum_eta} is proven.

### Proof of \eqref{eq_vstar_inter_Rk_equal_eta} and \eqref{eq_Pt_good_partition}

We show the remainder of the statements by a strong recursion over $t$. We have $\cP^0\in\mathfrak P$ by definition, and given that $S_0=\varnothing$ and $\eta^0_k=0$ for all $k\in\cK$ (recall that $\cK_0=\cK$), everything is equal to 0 in \eqref{eq_vstar_inter_Rk_equal_eta} and \eqref{eq_Pt_good_partition}.

So we let $t\in\{ 0,\dotsc,m-1\}$, and assume that $\cP^{t'}\in\mathfrak P$ and that \eqref{eq_vstar_inter_Rk_equal_eta} and \eqref{eq_Pt_good_partition} hold for all $t'\leq t$. In all the following, $\bar k$ is the element of $\cP^t$ such that $i_{t+1}\in R_{\bar k}$. We will distinguish two cases: if $i_{t+1}\in\bigcup_{k\in\cK^-_{t}}R_k$ or not. First we show an inequality that will be used in both cases. We have, for all $k\in\cK_t$,
\begin{align}
\Vstar(S_{t+1}\cap R_k)&\leq \sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|.\label{eq_ineq_both_cases}
\end{align}
Indeed, by \eqref{eq_vstar_Qpartition}, 
\begin{align*}
\Vstar(S_{t+1}\cap R_k)&\leq  \sum_{k'\in\cP^{t}} \zeta_{k'}\wedge |S_{t+1}\cap R_k \cap R_{k'}|.
\end{align*}
For any $k'\in\cP^{t}$, we have either $R_{k'}\cap R_k=\varnothing$, in which case $|S_{t+1}\cap R_k \cap R_{k'}|=0$, either $R_{k'}\subseteq R_k$, in which case $|S_{t+1}\cap R_k \cap R_{k'}|=|S_{t+1} \cap R_{k'}|$, but $R_{k}\subsetneq R_{k'}$ is impossible. Indeed, by definition of $\cK_t$, there exists $\tilde k\in \cP^t$ such that $R_{\tilde k}\subseteq R_k$, so $R_{k}\subsetneq R_{k'}$ would entail $R_{\tilde k}\subsetneq R_{k'}$ which is impossible since $k', \tilde k\in \cP^t\in\mathfrak P$ and so $R_{\tilde k}$ and $R_{k'}$ are part of a partition of $\Nm^*$. This gives \eqref{eq_ineq_both_cases}.

#### First case: $i_{t+1}\in\bigcup_{k\in\cK^-_{t}}R_k$

In this case, $\cP^{t+1}=\cP^t\in\mathfrak P$ and $\cK_{t+1}=\cK_t$. For any $k\in\cK_{t+1}$ such that $i_{t+1}\not\in R_k$ (or, equivalently, such that $S_{t+1}\cap R_k=S_t\cap R_k$),
\begin{align*}
\sum_{\substack{k'\in\cP^{t+1} \\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|&=\sum_{\substack{k'\in\cP^{t} \\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| \\
&=V^*_{\Rfam}(S_t\cap R_k) \text{ by~\eqref{eq_Pt_good_partition}}\\
&=\eta_k^t \text{ by~\eqref{eq_vstar_inter_Rk_equal_eta}}\\
&=\eta_k^{t+1}
\end{align*}
because $\eta_k^t=\eta_k^{t+1}$ for all $k\in\cK$. Furthermore $S_{t+1}\cap R_k=S_t\cap R_k$ so $V^*_{\Rfam}(S_{t+1}\cap R_k)=V^*_{\Rfam}(S_t\cap R_k)$. So everything is proved for such a $k$.

Now we let $k\in\cK_{t+1}$ such that $i_{t+1}\in R_k$ or, equivalently, such that $R_{\bar k}\subseteq R_k$. We first need to show that $\zeta_{\bar k}\leq |S_t\cap R_{\bar k}|$, and for that we need to distinguish two subcases: if $\bar k$ has been added to $\cP^t$ during a previous step of the algorithm, of if not.

##### First subcase: $\bar k$ has never been added during the process of line 17

Then $\bar k\in\cP^0$ and $R_{\bar k}$ is an atom, so $i_{t+1}\in\bigcup_{k'\in\cK^-_{t}}R_{k'}$ implies that $R_{\bar k}\subseteq \bigcup_{k'\in\cK^-_{t}}R_{k'}$ (because of the forest structure). Let $k'_{\max}$ such that
\begin{equation*}
R_{k'_{\max}}=\max\{ R_{k'}\telque k'\in\cK^-_t, R_{\bar k}\subseteq R_{k'}  \}
\end{equation*}
(this a maximum for the inclusion relation, and it is well defined thanks to the forest structure). By reductio ad absurdum we show that $k'_{\max}=\bar k$. If that wasn't the case, by the joint construction of $\cP^t$ and $\cK^-_t$ during the algorithm we would have $k'_{\max}\in\cP^t$ and a contradiction with the fact that $\cP^t\in\mathfrak P$: we can't have both $\bar k\in\cP^t$ and $k'_{\max}\in\cP^t$ if they are distinct. So $k'_{\max}=\bar k$, so $\bar k\in  \cK^-_t$, but it cannot have been added to $\cK^-_t$ during a previous step of the algorithm, otherwise it would have been added to $\cP^t$, too. Hence $\bar k\in \cK^-_0$ which means that $\zeta_{\bar k}=0$ and $\zeta_{\bar k}=0\leq |S_t\cap R_{\bar k}|$.

##### Second subcase: $\bar k$ has been added to $\cP^t$ at a previous step

Let $t'\leq t$ be this step. This means that $\bar k = \kth{t'}{h^f_{t'}}$ and that at that step $\eta^{t'}_{\bar k}=\zeta_{\bar k}$. Indeed, the if condition in line 13 failed so $\eta^{t'}_{\bar k}\geq\zeta_{\bar k}$, but for all $t''<t'$ we had $\eta^{t''}_{\bar k}\leq\zeta_{\bar k}$ which implies equality. Also $\bar k\in \cP^{t'}$ so $\bar k\in \cK_{t'}$ so we can write 
\begin{align*}
\zeta_{\bar k}&=\eta^{t'}_{\bar k}\\
&=\Vstar(S_{t'}\cap R_{\bar k})  \text{ by~\eqref{eq_vstar_inter_Rk_equal_eta}} \\
&\leq | S_{t'}\cap R_{\bar k} |\\
&\leq  | S_{t}\cap R_{\bar k} |.\\
\end{align*}

This concludes the two subcases dichotomy: $\zeta_{\bar k}\leq |S_t\cap R_{\bar k}|$ and we can go back to our $k\in\cK_{t+1}$ such that $i_{t+1}\in R_k$ and $R_{\bar k}\subseteq R_k$.

We write the following chain:
\begin{align*}
\Vstar(S_{t+1}\cap R_k)&\leq \sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|\text{ by~\eqref{eq_ineq_both_cases} and }\cK_{t+1}\subseteq\cK_t\\
&=\sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| + \zeta_{\bar k}\wedge |S_{t+1}\cap R_{\bar k}| \\
&=\sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge( |S_{t}\cap R_{\bar k}| +1)\\
&=\sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge|S_{t}\cap R_{\bar k}|\text{ because $\zeta_{\bar k}\leq |S_t\cap R_{\bar k}|$}\\
&=\sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| \\
&=\Vstar(S_t\cap R_k)  \text{ by~\eqref{eq_Pt_good_partition}} \\
&= \eta_k^t  \text{ by~\eqref{eq_vstar_inter_Rk_equal_eta}} \\
&= \eta_k^{t+1}.\\
\end{align*}
But on the other hand, $S_t\subseteq S_{t+1}$ and so \eqref{eq_vstar_Qpartition} also gives $\Vstar(S_t\cap R_k) \leq \Vstar(S_{t+1}\cap R_k)$ and so in the end we have the desired outcome:
\begin{equation*}
\Vstar(S_{t+1}\cap R_k) =  \eta_k^{t+1} =  \sum_{\substack{k'\in\cP^{t+1}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| ,
\end{equation*}
which concludes this first case.

#### Second case: $i_{t+1}\not\in\bigcup_{k\in\cK^-_{t}}R_k$

We first prove that $\cP^{t+1}\in\mathfrak P$ whether it came form the adjustment in line 17 or not. If it didn't, it stayed equal to $\cP^t\in\mathfrak P$. If it did, we have
\begin{equation}\label{eq_rel_rec_p}
\cP^{t+1}=\left(\cP^t \setminus\{k\in\cP^t, R_k\subseteq R_{  \kth {t+1}{h^f_{t+1}}   }   \}  \right)\cup \{ \kth {t+1}{h^f_{t+1}} \}.
\end{equation}
To prove that $\cP^{t+1}\in\mathfrak P$ in that case, it suffices to prove there are no $k'\in\cP^t$ such that $R_{  \kth {t+1}{h^f_{t+1}}} \subsetneq  R_{k'}$. If it was the case, because of the strict inclusion, we would have $k'\not\in\cP^0$, so $k'$ would have been added to $\cP^{t'}$ at a previous step $t'\leq t$ of the algorithm, but in that case it would also have been added to $\cK_{t'}^-\subseteq \cK_{t}^-$. So in the end we would have
\begin{equation*}
i_{t+1}\in R_{  \kth {t+1}{h^f_{t+1}}} \subsetneq R_{k'} \subseteq \bigcup_{k\in\cK^-_{t}}R_k
\end{equation*}
which is a contradiction and so $\cP^{t+1}\in\mathfrak P$.

Like in the first case, considering a $k\in\cK_{t+1}\subseteq \cK_t$ such that $i_{t+1}\not\in R_k$ is not problematic, because in that case $k$ is not visited at all by the algorithm at step $t+1$ : $\eta^{t+1}_k=\eta^{t}_k$, $\{k'\in\cP^{t+1}\telque R_{k'}\subseteq R_k\}=\{k'\in\cP^{t}\telque R_{k'}\subseteq R_k\}$, and for all $k'\in \cK$ such that $R_{k'}\subseteq R_k$, $S_{t+1}\cap R_{k'}=S_{t}\cap R_{k'}$. Hence, from 
\begin{equation*}
\Vstar(S_{t}\cap R_k) =  \eta_k^{t} =  \sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| ,
\end{equation*}
we directly have
\begin{equation*}
\Vstar(S_{t+1}\cap R_k) =  \eta_k^{t+1} =  \sum_{\substack{k'\in\cP^{t+1}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| .
\end{equation*}

So we now focus on the $k\in\cK_{t+1}$ such that $i_{t+1}\in R_k$. Note that for such $k$, 
\begin{equation*}
\eta^{t+1}_k=\eta^t_k+1=\Vstar(S_t\cap R_k)+1=\sum_{\substack{k'\in \cP^t\\ R_{k'}\subseteq R_k}}\zeta_{k'}\wedge|S_t\cap R_{k'}|+1
\end{equation*}
by construction, by \eqref{eq_vstar_inter_Rk_equal_eta} and by \eqref{eq_Pt_good_partition}. Indeed, such a $k$ is equal to a $\kth{t+1}h$ with $h\leq h_{max}(t+1)$, and even $h\leq h^f_{t+1}$ if the latter exists.

Also, similarly to the first case, for all $k\in\cK_{t+1}$ such that $i_{t+1}\in R_k$ (recall that this is equivalent to $R_{\bar k}\subseteq R_k$), we can write:
\begin{align}
\Vstar(S_{t+1}\cap R_k)&\leq \sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| \text{ by \eqref{eq_ineq_both_cases} and }\cK_{t+1}\subseteq\cK_t\notag\\
&=\sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| + \zeta_{\bar k}\wedge |S_{t+1}\cap R_{\bar k}| \notag\\
&=\sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge( |S_{t}\cap R_{\bar k}| +1)\notag\\
&\leq \sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge|S_{t}\cap R_{\bar k}| +1\notag\\
&=\sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}|  + 1\notag\\
&=\Vstar(S_t\cap R_k) +1  \text{ by \eqref{eq_Pt_good_partition}}.\label{eq_ineq_}
\end{align}

Note that by the joint construction of $\cK^-_t$ and $\cP^t$ on lines 17 and 18, the fact that $i_{t+1}\not\in\bigcup_{k\in\cK^-_{t}}R_k$ implies that $\bar k$ is the index of an atom, so actually $h_{\max}(t+1)=\phi(\bar k)$, $\bar k = \kth{t+1}{\phi(\bar k)}$ and the $R_k$, $k\in\cK_{t}$, such that $R_{\bar k}\subseteq R_k$ are nested and are exactly indexed by the $\kth{t+1}{h}$, $1\leq h\leq \phi(\bar k)$. We now prove that for all of them, $\Vstar(S_{t+1}\cap R_k)\geq \Vstar(S_{t}\cap R_k)+1$, which will be true in particular for the ones that are in $\cK_{t+1}$, given that $\cK_{t+1}\subseteq \cK_t$. We do that by constructing some sets $A_h$ with good properties with a descending recursion on $h$, starting from $\phi(\bar k)$. We only give the first two steps of the construction, because every other step is exactly the same as the second one, which contains the recursive arguments. We go back to the real definition of $\Vstar$ to do so, for any $S\subseteq \Nm$:
\begin{equation}
\label{eq_Vstar_au_max} \Vstar(S)=\max_{\substack{A\subseteq \Nm\\\forall k'\in\cK, |A\cap R_{k'}|\leq \zeta_{k'}}} |A\cap S| =\max_{\substack{A\subseteq S\\\forall k'\in\cK, |A\cap R_{k'}|\leq \zeta_{k'}}} |A|  . 
\end{equation}

By \eqref{eq_Vstar_au_max}, we have that $\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)}})=|A_{\phi(\bar k)}|$ for a given $A_{\phi(\bar k)}\subseteq S_t \cap R_{\kth{t+1}{\phi(\bar k)}}$ and such that $|A_{\phi(\bar k)}\cap R_{k'}|\leq \zeta_{k'}$ for all $k'\in\cK$. Now for the second set, we construct $A_{\phi(\bar k)-1}$. Note that $\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}})=|B|$ for some $B\subseteq S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}$ and such that $|B\cap R_{k'}|\leq \zeta_{k'}$ for all $k'\in\cK$. By reductio ad absurdum, if there are strictly less than $\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}) - \Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)}})=|B|-|A_{\phi(\bar k)}|$ elements in $S_t\cap R_{\kth{t+1}{\phi(\bar k)-1}} \setminus S_t\cap R_{\kth{t+1}{\phi(\bar k)}}$, then $|B|+|S_t \cap R_{\kth{t+1}{\phi(\bar k)}}|-|S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}|>|A_{\phi(\bar k)}|=\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)}})$. Given that $B\cup (S_t\cap R_{\kth{t+1}{\phi(\bar k)}})\subseteq S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}$, this entails $|B\cap S_t\cap R_{\kth{t+1}{\phi(\bar k)}}| =|B|+|S_t \cap R_{\kth{t+1}{\phi(\bar k)}}| -| B\cup (S_t\cap R_{\kth{t+1}{\phi(\bar k)}})| > \Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)}})$ which contradicts the maximality of $A_{\phi(\bar k)}$ in \eqref{eq_Vstar_au_max}. 

So we construct $A_{\phi(\bar k)-1}$ by taking the disjoint union of $A_{\phi(\bar k)}$ and $\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}) - \Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)}})$ elements of $S_t\cap R_{\kth{t+1}{\phi(\bar k)-1}} \setminus S_t\cap R_{\kth{t+1}{\phi(\bar k)}}$. We now establish the properties of $A_{\phi(\bar k)-1}$. First, $A_{\phi(\bar k)-1}\subseteq S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}$, and $|A_{\phi(\bar k)-1}|=\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}})$. For all $k'\in\cK$ such that $R_{\kth{t+1}{\phi(\bar k)-1}} \cap R_{k'}=\varnothing$, we have $|A_{\phi(\bar k)-1}\cap R_{k'}|=0\leq \zeta_k'$. Furthermore,
\begin{align*}
|A_{\phi(\bar k)-1}\cap R_{   \kth{t+1}{\phi(\bar k)}   }|&=|A_{\phi(\bar k)}\cap R_{   \kth{t+1}{\phi(\bar k)}   }|\\
&\leq \zeta_{ \kth{t+1}{\phi(\bar k)} }
\end{align*}
by construction of $A_{\phi(\bar k)}$. Finally, for all $k'$ such that $R_{\kth{t+1}{\phi(\bar k)-1}}\subseteq R_{k'}$, $|A_{\phi(\bar k)-1}\cap R_{k'}|=|A_{\phi(\bar k)-1}|=\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}})=|B|$ with the previously defined $B$, in particular $|B\cap R_{k'}|\leq \zeta_{k'}$, but given that $B\subseteq S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}$, $|B\cap R_{k'}|=|B|$. Wrapping all those equalities, it comes that $|A_{\phi(\bar k)-1}\cap R_{k'}|\leq \zeta_{k'}$. In the end, $|A_{\phi(\bar k)-1}\cap R_{k'}|\leq \zeta_{k'}$ for all $k'\in\cK$, so $A_{\phi(\bar k)-1}$ realizes the maximum in \eqref{eq_Vstar_au_max} for $S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}$.

By applying exactly the same method, we recursively construct a non-increasing sequence $A_{\phi(\bar k)}\subseteq\dotsb\subseteq A_1$ such that for all $\ell\in\{1,\dotsc, \phi(\bar k)\}$ and $k'\in\cK$, $A_\ell\subseteq S_t\cap R_{\kth{t+1}{\ell}}$, $\Vstar(S_t\cap R_{\kth{t+1}{\ell}})=|A_\ell|$, and $|A_\ell\cap R_{k'}|\leq \zeta_{k'}$. Furthermore for $\ell'>\ell$, $A_{\ell}\setminus A_{\ell'}\subseteq S_t\cap R_{\kth{t+1}{\ell}}\setminus S_t\cap R_{\kth{t+1}{\ell'}}$. Also note that the fact that $i_{t+1}\not\in\bigcup_{k\in\cK^-_{t}}R_k$ implies that $\eta^t_{\kth{t+1}{\ell}}<\zeta_{\kth{t+1}{\ell}}$ for all $\ell\in\{1,\dotsc, \phi(\bar k)\}$. So by \eqref{eq_vstar_inter_Rk_equal_eta}, $|A_\ell|<\zeta_{\kth{t+1}{\ell}}$.

Let, for any $\ell\in\{1,\dotsc, \phi(\bar k)\}$, $\widetilde A_\ell=A_\ell \cup \{ i_{t+1}\}$. Given that $A_\ell\subseteq S_t\cap R_{\kth{t+1}{\ell}}$ and that $i_{t+1}\in S_{t+1}\setminus S_t$, $\widetilde A_\ell\subseteq S_{t+1}\cap R_{\kth{t+1}{\ell}}$, $|\widetilde A_\ell|=| A_\ell|+1$, and for all $\ell'\in\{1,\dotsc, \phi(\bar k)\}$, $|\widetilde A_\ell \cap R_{\kth{t+1}{\ell'}} |=| A_\ell\cap R_{\kth{t+1}{\ell'}}|+1$. Note that if, furthermore, $\ell\geq \ell'$, then $A_\ell\subseteq A_{\ell'}$, so
\begin{align*}
|\widetilde A_\ell \cap R_{\kth{t+1}{\ell'}} |&=| A_\ell\cap R_{\kth{t+1}{\ell'}}|+1\\
&\leq | A_{\ell'}\cap R_{\kth{t+1}{\ell'}}|+1\\
&= | A_{\ell'}|+1\\
&<\zeta_{\kth{t+1}{\ell'}}+1.\\
\end{align*}
On the contrary, if $\ell< \ell'$, we write that
\begin{align*}
|\widetilde A_\ell \cap R_{\kth{t+1}{\ell'}} |&=| A_\ell\cap R_{\kth{t+1}{\ell'}}|+1\\
&= | (A_{\ell}\setminus A_{\ell'}) \cap R_{\kth{t+1}{\ell'}}   | + | A_{\ell'}\cap R_{\kth{t+1}{\ell'}}|+1\\
&<  0 +  \zeta_{\kth{t+1}{\ell'}} +1,
\end{align*}
because $A_{\ell}\setminus A_{\ell'} \subseteq   R_{\kth{t+1}{\ell}}\setminus  R_{\kth{t+1}{\ell'}}$ hence $(A_{\ell}\setminus A_{\ell'}) \cap R_{\kth{t+1}{\ell'}}  =\varnothing$. In both cases, $|\widetilde A_\ell \cap R_{\kth{t+1}{\ell'}} |< \zeta_{\kth{t+1}{\ell'}} +1$ so $|\widetilde A_\ell \cap R_{\kth{t+1}{\ell'}} |\leq \zeta_{\kth{t+1}{\ell'}}$. Additionally, for all $k'\in\cK$ such that $i_{t+1}\not\in R_{k'}$,  $|\widetilde A_\ell \cap R_{k'} |=| A_\ell \cap R_{k'} |\leq \zeta_{k'}$. 

In the end, $|\widetilde A_\ell \cap R_{k'} |\leq \zeta_{k'}$ for all $k'\in\cK$, so
\begin{align*}
\Vstar( S_{t+1}\cap R_{\kth{t+1}{\ell}})&\geq | \widetilde A_\ell | \text{ by \eqref{eq_Vstar_au_max}}\\
&=  |  A_\ell | +1\\
&= \Vstar( S_{t}\cap R_{\kth{t+1}{\ell}}) +1.
\end{align*}
So, as we wanted, $\Vstar(S_{t+1}\cap R_k)\geq \Vstar(S_{t}\cap R_k)+1$ for all $k\in\cK_{t}$ such that $i_{t+1}\in R_k$ and so for all such $k$ that are in $\cK_{t+1}$. So every inequality in \eqref{eq_ineq_} becomes an equality and we have proven that 
\begin{equation*}
\Vstar(S_{t+1}\cap R_k) = \Vstar(S_{t}\cap R_k)+1 =\eta^t_k+1= \eta^{t+1}_k,
\end{equation*}
that is, \eqref{eq_vstar_inter_Rk_equal_eta} is true at $t+1$.
Looking at the first line of \eqref{eq_ineq_} , we also proved that
\begin{equation}
\Vstar(S_{t+1}\cap R_k) =  \sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| . \label{eq_Pt_instead}
\end{equation}
The only thing left to prove is that \eqref{eq_Pt_instead} is also true with $\cP^{t+1}$ instead of $\cP^{t}$, that is that \eqref{eq_Pt_good_partition} also holds at $t+1$, or, put differently, that
\begin{equation}\label{eq_last_goal}
\sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|=\sum_{\substack{k'\in\cP^{t+1}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|.
\end{equation}
If $h^f_{t+1}$ does not exist, meaning that we didn't break the loop, $\cP^{t+1}=\cP^t$ so there is nothing to prove.

Now assume that $h^f_{t+1}$ exists. So \eqref{eq_rel_rec_p} holds. We will split each term in \eqref{eq_last_goal} in a sum of two terms. First, note that by \eqref{eq_rel_rec_p}, for any $k'\in\cK$ such that $R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing$, we have that $k'\in\cP^{t+1}$ if and only if $k'\in \cP^{t}$. And so,
\begin{align*}
 \sum_{\substack{k'\in\cP^{t+1}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| &=  \sum_{\substack{k'\in\cP^{t+1}\\R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing \\R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| +  \zeta_{ \kth {t+1}{h^f_{t+1}}}\wedge |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|\\ 
 &=  \sum_{\substack{k'\in\cP^{t}\\R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing \\R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| +  \zeta_{ \kth {t+1}{h^f_{t+1}}}\wedge |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|.
\end{align*}

Recall that we already proved that there is no $k'\in \cP^t$ such that $R_{  \kth {t+1}{h^f_{t+1}} }\subsetneq R_{k'}$, so for any $k'\in \cP^t$, either $R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing$ or $R_{k'}\subseteq  R_{  \kth {t+1}{h^f_{t+1}}}$. Hence the split
\begin{align*}
 \sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| &=  \sum_{\substack{k'\in\cP^{t}\\R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing \\R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|  \;   + \sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq  R_{  \kth {t+1}{h^f_{t+1}}}\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|\\
 &=\sum_{\substack{k'\in\cP^{t}\\R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing \\R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|  \;   + \sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq  R_{  \kth {t+1}{h^f_{t+1}}}}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|,
\end{align*}
where the last equality comes from the fact that $R_{  \kth {t+1}{h^f_{t+1}} }\subseteq R_k$, because $k\in\cK_{t+1}$, $i_{t+1}\in R_k$, and $\kth {t+1}{h^f_{t+1}}\in \cP^{t+1}$.

Given the two previously made splits, it remains to prove that 
\begin{equation*}
\sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq  R_{  \kth {t+1}{h^f_{t+1}}} }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| =  \zeta_{ \kth {t+1}{h^f_{t+1}}}\wedge |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|.
\end{equation*}
Interestingly, this does not depend  on $k$ anymore. By \eqref{eq_Pt_instead}, the left-hand side  is equal to $\Vstar( S_{t+1}\cap  R_{  \kth {t+1}{h^f_{t+1}}  } )$. Because we are breaking the loop at step  $h^f_{t+1}$, $\eta^{t+1}_{\kth {t+1}{h^f_{t+1}} }= \zeta_{ \kth {t+1}{h^f_{t+1}}}$. Finally, because \eqref{eq_vstar_inter_Rk_equal_eta} holds at $t+1$, $\eta^{t+1}_{\kth {t+1}{h^f_{t+1}} }=\Vstar( S_{t+1}\cap  R_{  \kth {t+1}{h^f_{t+1}}  } )$. Wrapping all these assertions:
\begin{align*}
\sum_{\substack{k'\in\cP^{t}\\R_{k'}\subseteq  R_{  \kth {t+1}{h^f_{t+1}}} }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| &= \Vstar( S_{t+1}\cap  R_{  \kth {t+1}{h^f_{t+1}}  } )\\
&=\Vstar( S_{t+1}\cap  R_{  \kth {t+1}{h^f_{t+1}}  } )\wedge  |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|\\
&=\eta^{t+1}_{\kth {t+1}{h^f_{t+1}} }\wedge  |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|\\
&=  \zeta_{ \kth {t+1}{h^f_{t+1}}}\wedge |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|,
\end{align*}
which achieves the second case and so the proof. $\square$

# Implementation {#sec-implementation}

All algorithms discussed in this manuscript are already implemented in the `R` [@R-base] package `sanssouci` [@sanssouci] which is available on GitHub (see the References for the link) and is dedicated to the computation of confidence bounds for the number of false positives. It also hosts the implementation of the methods described in @MR4124323 and @10.1093/bioinformatics/btac693. @alg-vstar is implemented as the `V.star` function, @alg-pruning is implemented as the `pruning` function, and @alg-curve is implemented as the `curve.V.star.forest.fast` function (whereas the `curve.V.star.forest.naive` function just repeatedly calls `V.star`). Note that the `pruning` function has a `delete.gaps` option that speeds up the computation even more by removing unnecessary gaps introduced in the data structure by the pruning operation, those gaps being due to the specific structure that is used to store the information of $\cK$. 

Speaking of the data structure, we briefly describe it, with an example. We represent $(R_k)_{k\in\cK}$ by two lists, `C` and `leaf_list`. `leaf_list` is a list of vectors, where `leaf_list[[i]]` is the vector listing the hypotheses in the atom $P_i$. `C` is a list of lists. For $1\leq h\leq H$, `C[[h]]` lists the regions at depth $h$, using the index bounds of the atoms they are composed of. That is, the elements of the list `C[[h]]` are vectors of size two, and if there is `k`, `i`  and `j` such that `C[[h]][[k]] = c(i, j)`, it means that $(i, j)\in\cK$, or in other words that $P_{i:j}$ is one of the regions, and that $\phi((i, j))=h$. We emphasize that the 1D structure of the hypotheses has to be respected by the user as the current implementation implicitly uses it: that is, $P_1$ has to contain the hypotheses labeled $1, 2, \dotsc, p$, $P_2$ has to contain the hypotheses labeled $p+1, \dotsc$, and so on. Also, the hypotheses have to be in non-decreasing order: `leaf_list[[1]]` has to be equal to `c(1, 2, 3, ..., p)` and not, say, `c(2, 1, 3, ..., p)`.

::: {#exm-implementation}

## Implementation of @exm-toy-leaves

For the reference family given in @exm-toy-forest and completed in @exm-toy-leaves, $H=3$. For $h=1$, we have `C[[1]][[1]] = c(1, 5)`, `C[[1]][[2]] = c(6, 7)`, `C[[1]][[3]] = c(8, 8)`. For $h=2$, we have `C[[2]][[1]] = c(1, 1)`, `C[[2]][[2]] = c(2, 3)`, `C[[2]][[3]] = c(4, 5)`, `C[[2]][[4]] = c(6, 6)`, `C[[2]][[5]] = c(7, 7)`. For $h=3$, we have `C[[3]][[1]] = c(2, 2)`, `C[[3]][[2]] = c(3, 3)`, `C[[3]][[3]] = c(4, 4)`, `C[[3]][[4]] = c(5, 5)`. 

And then for the atoms, we have `leaf_list[[1]] = c(1, 2)`, `leaf_list[[2]] = c(3, 4)`, `leaf_list[[3]] = c(5, 6, 7, 8, 9, 10)`, `leaf_list[[4]] = c(11, 12, 13, 14, 15, 16)`, `leaf_list[[5]] = c(17, 18, 19, 20)`, `leaf_list[[6]] = 21`, `leaf_list[[7]] = 22` and finally `leaf_list[[8]] = c(23, 24, 25)`.
:::

The functions `dyadic.from.leaf_list`, `dyadic.from.window.size`, and `dyadic.from.height` return the appropriate data structure to represent a $\cK$ that can be described as a dyadic tree, based on some entry parameters that can be inferred from the names of the functions. The completion of a forest structure, mentioned in @sec-forest-structure, is done by the `forest.completion` function. Finally, the $\zeta_k$'s are computed as in @MR4178188 by the `zetas.tree` function with `method=zeta.DKWM`.

# Numerical experiments {#sec-numeric}

In this Section, we present some numerical experiments aiming to demonstrate the impact of the pruning of @alg-pruning (using the `delete.gaps` option mentioned in @sec-implementation) and of the fast @alg-curve, in terms of computation time, compared to the only previously available method to compute a curve of confidence bounds. As mentioned in @sec-forest-structure and @sec-implementation, this naive method simply consisted in a `for` loop repeatedly applying @alg-vstar.

To compare the computation time, we use the `R` package `microbenchmark` version 1.5.0 [@microbenchmark] with `R` version 4.4.0 (2024-04-24) and `sanssouci` version 0.13.0, on a MacBook Air M1 (2020) running macOS 15.1.1. The package `microbenchmark` allows to run code snippets a given number `n_repl` of times, and to compute summary statistics on the computation time. The script executing the computation can be found in the same repository as this manuscript.

Four scenarios are studied, all based on a common setting which we first describe. A number $m$ of hypotheses is tested. We use a reference family $(R_k,\zeta_k)$ such that the $R_k$'s have a forest structure of maximal depth $H=10$. The graph of the inclusion relations between the $R_k$'s is a binary tree, hence there are $2^H-1=1023$ $R_k$'s and in particular $2^{H-1}=512$ atoms. $P$-values are generated in a gaussian one-sided fashion where $\Hoi= \{ \mathcal N(\boldsymbol{\mu}, \mathrm{Id})  :\mu_i=0 \}$, $H_{1,i}=\{ \mathcal N(\boldsymbol{\mu}, \mathrm{Id}) :\mu_i=4 \}$, and $p_i(X)=1-\Phi(X_i)$. $\cH_1$ is comprised of the leafs 1, 5, 9 and 10, that is $\cH_1=P_1\cup P_5\cup P_9\cup P_{10}$. For each scenario, the curve $\left(\Vstar(\{1,\dotsc,t \})\right)_{t\in\Nm^*}$ is computed. For the experiments including pruning, the pruning is done once before the `n_repl` replications, to mimick the practice where pruning only needs to be done once and for all, while the user may be interested in computing multiple bounds and curves after that.

In scenarios 1 and 2, $m=1024$ (so the atoms are of size 2), in scenarios 3 and 4, $m=10240$ (so the atoms are of size 10). In scenarios 1 and 3, the $\zeta_k$'s are estimated trivially by $\zeta_k=|R_k|$, and in scenarios 2 and 4, they are computed as in @MR4178188 with the DKWM inequality [@MR0083864 ; @MR1062069]. Because of the size of $m$ and the poor performances of the naive approach, we set `n_repl=100` in scenarios 1 and 2 and `n_repl=10` only in scenario s 3 and 4. The differences between the scenarios are summarized in @tbl-scenarios.

::: {#tbl-scenarios}

|parameter| Scenario 1 | Scenario 2 | Scenario 3 | Scenario 4 |
|--|------|------|------|--|
|$m$| 1024    | 1024    | 10240    |10240 |
|zeta computation| trivial    | DKWM   | trivial    |DKWM |
|`n_repl`| 100    | 100    | 10    | 10|

Differences between the scenarios

::: 

For the trivial $\zeta_k$ computation of scenarios 1 and 3, the pruning obviously deletes all non-atom regions so $|\cK^{\pr}|=512$. Whereas, for the particular instance $\omega\in\Omega$ in the experiments, $|\cK^{\pr}|=541$ for scenario 2, and $|\cK^{\pr}|=573$ for scenario 4. Those results alone illustrate the benefits of pruning with respect to the reduction of the cardinality of the reference family: the regions above atoms with no signal (or no detectable signal in the trivial scenarios) are pruned. The fact that the regions above atoms with detectable signal are not pruned means that they are relevant for the confidences bounds (which had already been demonstrated in the simulation study of @MR4178188).

The summary statistics of the computation time in each scenario are presented in @tbl-benchmark01, @tbl-benchmark02, @tbl-benchmark03, and @tbl-benchmark04, and they are also presented as boxplots in @fig-benchmark01. The time unit is the second (in logarithmic scale in the boxplots).

```{r loading, echo=FALSE}
library(microbenchmark)

unit <- "s"
loaded_list <- list()
summary_list <- list()

for (i in 1:4){
  loaded <- read.csv(paste0("benchmark_0", i, ".csv"))
  class(loaded) <- c("microbenchmark", class(loaded))
  loaded$expr <- factor(loaded$expr, levels = c("naive.not.pruned", 
                                                "naive.pruned", 
                                                # "naive.pruned.no.gaps",
                                                "fast.not.pruned",
                                                "fast.pruned"
                                                # "fast.pruned.no.gaps"
  )
  )
  loaded$time <- microbenchmark:::convert_to_unit(loaded, unit)
  loaded_list[[i]] <- loaded
  summary_list[[i]] <- summary(loaded)
}
```

```{r echo=FALSE}
#| label: tbl-benchmark01
i <- 1
knitr::kable(summary_list[[i]], caption = paste0("Scenario ", i))
```
```{r echo=FALSE}
#| label: tbl-benchmark02
i <- 2
knitr::kable(summary_list[[i]], caption = paste0("Scenario ", i))
```
```{r echo=FALSE}
#| label: tbl-benchmark03
i <- 3
knitr::kable(summary_list[[i]], caption = paste0("Scenario ", i))
```
```{r echo=FALSE}
#| label: tbl-benchmark04
i <- 4
knitr::kable(summary_list[[i]], caption = paste0("Scenario ", i))
```


```{r fig.height=10, fig.width=10, echo=FALSE}
#| label: fig-benchmark01
#| message: false
#| warning: false
#| fig-cap: "Computation times in scenario, in log seconds"

def_mar <- c(5, 4, 4, 2) + 0.1

shift_fig <- c(0.307, 0.310, 0.13, 0.145)

par(mfrow = c(2, 2))

for (i in 1:4) {
  par(mar = def_mar + c(3.8, 0, 0, 0))
  
  bp <- boxplot(
    time ~ expr,
    data = loaded_list[[i]],
    ylab = "log seconds",
    xlab = "",
    ylim = NULL,
    horizontal = F,
    main = paste0("Comp. time, scenario ", i),
    xaxt = "n",
    log = "y"
  )
  tick <- seq_along(bp$names)
  axis(1, at = tick, labels = FALSE)
  text(tick,
       par("usr")[1] - shift_fig[i],
       bp$names,
       srt = 60,
       xpd = TRUE)
}
```

On each scenario, using the fast algorithm is much faster than the naive approach, while pruning always gives a slight improvement over not pruning. 

Comparing scenarios 1 and 2 first, we see that, as expected, there is no significant change in computation time for `naive.not.pruned`, while `naive.pruned` is faster in scenario 1, given that we prune more. But, on the other hand, `fast.not.pruned` and `fast.pruned` are both faster in scenario 2, even if we prune less. This is because, for the regions with signal, said signal is detected and so those regions are quickly saturated, in the sense that we quickly have $\eta_k^t=\zeta_k$ and $k$ added to $\cK^-_k$, which saves a lot of time. 

The comparison between scenarios 3 and 4 is similar, except that this time we prune even less in scenario 4 and so the effect of the saturation is not enough to compensate. Although, with only `n_repl=10`, the statistics seem less accurate, this can be confirmed with additional experiments (`n_repl` can also be set to 100 without problem is we don't include `naive` methods).

Finally, comparing scenarios 3 & 4 with scenarios 1 & 2, we see that multiplying the number of hypotheses by 10 effectively multiplies the computation time by $\sim10$ when using @alg-curve and by $\sim100$ when using @alg-vstar naively, which illustrates the stated complexities of $O(m|\cK|)$ and $O(m^2|\cK|)$, respectively.

# Conclusion

In conclusion, we effectively introduced a new algorithm to compute a curve of confidence upper bounds, much faster the previous alternative, with one power of $m$ less in the complexity.

To develop new confidence upper bounds methodology and test them on simulations, it was previously not conceivable to replicate experiments a sufficient number of times while computing whole curves. For instance, in the simulation study of @MR4178188, the number of replications chosen was 10 and the whole curve was not computed, only ten values along the curve were computed, for an `m` set to 12800, that is 0.078% of the curve had been computed. Now, simulation studies with an adequate number of replications and 100% of the curve become feasible.

A lot of work remains to be done on the `sanssouci` package. For example, to make the data format of a forest structure $(R_k)_{k\in\cK}$ less convoluted and more user-friendly is an interesting project. Another one would be to implement inside the package the methods of the paper @blain22notip, which are currently only available in the Python language [@10.5555/1593511], and the methods of the paper @JMLR:v25:23-1025.

Other current works include the development of new reference families with theoretical JER control that could better account for realistic models, such as models with dependence between the $p$-values, see for example @perrot2023selective, or models with discreteness.

# Acknowledgements

This work has been supported by ANR-20-IDEES-0002 (PIA), ANR-19-CHIA-0021 (BISCOTTE), ANR-23-CE40-0018 (BACKUP) and ANR-21-CE23-0035 (ASCAI). Thanks to Romain Périer for being the first to extensively use the new implemented algorithms. Thanks to Pierre Neuvial for his valuable feedback.

# References {.unnumbered}

::: {#refs}
:::

# Session information {.appendix .unnumbered}

```{r session-info}
sessionInfo()
```

