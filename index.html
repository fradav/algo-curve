<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Guillermo Durand">
<meta name="dcterms.date" content="2024-12-26">
<meta name="keywords" content="multiple testing, algorithmic, post hoc inference, false discovery proportion, confidence bound">

<title>A fast algorithm to compute a curve of confidence upper bounds for the False Discovery Proportion using a reference family with a forest structure</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="algo-curve_files/libs/clipboard/clipboard.min.js"></script>
<script src="algo-curve_files/libs/quarto-html/quarto.js"></script>
<script src="algo-curve_files/libs/quarto-html/popper.min.js"></script>
<script src="algo-curve_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="algo-curve_files/libs/quarto-html/anchor.min.js"></script>
<link href="algo-curve_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="algo-curve_files/libs/quarto-html/quarto-syntax-highlighting-0626ff4d7a71b55c8707dcae1d04a9b6.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="algo-curve_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="algo-curve_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="algo-curve_files/libs/bootstrap/bootstrap-cde7780d289188dc44a061be387cb41e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="algo-curve_files/libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.js"></script>
<link href="algo-curve_files/libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.css" rel="stylesheet">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>
<script>
window.MathJax = {
  tex: {
    tags: 'ams'
  }
};
</script>
<meta name="quarto:status" content="draft">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body><div id="quarto-draft-alert" class="alert alert-warning"><i class="bi bi-pencil-square"></i>Draft</div>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; A fast algorithm to compute a curve of confidence upper bounds for the False Discovery Proportion using a reference family with a forest structure</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-heading">Affiliation</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://durandg12.github.io/">Guillermo Durand</a> <a href="https://orcid.org/0000-0003-4056-5631" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.imo.universite-paris-saclay.fr/fr/">
                  Université Paris-Saclay
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 26, 2024</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">December 26, 2024</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">multiple testing, algorithmic, post hoc inference, false discovery proportion, confidence bound</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>This paper presents a new algorithm (and an additional trick) that allows to compute fastly an entire curve of post hoc bounds for the False Discovery Proportion when the underlying bound <span class="math inline">\(V^*_{\mathfrak{R}}\)</span> construction is based on a reference family <span class="math inline">\(\mathfrak{R}\)</span> with a forest structure à la <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span>. By an entire curve, we mean the values <span class="math inline">\(V^*_{\mathfrak{R}}(S_1),\dotsc,V^*_{\mathfrak{R}}(S_m)\)</span> computed on a path of increasing selection sets <span class="math inline">\(S_1\subsetneq\dotsb\subsetneq S_m\)</span>, <span class="math inline">\(|S_t|=t\)</span>. The new algorithm leverages the fact that going from <span class="math inline">\(S_t\)</span> to <span class="math inline">\(S_{t+1}\)</span> is done by adding only one hypothesis.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#notation-and-reference-family-methodology" id="toc-notation-and-reference-family-methodology" class="nav-link" data-scroll-target="#notation-and-reference-family-methodology"><span class="header-section-number">2</span> Notation and reference family methodology</a>
  <ul class="collapse">
  <li><a href="#sec-notation" id="toc-sec-notation" class="nav-link" data-scroll-target="#sec-notation"><span class="header-section-number">2.1</span> Multiple testing notation</a></li>
  <li><a href="#sec-reference-fam" id="toc-sec-reference-fam" class="nav-link" data-scroll-target="#sec-reference-fam"><span class="header-section-number">2.2</span> Post hoc bounds with reference families</a></li>
  <li><a href="#sec-forest-structure" id="toc-sec-forest-structure" class="nav-link" data-scroll-target="#sec-forest-structure"><span class="header-section-number">2.3</span> Regions with a forest structure</a></li>
  </ul></li>
  <li><a href="#new-algorithms" id="toc-new-algorithms" class="nav-link" data-scroll-target="#new-algorithms"><span class="header-section-number">3</span> New algorithms</a>
  <ul class="collapse">
  <li><a href="#sec-pruning" id="toc-sec-pruning" class="nav-link" data-scroll-target="#sec-pruning"><span class="header-section-number">3.1</span> Pruning the forest</a></li>
  <li><a href="#sec-fast-curve" id="toc-sec-fast-curve" class="nav-link" data-scroll-target="#sec-fast-curve"><span class="header-section-number">3.2</span> Fast algorithm to compute a curve of confidence bounds on a path of selection sets</a></li>
  </ul></li>
  <li><a href="#sec-implementation" id="toc-sec-implementation" class="nav-link" data-scroll-target="#sec-implementation"><span class="header-section-number">4</span> Implementation</a></li>
  <li><a href="#sec-numeric" id="toc-sec-numeric" class="nav-link" data-scroll-target="#sec-numeric"><span class="header-section-number">5</span> Numerical experiments</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">6</span> Conclusion</a></li>
  <li><a href="#acknowledgements" id="toc-acknowledgements" class="nav-link" data-scroll-target="#acknowledgements"><span class="header-section-number">7</span> Acknowledgements</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="algo-curve.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">




<div class="hidden">

</div>
<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Multiple testing theory is often used for exploratory analysis, like Genome-Wide Association Studies, where multiple features are tested to find promising ones. Classical multiple testing theory like Family-Wise Error Rate (FWER) control or False Discovery Rate (FDR) control <span class="citation" data-cites="MR1325392">(<a href="#ref-MR1325392" role="doc-biblioref">Benjamini and Hochberg 1995</a>)</span> can be used, but a more recent trend consists in the computation of post hoc bounds, also named post selection bounds or confidence envelopes, for the number of false positives, or, equivalently, for the False Discovery Proportion (FDP). This approach is notably advocated for in the context of exploratory research by <span class="citation" data-cites="MR2951390">(<a href="#ref-MR2951390" role="doc-biblioref">Goeman and Solari 2011, sec. 1</a>)</span>.</p>
<p>Mathematically speaking, a confidence upper bound (we prefer to say upper bound instead of envelope for obvious reasons) is a function <span class="math inline">\(\widehat V: \mathcal{P}(\mathbb{N}_m^*) \to \mathbb{N}_m\)</span>, where <span class="math inline">\(\mathbb{N}_m=\{0,\dotsc,m\}\)</span>, <span class="math inline">\(\mathbb{N}_m^*=\{1,\dotsc,m\}\)</span> and <span class="math inline">\(m\)</span> is the number of hypotheses, such that <span class="math display">\[\begin{equation}
\forall \alpha \in ]0,1[, \mathbb{P}\left(\forall S \subseteq \mathbb{N}_m^*, |S\cap \mathcal{H}_0|\leq \widehat V(S)\right)\geq 1-\alpha.
\label{eq_confidence}
\end{equation}\]</span> Here, <span class="math inline">\(\alpha\)</span> is a target error rate and <span class="math inline">\(\mathcal{H}_0\)</span> is the set of hypotheses indices that are true null hypotheses. Note that the construction of <span class="math inline">\(\widehat V\)</span> depends on <span class="math inline">\(\alpha\)</span> and on the random data <span class="math inline">\(X\)</span> and the dependence is omitted to lighten notation and because there is no ambiguity. The meaning of Equation <span class="math inline">\(\eqref{eq_confidence}\)</span> is that <span class="math inline">\(\widehat V\)</span> provides an upper bound of the number of null hypotheses in <span class="math inline">\(S\)</span> for any selection set <span class="math inline">\(S\subseteq \mathbb{N}_m^*\)</span>, which allows the user to perform post hoc selection on their data without breaching the statistical guarantee. Also note that by dividing by <span class="math inline">\(|S|\vee 1\)</span> in Equation <span class="math inline">\(\eqref{eq_confidence}\)</span> we also get a confidence bound for the FDP: <span class="math display">\[\begin{equation}
\forall \alpha \in ]0,1[, \mathbb{P}\left(\forall S \subseteq \mathbb{N}_m^*, \mathrm{FDP}(S)\leq \frac{\widehat V(S)}{|S|\vee 1}\right)\geq 1-\alpha.
\label{eq_confidence_fdp}
\end{equation}\]</span> So post hoc bounds provide ways to construct FDP-controlling sets instead of FDR-controlling sets, which is much more desirable given the nature of the FDR as an expected value. See for example <span class="citation" data-cites="MR3418717">(<a href="#ref-MR3418717" role="doc-biblioref">Bogdan et al. 2015, fig. 4</a>)</span> for a credible example where the FDR is controlled but the FDP has a highly undesirable behavior (either 0 because no discoveries at all are made, either higher than the target level).</p>
<p>The first confidence bounds are found in <span class="citation" data-cites="MR2279468">Genovese and Wasserman (<a href="#ref-MR2279468" role="doc-biblioref">2006</a>)</span> and <span class="citation" data-cites="MR2279639">Meinshausen (<a href="#ref-MR2279639" role="doc-biblioref">2006</a>)</span>, although, in the latter, only for selection sets of the form <span class="math inline">\(\{i\in\mathbb{N}_m: P_i\leq t\}\)</span> where <span class="math inline">\(P_i\)</span> is the <span class="math inline">\(p\)</span>-value associated to the null hypothesis <span class="math inline">\(H_{0,i}\)</span>. In <span class="citation" data-cites="MR2951390">Goeman and Solari (<a href="#ref-MR2951390" role="doc-biblioref">2011</a>)</span> the authors re-wrote the generic construction of <span class="citation" data-cites="MR2279468">Genovese and Wasserman (<a href="#ref-MR2279468" role="doc-biblioref">2006</a>)</span> in terms of closed testing <span class="citation" data-cites="MR468056">Marcus, Peritz, and Gabriel (<a href="#ref-MR468056" role="doc-biblioref">1976</a>)</span>, proposed several practical constructions and sparked a new interest in multiple testing procedures based on confidence envelopes. This work was followed by a prolific series of works like <span class="citation" data-cites="MR3305943">Meijer, Krebs, and Goeman (<a href="#ref-MR3305943" role="doc-biblioref">2015</a>)</span> or <span class="citation" data-cites="MR4731977">Vesely, Finos, and Goeman (<a href="#ref-MR4731977" role="doc-biblioref">2023</a>)</span>. In <span class="citation" data-cites="MR4124323">Blanchard, Neuvial, and Roquain (<a href="#ref-MR4124323" role="doc-biblioref">2020</a>)</span>, the authors introduce the new point of view of references families (see <a href="#sec-reference-fam" class="quarto-xref">Section&nbsp;2.2</a>) to construct post hoc bounds, and show the links between this meta-technique and the closed testing one, along with new bounds.</p>
<p>Following the reference family trail, in <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> the authors introduce new reference families with a special set-theoretic constraint that allows an efficient computation of the bound denoted by <span class="math inline">\(V^*_{\mathfrak{R}}\)</span> on a single selection set <span class="math inline">\(S\)</span>. The problem is that one often wants to compute <span class="math inline">\(V^*_{\mathfrak{R}}\)</span> on a whole path of selection sets <span class="math inline">\((S_t)_{t\in\mathbb{N}_m^*}\)</span>, for example the hypotheses attached to the <span class="math inline">\(t\)</span> smallest <span class="math inline">\(p\)</span>-values. Whereas the algorithm provided in the aforementioned work <span class="citation" data-cites="MR4178188">(<a href="#ref-MR4178188" role="doc-biblioref">Durand et al. 2020</a>, Algorithm 1)</span>, which is reproduced here, see <a href="#alg-vstar" class="quarto-xref">Algorithm 1</a>, is fast for a single evaluation, it is slow and inefficient to repeatedly call it to compute each <span class="math inline">\(V^*_{\mathfrak{R}}(S_t)\)</span>. If the <span class="math inline">\(S_t\)</span>’s are nested, and growing by one, that is <span class="math inline">\(S_1\subsetneq\dotsb\subsetneq S_m\)</span> and <span class="math inline">\(|S_t|=t\)</span>, there is a way to efficiently compute <span class="math inline">\(\left(V^*_{\mathfrak{R}}(S_t)\right)_{t\in\mathbb{N}_m}\)</span> by leveraging the nested structure.</p>
<p>This is the main contribution of the present paper: a new and fast algorithm computing the curve <span class="math inline">\(\left(V^*_{\mathfrak{R}}(S_t)\right)_{t\in\mathbb{N}_m}\)</span> for a nested path of selection sets, that is presented in <a href="#sec-fast-curve" class="quarto-xref">Section&nbsp;3.2</a>. An additional algorithm that can speed up computations both for the single-evaluation algorithm and the new curve-evaluation algorithm is also presented, in <a href="#sec-pruning" class="quarto-xref">Section&nbsp;3.1</a>. In <a href="#sec-notation" class="quarto-xref">Section&nbsp;2.1</a>, all necessary notation and vocabulary is re-introduced, most of it being the same as in <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span>. In <a href="#sec-implementation" class="quarto-xref">Section&nbsp;4</a> we discuss the current implementations of all the presented algorithms in the <code>R</code> <span class="citation" data-cites="R-base">(<a href="#ref-R-base" role="doc-biblioref">R Core Team 2024</a>)</span> package <code>sanssouci</code> <span class="citation" data-cites="sanssouci">(<a href="#ref-sanssouci" role="doc-biblioref">Neuvial et al. 2024</a>)</span>. Finally, a few numerical experiments are presented in Section <a href="#sec-numeric" class="quarto-xref">Section&nbsp;5</a> to demonstrate the computation time gain.</p>
</section>
<section id="notation-and-reference-family-methodology" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Notation and reference family methodology</h1>
<section id="sec-notation" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="sec-notation"><span class="header-section-number">2.1</span> Multiple testing notation</h2>
<p>As is usual in multiple testing theory, we consider a probability space <span class="math inline">\((\Omega,\mathcal A, \mathbb P)\)</span>, a model <span class="math inline">\(\mathcal{P}\)</span> on a measurable space <span class="math inline">\((\mathcal{X},\mathfrak{X})\)</span>, and data that is represented by a random variable <span class="math inline">\(X:(\Omega,\mathcal A)\to(\mathcal{X},\mathfrak{X})\)</span> with <span class="math inline">\(X\sim P\in \mathcal{P}\)</span>, that is, the law of <span class="math inline">\(X\)</span> is comprised in the model <span class="math inline">\(\mathcal{P}\)</span>.</p>
<p>Then we consider <span class="math inline">\(m\geq1\)</span> null hypotheses <span class="math inline">\(H_{0,1}, \dotsc, H_{0,m}\)</span> which formally are submodels, that is subsets of <span class="math inline">\(\mathcal{P}\)</span>. The associated alternative hypotheses <span class="math inline">\(H_{1,1}, \dotsc, H_{1,m}\)</span> are submodels such that <span class="math inline">\(H_{0,i}\cap H_{1,i}=\varnothing\)</span> for all <span class="math inline">\(i\in\mathbb{N}_m^*\)</span>. We denote by <span class="math inline">\(\mathcal{H}_0=\mathcal{H}_0(P)\)</span> (the dependence in <span class="math inline">\(P\)</span> will be dropped when there is no ambiguity) the set of all null hypotheses that are true, that is <span class="math inline">\(\mathcal{H}_0(P)=\{i\in\mathbb{N}_m^* : P\in H_{0,i}\}\)</span>. In other words, <span class="math inline">\(H_{0,i}\)</span> is true if and only if <span class="math inline">\(i\in\mathcal{H}_0\)</span>. For testing each <span class="math inline">\(H_{0,i}, i\in\mathbb{N}_m^*\)</span>, we have at hand a <span class="math inline">\(p\)</span>-value <span class="math inline">\(p_i=p_i(X)\)</span> (the dependence in <span class="math inline">\(X\)</span> will be dropped when there is no ambiguity) which is a random variable with the following property : if <span class="math inline">\(i\in\mathcal{H}_0\)</span>, then the law of <span class="math inline">\(p_i\)</span> is super-uniform, which is sometimes denoted <span class="math inline">\(\mathcal L(p_i)\succeq \mathcal{U}([0,1])\)</span>. This means that in such case, the cumulative distribution function (cdf) of <span class="math inline">\(p_i\)</span> is always smaller than or equal to the cdf of a random variable <span class="math inline">\(U\sim \mathcal{U}([0,1])\)</span> : <span class="math display">\[\begin{equation}
\forall x \in \mathbb{R}, \mathbb{P}\left(p_i\leq x\right)\leq \mathbb{P}\left(U\leq x\right) = 0\vee(x\wedge 1).
\label{eq_super_unif}
\end{equation}\]</span></p>
<p>For every subset of hypotheses <span class="math inline">\(S\subseteq\mathbb{N}_m^*\)</span>, let <span class="math inline">\(V(S)=|S\cap\mathcal{H}_0|\)</span>. If we think of <span class="math inline">\(S\)</span> as a selection set of hypotheses deemed significant, <span class="math inline">\(V(S)\)</span> is then the number of false positives (FP) in <span class="math inline">\(S\)</span>. <span class="math inline">\(V(S)\)</span> is our main object of interest and the quantity that we wish to over-estimate with confidence upper bounds (see Equation <span class="math inline">\(\eqref{eq_confidence}\)</span> or the more formal Equation <span class="math inline">\(\eqref{eq_confidence_formal}\)</span> below).</p>
<p>Finally let us consider the following toy example, that will be re-used in the remainder of the paper.</p>
<div id="exm-gauss" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 (Gaussian one-sided)</strong></span> In this case we assume that <span class="math inline">\(X=(X_1,\dotsc,X_m)\)</span> is a Gaussian vector and the null hypotheses refer to the nullity of the means in contrast to their positivity. That is, formally, <span class="math inline">\((\mathcal{X},\mathfrak{X})=(\mathbb R^m, \mathcal B\left(\mathbb R^m  \right))\)</span>, <span class="math inline">\(\mathcal P=\{ \mathcal N(\boldsymbol{\mu}, \Sigma) : \forall j \in\mathbb{N}_m^*, \mu_j\geq 0, \Sigma \text{ positive semidefinite}  \}\)</span>, for each <span class="math inline">\(i\in\mathbb{N}_m^*\)</span>, <span class="math inline">\(H_{0,i}= \{ \mathcal N(\boldsymbol{\mu}, \Sigma) \in \mathcal P :\mu_i=0 \}\)</span> and <span class="math inline">\(H_{1,i}=\{ \mathcal N(\boldsymbol{\mu}, \Sigma) \in \mathcal P :\mu_i&gt;0 \}\)</span>. Then we can construct <span class="math inline">\(p\)</span>-values by letting <span class="math inline">\(p_i(X)=\bar\Phi(X_i)=1-\Phi(X_i)\)</span>, where <span class="math inline">\(\Phi\)</span> denotes the cdf of <span class="math inline">\(\mathcal N(0,1)\)</span> and <span class="math inline">\(\bar\Phi\)</span> the associated survival function.</p>
</div>
</section>
<section id="sec-reference-fam" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-reference-fam"><span class="header-section-number">2.2</span> Post hoc bounds with reference families</h2>
<p>With the formalism introduced in last section, a confidence upper bound is a functional <span class="math inline">\(\widehat V:\mathcal X\times ]0,1[\to(\mathcal P(\mathbb{N}_m^*) \to \mathbb{N}_m)\)</span> such that, <span class="math display">\[\begin{equation}
\forall P\in\mathcal P, \forall X\sim P, \forall \alpha \in ]0,1[, \mathbb{P}\left(\forall S \subseteq \mathbb{N}_m^*, V(S)\leq \widehat V(X,\alpha)(S)\right)\geq 1-\alpha.
\label{eq_confidence_formal}
\end{equation}\]</span> In the remainder, the dependence in <span class="math inline">\((X,\alpha)\)</span> will be dropped when there is no ambiguity and <span class="math inline">\(\widehat V(X,\alpha)\)</span> will simply be written <span class="math inline">\(\widehat V\)</span>.</p>
<p>As said in the Introduction, many constructions, ultimately theoretically equivalent but differing by the practical steps involved, exist, and in this paper we focus on the meta-construction of <span class="citation" data-cites="MR4124323">Blanchard, Neuvial, and Roquain (<a href="#ref-MR4124323" role="doc-biblioref">2020</a>)</span> based on reference families. A reference family is a family <span class="math inline">\(\mathfrak{R}=\mathfrak{R}(X,\alpha)=(R_k,\zeta_k)_{k\in \mathcal K}\)</span> with <span class="math inline">\(|\mathcal K|\leq 2^m\)</span>, <span class="math inline">\(R_k\subseteq\mathbb{N}_m^*\)</span>, <span class="math inline">\(\zeta_k\in\left\{0,\dotsc,|R_k|\right\}\)</span> where everything (that is, <span class="math inline">\(\mathcal K\)</span> and all the <span class="math inline">\(R_k\)</span> and <span class="math inline">\(\zeta_k\)</span>) depends on <span class="math inline">\((X,\alpha)\)</span> but the dependency is not explicitly written. The <span class="math inline">\(R_k\)</span> are all distinct. We also define the following error criterion for a reference family, named Joint Error Rate (JER): <span class="math display">\[\begin{equation}
\mathrm{JER}(\mathfrak{R}) = \mathbb{P}\left(\exists k\in\mathcal K, |R_k\cap\mathcal{H}_0| &gt; \zeta_k \right) = \mathbb{P}\left(\exists k\in\mathcal K, V(R_k) &gt; \zeta_k \right).
\label{eq_jer}
\end{equation}\]</span> In the following, we are only interested in reference families that control the JER at level <span class="math inline">\(\alpha\)</span>: <span class="math display">\[\begin{equation}
\forall P\in\mathcal P, \forall X\sim P, \forall \alpha \in ]0,1[, 1-\mathrm{JER}(\mathfrak{R}(X,\alpha))=\mathbb{P}\left(\forall k\in\mathcal K, V(R_k)\leq \zeta_k\right) \geq 1-\alpha.
\label{eq_jer_control}
\end{equation}\]</span> Note that Equation <span class="math inline">\(\eqref{eq_jer_control}\)</span> is really similar to Equation <span class="math inline">\(\eqref{eq_confidence_formal}\)</span> except that the uniform guarantee, instead of being over all <span class="math inline">\(S\subseteq \mathbb{N}_m^*\)</span>, is only over all the <span class="math inline">\(R_k\subseteq \mathbb{N}_m^*, k\in\mathcal K\)</span>, with <span class="math inline">\(\mathcal K\)</span> having cardinality potentially much smaller than <span class="math inline">\(2^m\)</span>. A global confidence bound is then derived from a JER-controlling reference family by interpolation. Let <span class="math display">\[\begin{equation}
\mathcal A(\mathfrak{R})= \left\{A\subseteq \mathbb{N}_m^*:  \forall k\in\mathcal K, |R_k\cap A| \leq \zeta_k \right\}.
\label{eq_a}
\end{equation}\]</span> What says the JER control is that <span class="math inline">\(\mathcal{H}_0\in\mathcal A(\mathfrak{R})\)</span>. We leverage this information with the following confidence bound construction: <span class="math display">\[\begin{equation}
V^*_{\mathfrak{R}}(S) = \max_{A\in\mathcal A(\mathfrak{R})}|S\cap A|
\label{eq-vstar}
\end{equation}\]</span> which optimally uses the information provided by the JER control of the reference family, as proven by Proposition 2.1 of <span class="citation" data-cites="MR4124323">Blanchard, Neuvial, and Roquain (<a href="#ref-MR4124323" role="doc-biblioref">2020</a>)</span>. Because of the <span class="math inline">\(\max_{A\in\mathcal A(\mathfrak{R})}\)</span>, the computation of <span class="math inline">\(V^*_{\mathfrak{R}}(S)\)</span> is generally intractable (see Proposition 2.2 of <span class="citation" data-cites="MR4124323">Blanchard, Neuvial, and Roquain (<a href="#ref-MR4124323" role="doc-biblioref">2020</a>)</span>), but for specific structures of reference families, a polynomial computation can be derived. This is the topic of <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> and of next section.</p>
</section>
<section id="sec-forest-structure" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sec-forest-structure"><span class="header-section-number">2.3</span> Regions with a forest structure</h2>
<p>The core concept of this section is to assume that the regions <span class="math inline">\(R_k\)</span>’s of the reference family are what we called in <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> a forest structure, that is two regions are either disjoint or nested: <span class="math display">\[\begin{equation}
\forall k,k'\in\mathcal{K} , R_k \cap R_{k'} \in \{ R_k,  R_{k'} , \varnothing \}.
\label{eq-forest}
\end{equation}\]</span> Representing the <span class="math inline">\(R_k\)</span>’s with a directed graph, where there is an oriented edge <span class="math inline">\(R_k \leftarrow R_{k'}\)</span> if and only if <span class="math inline">\(R_k \subset R_{k'}\)</span> and there is no <span class="math inline">\(R_{k''}\)</span> such that <span class="math inline">\(R_k \subsetneq R_{k''}\subsetneq R_{k'}\)</span> gives a forest, hence the name. See <a href="#exm-toy-forest" class="quarto-xref">Example&nbsp;2</a> and its representation in <a href="#fig-forest-exm" class="quarto-xref">Figure&nbsp;1</a>.</p>
<p>We also need to introduce the notion of depth with the following function: <span class="math display">\[\begin{equation}
\phi \:  : \: \left\{
\begin{array}{l  c l  }
\mathcal{K}&amp; \to &amp; \mathbb{N}^*\\
k &amp; \mapsto &amp; 1 + \left| \{k'\in\mathcal{K}: R_k\subsetneq R_{k'} \} \right|   .
\end{array}
\right.
\label{eq-depth}
\end{equation}\]</span></p>
<div id="exm-toy-forest" class="theorem example">
<p><span class="theorem-title"><strong>Example 2</strong></span> Let <span class="math inline">\(m=25\)</span>, <span class="math inline">\(R_1 = \{1, \dotsc , 20 \}\)</span>, <span class="math inline">\(R_2  =  \{1, 2  \}\)</span>, <span class="math inline">\(R_3   =   \{3 , \dotsc , 10 \}\)</span>, <span class="math inline">\(R_4  =    \{11, \dotsc , 20 \}\)</span>, <span class="math inline">\(R_5 =  \{5, \dotsc , 10 \}\)</span>, <span class="math inline">\(R_6   =     \{11, \dotsc , 16 \}\)</span>, <span class="math inline">\(R_7  =   \{17, \dotsc ,20  \}\)</span>, <span class="math inline">\(R_8=\{21,22\}\)</span>, <span class="math inline">\(R_9 = \{22\}\)</span>. This is the same example as Example 2 of <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> and it is graphically depicted in <a href="#fig-forest-exm" class="quarto-xref">Figure&nbsp;1</a>. The sets <span class="math inline">\(R_1\)</span>, <span class="math inline">\(R_8\)</span> are of depth <span class="math inline">\(1\)</span>; the sets <span class="math inline">\(R_2,R_3,R_4,R_9\)</span> are of depth <span class="math inline">\(2\)</span>; the sets <span class="math inline">\(R_5,R_6,R_7\)</span> are of depth <span class="math inline">\(3\)</span>.</p>
</div>
<div id="fig-forest-exm" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-forest-exm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="fig-forest-exm" data-opt-additional-packages="\usetikzlibrary{arrows}"><pre class="sourceCode tikz code-with-copy"><code class="sourceCode latex"><span id="fig-forest-exm-1"><a href="#fig-forest-exm-1" aria-hidden="true" tabindex="-1"></a><span class="co">%%| filename: ../figure-tikz/fig-tikz-01</span></span>
<span id="fig-forest-exm-2"><a href="#fig-forest-exm-2" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">tikzpicture</span>}[scale=0.85]</span>
<span id="fig-forest-exm-3"><a href="#fig-forest-exm-3" aria-hidden="true" tabindex="-1"></a> <span class="fu">\tikzstyle</span>{quadri}=[circle,draw,text=black, thick]</span>
<span id="fig-forest-exm-4"><a href="#fig-forest-exm-4" aria-hidden="true" tabindex="-1"></a> <span class="fu">\tikzstyle</span>{estun}=[-&gt;,&gt;=latex,very thick]</span>
<span id="fig-forest-exm-5"><a href="#fig-forest-exm-5" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R1) at (0,3) {<span class="ss">$R_1$</span>};</span>
<span id="fig-forest-exm-6"><a href="#fig-forest-exm-6" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R2) at (-2,1) {<span class="ss">$R_2$</span>};</span>
<span id="fig-forest-exm-7"><a href="#fig-forest-exm-7" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R3) at (0,1) {<span class="ss">$R_3$</span>};</span>
<span id="fig-forest-exm-8"><a href="#fig-forest-exm-8" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R4) at (2,1) {<span class="ss">$R_4$</span>};</span>
<span id="fig-forest-exm-9"><a href="#fig-forest-exm-9" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R5) at (0,-1) {<span class="ss">$R_5$</span>};</span>
<span id="fig-forest-exm-10"><a href="#fig-forest-exm-10" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R6) at (1.5,-1) {<span class="ss">$R_6$</span>};</span>
<span id="fig-forest-exm-11"><a href="#fig-forest-exm-11" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R7) at (2.5,-1) {<span class="ss">$R_7$</span>};</span>
<span id="fig-forest-exm-12"><a href="#fig-forest-exm-12" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R8) at (4,3) {<span class="ss">$R_8$</span>};</span>
<span id="fig-forest-exm-13"><a href="#fig-forest-exm-13" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R9) at (4,1) {<span class="ss">$R_9$</span>};</span>
<span id="fig-forest-exm-14"><a href="#fig-forest-exm-14" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R1)--(R2);</span>
<span id="fig-forest-exm-15"><a href="#fig-forest-exm-15" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R1)--(R3);</span>
<span id="fig-forest-exm-16"><a href="#fig-forest-exm-16" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R1)--(R4);</span>
<span id="fig-forest-exm-17"><a href="#fig-forest-exm-17" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R3)--(R5);</span>
<span id="fig-forest-exm-18"><a href="#fig-forest-exm-18" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R4)--(R6);</span>
<span id="fig-forest-exm-19"><a href="#fig-forest-exm-19" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R4)--(R7);</span>
<span id="fig-forest-exm-20"><a href="#fig-forest-exm-20" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R8)--(R9);</span>
<span id="fig-forest-exm-21"><a href="#fig-forest-exm-21" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">tikzpicture</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-forest-exm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: The regions of <a href="#exm-toy-forest" class="quarto-xref">Example&nbsp;2</a>.
</figcaption>
</figure>
</div>
<p>Another tool of <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> that will be used is its Lemma 2, that is the identification of <span class="math inline">\(\mathfrak{R}\)</span> with a set <span class="math inline">\(\mathcal C\subset \left\{(i,j)\in \left({\mathbb N_N}^*\right)^2 \: : i\leq j\right\}\)</span> such that for <span class="math inline">\((i,j), (i',j')\in\mathcal C\)</span>, <span class="math inline">\(\{i,\dotsc, j\}\cap\{i',\dotsc,j'\}\in\left\{\varnothing, \{i,\dotsc, j\},\{i',\dotsc j'\}  \right\}\)</span>. With this identification, each <span class="math inline">\(R_k=R_{(i,j)}\)</span> can be written as <span class="math inline">\(P_{i:j}=\bigcup_{i\leq n\leq j}P_n\)</span> where <span class="math inline">\((P_n)_{1\leq n \leq N}\)</span> is a partition of <span class="math inline">\(\mathbb{N}_m^*\)</span>. The <span class="math inline">\(P_n\)</span>’s were called atoms in <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> because they have the thinnest granularity in the structure, but to continue the analogy with graphs, forests and trees, they can also be called leafs. See <a href="#exm-toy-leaves" class="quarto-xref">Example&nbsp;3</a> for a concrete example.</p>
<div id="exm-toy-leaves" class="theorem example">
<p><span class="theorem-title"><strong>Example 3 (Continuation of <a href="#exm-toy-forest" class="quarto-xref">Example&nbsp;2</a>)</strong></span> For the reference family given in <a href="#exm-toy-forest" class="quarto-xref">Example&nbsp;2</a>, a partition of atoms is given by <span class="math inline">\(P_1 =R_2\)</span>, <span class="math inline">\(P_2  =   R_3\setminus R_5\)</span>, <span class="math inline">\(P_3  =   R_5\)</span>, <span class="math inline">\(P_4=R_6\)</span>, <span class="math inline">\(P_5=R_7\)</span>, <span class="math inline">\(P_6=R_8\setminus R_9\)</span>, <span class="math inline">\(P_7=R_9\)</span>, <span class="math inline">\(P_8=\mathbb{N}_m^* \setminus \{R_1 \cup R_8 \}\)</span>. Then <span class="math inline">\(R_1=P_{1:5}\)</span>, <span class="math inline">\(R_3=P_{2:3}\)</span>, <span class="math inline">\(R_4=P_{4:5}\)</span> and <span class="math inline">\(R_8=P_{6:7}\)</span>. Note that not all atoms are regions of the family. Those new labels are graphically depicted in <a href="#fig-leaves-exm" class="quarto-xref">Figure&nbsp;2</a>. The nodes that correspond to atoms that are not in the family are depicted with a dashed circle, and all atoms are depicted in gray. This is the same example as Example 3 of <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span>.</p>
</div>
<div id="fig-leaves-exm" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-leaves-exm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="fig-leaves-exm" data-opt-additional-packages="\usetikzlibrary{arrows}"><pre class="sourceCode tikz code-with-copy"><code class="sourceCode latex"><span id="fig-leaves-exm-1"><a href="#fig-leaves-exm-1" aria-hidden="true" tabindex="-1"></a><span class="co">%%| filename: ../figure-tikz/fig-tikz-02</span></span>
<span id="fig-leaves-exm-2"><a href="#fig-leaves-exm-2" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">tikzpicture</span>}[scale=0.85]</span>
<span id="fig-leaves-exm-3"><a href="#fig-leaves-exm-3" aria-hidden="true" tabindex="-1"></a> <span class="fu">\tikzstyle</span>{quadri}=[circle,draw,text=black,thick]</span>
<span id="fig-leaves-exm-4"><a href="#fig-leaves-exm-4" aria-hidden="true" tabindex="-1"></a> <span class="fu">\tikzstyle</span>{estun}=[-&gt;,&gt;=latex,very thick]</span>
<span id="fig-leaves-exm-5"><a href="#fig-leaves-exm-5" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R1) at (0,3) {<span class="ss">$P_{1:5}$</span>};</span>
<span id="fig-leaves-exm-6"><a href="#fig-leaves-exm-6" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri, fill=gray!25] (R2) at (-2,1) {<span class="ss">$P_1$</span>};</span>
<span id="fig-leaves-exm-7"><a href="#fig-leaves-exm-7" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R3) at (0,1) {<span class="ss">$P_{2:3}$</span>};</span>
<span id="fig-leaves-exm-8"><a href="#fig-leaves-exm-8" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R4) at (2,1) {<span class="ss">$P_{4:5}$</span>};</span>
<span id="fig-leaves-exm-9"><a href="#fig-leaves-exm-9" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri, dashed,fill=gray!25] (P2) at (-0.5,-1) {<span class="ss">$P_2$</span>};</span>
<span id="fig-leaves-exm-10"><a href="#fig-leaves-exm-10" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri,fill=gray!25] (R5) at (0.5,-1) {<span class="ss">$P_3$</span>};</span>
<span id="fig-leaves-exm-11"><a href="#fig-leaves-exm-11" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri,fill=gray!25] (R6) at (1.5,-1) {<span class="ss">$P_4$</span>};</span>
<span id="fig-leaves-exm-12"><a href="#fig-leaves-exm-12" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri,fill=gray!25] (R7) at (2.5,-1) {<span class="ss">$P_5$</span>};</span>
<span id="fig-leaves-exm-13"><a href="#fig-leaves-exm-13" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri] (R8) at (4,3) {<span class="ss">$P_{6:7}$</span>};</span>
<span id="fig-leaves-exm-14"><a href="#fig-leaves-exm-14" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri,dashed,fill=gray!25] (P6) at (3.5,1) {<span class="ss">$P_6$</span>};</span>
<span id="fig-leaves-exm-15"><a href="#fig-leaves-exm-15" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri,fill=gray!25] (R9) at (4.5,1) {<span class="ss">$P_7$</span>};</span>
<span id="fig-leaves-exm-16"><a href="#fig-leaves-exm-16" aria-hidden="true" tabindex="-1"></a> <span class="fu">\node</span>[quadri,dashed,fill=gray!25] (P8) at (6,3) {<span class="ss">$P_8$</span>};</span>
<span id="fig-leaves-exm-17"><a href="#fig-leaves-exm-17" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R1)--(R2);</span>
<span id="fig-leaves-exm-18"><a href="#fig-leaves-exm-18" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R1)--(R3);</span>
<span id="fig-leaves-exm-19"><a href="#fig-leaves-exm-19" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R1)--(R4);</span>
<span id="fig-leaves-exm-20"><a href="#fig-leaves-exm-20" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R3)--(R5);</span>
<span id="fig-leaves-exm-21"><a href="#fig-leaves-exm-21" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun,dashed,thick] (R3)--(P2);</span>
<span id="fig-leaves-exm-22"><a href="#fig-leaves-exm-22" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R4)--(R6);</span>
<span id="fig-leaves-exm-23"><a href="#fig-leaves-exm-23" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R4)--(R7);</span>
<span id="fig-leaves-exm-24"><a href="#fig-leaves-exm-24" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun] (R8)--(R9);</span>
<span id="fig-leaves-exm-25"><a href="#fig-leaves-exm-25" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[estun,dashed,thick] (R8)--(P6);</span>
<span id="fig-leaves-exm-26"><a href="#fig-leaves-exm-26" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">tikzpicture</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-leaves-exm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: The regions of <a href="#exm-toy-forest" class="quarto-xref">Example&nbsp;2</a> but with the labels of <a href="#exm-toy-leaves" class="quarto-xref">Example&nbsp;3</a>.
</figcaption>
</figure>
</div>
<p>When all leaves are regions of the family, it is said that the family is complete. If this is not the case, the family can easily be completed by adding the missing leaves (and using their cardinality as associated <span class="math inline">\(\zeta\)</span>) without changing the value <span class="math inline">\(V^*_{\mathfrak{R}}\)</span>. See Definition 2, Lemma 6 and Algorithm 2 of <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> for the details.</p>
<p><span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> also proved in their Theorem 1 that: <span class="math display">\[\begin{equation}
V^*_{\mathfrak{R}}(S)=\min_{Q\subseteq\mathcal{K}}\left(\sum_{k'\in Q}\zeta_{k'}\wedge|S\cap R_{k'}|+\left| S\setminus\bigcup_{k'\in Q} R_{k'}   \right|\right)
\label{eq_vstar_Q}
\end{equation}\]</span> and, even better, in their Corollary 1 <em>(iii)</em> that: <span class="math display">\[\begin{equation}
V^*_{\mathfrak{R}}(S) = \min_{Q\in \mathfrak P}\sum_{k'\in Q}\zeta_{k'}\wedge|S\cap R_{k'}|,
\label{eq_vstar_Qpartition}
\end{equation}\]</span> provided that the family is complete. Here, <span class="math inline">\(\mathfrak P \subseteq \mathcal P(\mathcal{K})\)</span> is the set of subsets of <span class="math inline">\(\mathcal{K}\)</span> that realize a partition, that is, the set of <span class="math inline">\(Q\subseteq\mathcal{K}\)</span> such that the <span class="math inline">\(R_k\)</span>, <span class="math inline">\(k\in Q\)</span>, form a partition of <span class="math inline">\(\mathbb{N}_m^*\)</span>. So the minimum in Equation <span class="math inline">\(\eqref{eq_vstar_Qpartition}\)</span> is over way less elements than in Equation <span class="math inline">\(\eqref{eq_vstar_Q}\)</span>.</p>
<p>Finally, that paper provides a polynomial algorithm to <span class="math inline">\(V^*_{\mathfrak{R}}(S)\)</span> for a single <span class="math inline">\(S\subseteq\mathbb{N}_m^*\)</span>, which we reproduce here in <a href="#alg-vstar" class="quarto-xref">Algorithm 1</a>. The family is assumed complete, otherwise the first step would be to complete it. In the original paper, <span class="math inline">\(\mathcal{K}^h\)</span> used to designate the elements of <span class="math inline">\(\mathcal{K}\)</span> at depth <span class="math inline">\(h\)</span> plus the atoms at depth <span class="math inline">\(\leq h\)</span>. Actually one can realize that the last assumption is not needed for this algorithm to perform exactly the same, with the added benefit of not repeating computations at the atoms that don’t have the maximal depth. The only change is that sometimes <span class="math inline">\(Succ_k\)</span> can be empty, in which case we simply let <span class="math inline">\(newVec_k=\zeta_k\wedge|S\cap R_k|\)</span>. Thus, here in this paper, we define <span class="math inline">\(\mathcal{K}^h\)</span> as only the elements of <span class="math inline">\(\mathcal{K}\)</span> at depth <span class="math inline">\(h\)</span> (the previous intricate definition may still be necessary for the proof of Theorem 1 of <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span>): <span class="math inline">\(\mathcal{K}^h=\{ (i,j)\in\mathcal{K}: \phi(i,j)=h      \}, \:\:\:h\geq 1.\)</span> This is the only deviation from the notation of <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span>. Finally note that in the ongoing analogy with graph theory, the elements of <span class="math inline">\(\mathcal{K}^1\)</span> are the roots of the different trees making up the forest.</p>
<div id="alg-vstar" class="pseudocode-container quarto-float" data-comment-delimiter="//" data-indent-size="1.2em" data-pseudocode-number="1" data-line-number-punc=":" data-line-number="true" data-caption-prefix="Algorithm" data-no-end="false">
<div class="pseudocode">
\begin{algorithm} \caption{Computation of a given $V^*_{\mathfrak{R}}(S)$} \begin{algorithmic} \Procedure{Vstar}{S, $\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$ with $\mathfrak{R}$ complete} \State $ H \gets \max_{k\in\mathcal{K}} \phi(k) $ \Comment{maximum depth} \For{$h = H-1, \dotsc, 1$} \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h \}$ \State $newVec\gets (0)_{k \in \mathcal{K}^h}$ \For{$k \in \mathcal{K}^h$} \State $Succ_k \gets \{ k' \in \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$ \If{$Succ_k=\varnothing$} \State $newVec_k \gets \zeta_k\wedge|S\cap R_k|$ \Else \State $newVec_k \gets \min\left( \zeta_{k}\wedge|S\cap R_k| , \sum_{k'\in Succ_k} Vec_{k'} \right)$ \EndIf \EndFor \State $Vec\gets newVec$ \EndFor \Return $\sum_{k\in\mathcal{K}^1} Vec_k $ \EndProcedure \end{algorithmic} \end{algorithm}
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>In the practical implementation of this algorithm (and of the following <a href="#alg-pruning" class="quarto-xref">Algorithm 2</a>), <span class="math inline">\(Vec\)</span> and <span class="math inline">\(newVec\)</span> are always of size <span class="math inline">\(N\)</span> (the number of leaves) instead of the cardinality of <span class="math inline">\(\mathcal{K}^h\)</span>. And the sum <span class="math inline">\(\sum_{k'\in Succ_k} Vec_{k'}\)</span> is really easy to compute: if <span class="math inline">\(R_k= R_{(i_0,i_{p}-1)}= \bigcup_{ j=1}^{p} R_{(i_{ j-1}, i_{ j}-1)}=\bigcup_{i_0\leq n\leq i_{p}-1}P_n\in\mathcal{K}^h\)</span> for some <span class="math inline">\(p\geq2\)</span>, a strictly increasing sequence <span class="math inline">\((i_0,\dotsc,i_{p})\)</span> and <span class="math inline">\(R_{(i_{ j-1}, i_{ j}-1)}\in\mathcal{K}^{h+1}\)</span> for all <span class="math inline">\(1\leq j\leq p\)</span>, then we simply sum <span class="math inline">\(Vec\)</span> over the indices from <span class="math inline">\(i_{0}\)</span> to <span class="math inline">\(i_{p}-1\)</span>. After that, the computed quantity is set in <span class="math inline">\(newVec\)</span> at index <span class="math inline">\(i_0\)</span>. So actually computing <span class="math inline">\(Succ_k\)</span> is not needed and not done.</p>
</div>
</div>
<p>The computation time of the algorithm is in <span class="math inline">\(O(m|\mathcal{K}|)\)</span>, which is fast for a single evaluation, but calling it repeatedly on a path of selection sets <span class="math inline">\((S_t)_{t\in\mathbb{N}_m^*}\)</span> has complexity <span class="math inline">\(O(m^2|\mathcal{K}|)\)</span> which is not desirable and makes computations difficult in practice, hence the need for a new, faster algorithm.</p>
<div id="rem-zeta" class="proof remark">
<p><span class="proof-title"><em>Remark 1</em>. </span>The specific computation of the <span class="math inline">\(R_k\)</span>’s and the <span class="math inline">\(\zeta_k\)</span>’s such that Equation <span class="math inline">\(\eqref{eq_jer_control}\)</span> holds is outside the scope of the present paper, but different constructions can be found in <span class="citation" data-cites="MR4124323">Blanchard, Neuvial, and Roquain (<a href="#ref-MR4124323" role="doc-biblioref">2020</a>)</span>, <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> or <span class="citation" data-cites="blain22notip">Blain, Thirion, and Neuvial (<a href="#ref-blain22notip" role="doc-biblioref">2022</a>)</span> for example.</p>
</div>
</section>
</section>
<section id="new-algorithms" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> New algorithms</h1>
<section id="sec-pruning" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-pruning"><span class="header-section-number">3.1</span> Pruning the forest</h2>
<p>We remark the simple fact that if, for example, <span class="math inline">\((1,1), (2,2), (1,2)\in\mathcal{K}\)</span>, and <span class="math inline">\(\zeta_{(1,2)}\geq \zeta_{(1,1)}+\zeta_{(2,2)}\)</span>, then <span class="math inline">\(R_{(1,2)}\)</span> never contributes to the computation of any <span class="math inline">\(V^*_{\mathfrak{R}}(S)\)</span> and it could just be removed from <span class="math inline">\(\mathfrak{R}\)</span>. We now formalize and prove this pruning scheme.</p>
<div id="def-pruning" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (Pruning)</strong></span> We define by <span class="math inline">\(\mathcal{K}^{\mathfrak{pr}}\)</span> (<span class="math inline">\(\mathcal{K}\)</span> pruned) the set of elements of <span class="math inline">\(\mathcal{K}\)</span> such that we removed all <span class="math inline">\((i,i')\)</span> such that there exists <span class="math inline">\(p\geq2\)</span> and integers <span class="math inline">\(i_1,\dotsc,i_{p-1}\)</span> such that, when setting <span class="math inline">\(i_0=i\)</span> and <span class="math inline">\(i_{p}=i'+1\)</span>, the sequence <span class="math inline">\((i_0,\dotsc,i_{p})\)</span> is strictly increasing, <span class="math inline">\((i_{j-1},i_{j}-1)\in\mathcal{K}\)</span> for all <span class="math inline">\(1\leq j\leq p\)</span> and finally <span class="math inline">\(\zeta_{(i,i')}=\zeta_{(i_0,i_{p}-1)}\geq \sum_{j=1}^{p} \zeta_{(i_{j-1}, i_{j}-1)}\)</span>.</p>
</div>
<p>An important note is that for a removed <span class="math inline">\((i,i')\in\mathcal{K}\setminus\mathcal{K}^{\mathfrak{pr}}\)</span>, we can always choose the indices <span class="math inline">\(i_1,\dotsc,i_{p-1}\)</span> such that actually <span class="math inline">\((i_j,i_{j+1}-1)\in\mathcal{K}^{\mathfrak{pr}}\)</span> and not only <span class="math inline">\(\mathcal{K}\)</span>, because if <span class="math inline">\((i_j,i_{j+1}-1)\in\mathcal{K}\setminus\mathcal{K}^{\mathfrak{pr}}\)</span> it can itself be fragmented, and this decreasing recursion eventually ends (the later possible being at the atoms of the forest structure). Also note that removing elements from <span class="math inline">\(\mathcal{K}\)</span> does not alter the fact that we have at hand a forest structure, that is, the reference family defined by <span class="math inline">\(\mathfrak{R}^{\mathfrak{pr}}=(R_k,\zeta_k)_{k\in\mathcal{K}^{\mathfrak{pr}}}\)</span> has a forest structure. Because pruning a forest structure does not touch the atoms, note finally that if <span class="math inline">\(\mathcal{K}\)</span> is complete then so is <span class="math inline">\(\mathcal{K}^{\mathfrak{pr}}\)</span>.</p>
<p>The following proposition states that pruning the forest does not alter the bound.</p>
<div id="prp-pruning" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1</strong></span> For any <span class="math inline">\(S\subseteq \mathbb{N}_m^*\)</span>, <span class="math inline">\(V^*_{\mathfrak{R}}(S)=V^*_{\mathfrak{R}^{\mathfrak{pr}}}(S)\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Recall Equation <span class="math inline">\(\eqref{eq_vstar_Q}\)</span> and, because <span class="math inline">\(\mathfrak{R}^{\mathfrak{pr}}\)</span> also has a forest structure, <span class="math display">\[\begin{equation}
V^*_{\mathfrak{R}^{\mathfrak{pr}}}(S)=\min_{Q\subseteq\mathcal{K}^{\mathfrak{pr}}}\left(\sum_{k'\in Q}\zeta_{k'}\wedge|S\cap R_{k'}|+\left| S\setminus\bigcup_{k'\in Q} R_{k'}   \right|\right),
\label{eq_vstarpruned_Q}
\end{equation}\]</span> so we immediately get that <span class="math inline">\(V^*_{\mathfrak{R}}(S)\leq V^*_{\mathfrak{R}^{\mathfrak{pr}}}(S)\)</span>.</p>
<p>Let any <span class="math inline">\(Q\subseteq \mathcal{K}\)</span>. We split <span class="math inline">\(Q\)</span> in <span class="math inline">\(A\)</span> elements of <span class="math inline">\(\mathcal{K}\setminus\mathcal{K}^{\mathfrak{pr}}\)</span>, denoted <span class="math inline">\((i_{0,a}, i_{p_a,a}-1)\)</span>, <span class="math inline">\(1\leq a\leq A\)</span> for some <span class="math inline">\(p_a\geq2\)</span>, and <span class="math inline">\(B\)</span> elements of <span class="math inline">\(\mathcal{K}^{\mathfrak{pr}}\)</span>, simply denoted <span class="math inline">\(k_b\)</span>, <span class="math inline">\(1\leq b\leq B\)</span>. By the definition of <span class="math inline">\(\mathcal{K}^{\mathfrak{pr}}\)</span> and the previous remarks, for any <span class="math inline">\(1\leq a \leq A\)</span>, there exist integers <span class="math inline">\(i_{1,a},\dotsc,i_{p_a-1,a}\)</span> such that <span class="math inline">\(i_{0,a}&lt;i_{1,a}&lt;\dotsb&lt;i_{p_a-1,a} &lt; i_{p_a,a}\)</span>, <span class="math inline">\((i_{j-1,a},i_{j,a}-1)\in\mathcal{K}^{\mathfrak{pr}}\)</span> for all <span class="math inline">\(1\leq j\leq p_a\)</span>, and <span class="math inline">\(\zeta_{(i_{0,a}, i_{p_a,a}-1)}\geq \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)}\)</span>. Now let <span class="math display">\[\begin{equation}
Q^{\mathfrak{pr}}=\{k_b : 1\leq b\leq B \} \cup \{ (i_{j-1,a},i_{j,a}-1) :  1\leq a\leq A, 1\leq j\leq p_a  \}.
\label{eq_Qpr}
\end{equation}\]</span> We have that <span class="math inline">\(Q^{\mathfrak{pr}}\subseteq \mathcal{K}^{\mathfrak{pr}}\)</span> and <span class="math inline">\(\bigcup_{k\in Q}R_k=\bigcup_{k\in Q^{\mathfrak{pr}}}R_k\)</span>. Then, <span class="math display">\[\begin{align*}
\sum_{k\in Q}\zeta_k\wedge|S\cap R_k|+\left| S\setminus\bigcup_{k\in Q} R_k   \right|&amp;=\sum_{b=1}^B\zeta_{k_b}\wedge|S\cap R_{k_b}| \\
&amp;\qquad+\sum_{a=1}^A\zeta_{(i_{0,a}, i_{p_a,a}-1)}\wedge |S\cap R_{(i_{0,a}, i_{p_a,a}-1)}| \\
&amp;\qquad+ \left| S\setminus\bigcup_{k\in Q} R_k   \right|    ,
\end{align*}\]</span> but for all <span class="math inline">\(1\leq a\leq A\)</span>, <span class="math display">\[\begin{align*}
\zeta_{(i_{0,a}, i_{p_a,a}-1)}&amp;\geq  \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} \\
&amp;\geq   \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} \wedge |S\cap R_{(i_{j-1,a}, i_{j,a}-1)}| ,
\end{align*}\]</span> so the term <span class="math inline">\(\sum_{a=1}^A\zeta_{(i_{0,a}, i_{p_a,a}-1)}\wedge |S\cap R_{(i_{0,a}, i_{p_a,a}-1)}|\)</span> is greater than or equal to <span class="math display">\[\begin{equation*}
\sum_{a=1}^A\left(  \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} \wedge |S\cap R_{(i_{j-1,a}, i_{j,a}-1)}| \right)\wedge |S\cap R_{(i_{0,a}, i_{p_a,a}-1)}| ,
\end{equation*}\]</span> which is simply equal to <span class="math display">\[\begin{equation*}
\sum_{a=1}^A  \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} \wedge |S\cap R_{(i_{j-1,a}, i_{j,a}-1)}|.
\end{equation*}\]</span> Furthermore <span class="math inline">\(\left|S\setminus\bigcup_{k\in Q} R_k\right|= \left|S\setminus\bigcup_{k\in Q^{\mathfrak{pr}}} R_k\right|\)</span> so finally: <span class="math display">\[\begin{align}
\sum_{k\in Q}\zeta_k\wedge|S\cap R_k|+\left| S\setminus\bigcup_{k\in Q} R_k   \right| &amp;\geq \sum_{k\in Q^{\mathfrak{pr}}}\zeta_k\wedge|S\cap R_k|+\left| S\setminus\bigcup_{k\in Q^{\mathfrak{pr}}} R_k   \right|   \label{pruning_ineq}\\
&amp;\geq V^*_{\mathfrak{R}^{\mathfrak{pr}}}(S). \notag
\end{align}\]</span> Note that Equation <span class="math inline">\(\eqref{pruning_ineq}\)</span> is true even if there are some <span class="math inline">\(b\in\{ 1,\dotsc,B\}, a\in\{ 1,\dotsc,A\}, j\in\{ 1,\dotsc,p_a\}\)</span> such that <span class="math inline">\(k_b=(i_{j-1,a}, i_{j,a}-1)\)</span>. We minimize over all <span class="math inline">\(Q\)</span> to get that <span class="math inline">\(V^*_{\mathfrak{R}}(S)\geq V^*_{\mathfrak{R}^{\mathfrak{pr}}}(S)\)</span>. <span class="math inline">\(\square\)</span></p>
</div>
<p>This gives a practical way to speed up computations by first pruning the family before computing any <span class="math inline">\(V^*_{\mathfrak{R}}(S)\)</span>, because <span class="math inline">\(\mathcal{K}^{\mathfrak{pr}}\)</span> is smaller than <span class="math inline">\(\mathcal{K}\)</span>, and by the above Proposition there is no theoretical loss in doing so.</p>
<p>Furthermore, pruning can be done really simply by following <a href="#alg-vstar" class="quarto-xref">Algorithm 1</a> for <span class="math inline">\(S=\mathbb{N}_m^*\)</span>, and pruning when appropriate. This gives the following <a href="#alg-pruning" class="quarto-xref">Algorithm 2</a>, assuming, for simplicity, that the family is complete. The computation time of the algorithm is the same as <a href="#alg-vstar" class="quarto-xref">Algorithm 1</a>, that is <span class="math inline">\(O(m|\mathcal{K}|)\)</span>. Note that the only differences between <a href="#alg-pruning" class="quarto-xref">Algorithm 2</a> and <a href="#alg-vstar" class="quarto-xref">Algorithm 1</a> are the pruning step and <span class="math inline">\(\zeta_k\)</span> replacing <span class="math inline">\(\zeta_k\wedge|S\cap R_k|\)</span>, because <span class="math inline">\(\zeta_k\leq|R_k|\)</span> and here <span class="math inline">\(S=\mathbb{N}_m^*\)</span>, so <span class="math inline">\(\zeta_k\wedge|\mathbb{N}_m^*\cap R_k|=\zeta_k\)</span>. Also note that the algorithm returns <span class="math inline">\(V^*_{\mathfrak{R}}(\mathbb{N}_m^*)\)</span> as a by-product. The following proposition states that <a href="#alg-pruning" class="quarto-xref">Algorithm 2</a> indeed produces the pruned region as in <a href="#def-pruning" class="quarto-xref">Definition&nbsp;1</a>.</p>
<div id="alg-pruning" class="pseudocode-container quarto-float" data-comment-delimiter="//" data-indent-size="1.2em" data-pseudocode-number="2" data-line-number-punc=":" data-line-number="true" data-caption-prefix="Algorithm" data-no-end="false">
<div class="pseudocode">
\begin{algorithm} \caption{Pruning of $\mathfrak{R}$} \begin{algorithmic} \Procedure{Pruning}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$ with $\mathfrak{R}$ complete} \State $\mathcal{L}\gets\mathcal{K}$ \State $ H \gets \max_{k\in\mathcal{K}} \phi(k) $ \Comment{maximum depth} \For{$h = H-1, \dotsc, 1$} \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h \}$ \State $newVec\gets (0)_{k \in \mathcal{K}^h}$ \For{$k \in \mathcal{K}^h$} \State $Succ_k \gets \{ k' \in \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$ \If{$Succ_k=\varnothing$} \State $newVec_k \gets \zeta_k$ \Else \If{$\zeta_{k} \geq \sum_{k'\in Succ_k} Vec_{k'}$} \State $\mathcal{L}\gets \mathcal{L}\setminus \{ k \}$ \Comment{pruning of the region indexed by $k$} \EndIf \State $newVec_k \gets \min\left( \zeta_{k} , \sum_{k'\in Succ_k} Vec_{k'} \right)$ \EndIf \EndFor \State $Vec\gets newVec$ \EndFor \Return $(\mathcal{L},\sum_{k\in\mathcal{K}^1} Vec_k )$ \EndProcedure \end{algorithmic} \end{algorithm}
</div>
</div>
<div id="prp-pruning-correct" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2</strong></span> The final <span class="math inline">\(\mathcal{L}\)</span> returned by <a href="#alg-pruning" class="quarto-xref">Algorithm 2</a> is equal to <span class="math inline">\(\mathcal{K}^{\mathfrak{pr}}\)</span>: <span class="math inline">\(\mathcal{L}=\mathcal{K}^{\mathfrak{pr}}\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>First, <span class="math inline">\(\mathcal{K}\setminus\mathcal{L}\subseteq\mathcal{K}\setminus\mathcal{K}^{\mathfrak{pr}}\)</span> is trivial: a <span class="math inline">\(k\)</span> such that <span class="math inline">\(\zeta_{k} \geq  \sum_{k'\in Succ_k} Vec_{k'}\)</span> obviously satisfies the condition of <a href="#def-pruning" class="quarto-xref">Definition&nbsp;1</a> to be pruned.</p>
<p>Now let <span class="math inline">\((i,i')\in \mathcal{K}\setminus\mathcal{K}^{\mathfrak{pr}}\)</span> an element that is pruned by <a href="#def-pruning" class="quarto-xref">Definition&nbsp;1</a>, so there exists <span class="math inline">\(p\geq2\)</span> and integers <span class="math inline">\(i_1,\dotsc,i_{p-1}\)</span> such that, when setting <span class="math inline">\(i_0=i\)</span> and <span class="math inline">\(i_{p}=i'+1\)</span>, the sequence <span class="math inline">\((i_0,\dotsc,i_{p})\)</span> is strictly increasing, <span class="math inline">\((i_{j-1},i_{j}-1)\in\mathcal{K}\)</span> for all <span class="math inline">\(1\leq j\leq p\)</span> and finally <span class="math inline">\(\zeta_{(i,i')}=\zeta_{(i_0,i_{p}-1)}\geq \sum_{j=1}^{p} \zeta_{(i_{j-1}, i_{j}-1)}\)</span>. Then by the proof of Theorem 1 of <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> but applied to <span class="math inline">\(S=R_{(i,i')}\)</span> we have that <span class="math inline">\(\sum_{j=1}^{p} \zeta_{(i_{j-1}, i_{j}-1)}\geq  \sum_{k'\in Succ_{(i,i')}} Vec_{k'}\)</span> (see the unnumbered line just above Equation (A4) in that paper) and so <span class="math inline">\(\zeta_{(i,i')}\geq \sum_{k'\in Succ_{(i,i')}} Vec_{k'}\)</span> hence <span class="math inline">\((i,i')\)</span> is pruned by <a href="#alg-pruning" class="quarto-xref">Algorithm 2</a> and <span class="math inline">\(\mathcal{K}\setminus\mathcal{K}^{\mathfrak{pr}}\subseteq\mathcal{K}\setminus\mathcal{L}\)</span>.</p>
<p>In the end, <span class="math inline">\(\mathcal{K}\setminus\mathcal{K}^{\mathfrak{pr}}=\mathcal{K}\setminus\mathcal{L}\)</span> so <span class="math inline">\(\mathcal{K}^{\mathfrak{pr}}=\mathcal{L}\)</span>. <span class="math inline">\(\square\)</span></p>
</div>
</section>
<section id="sec-fast-curve" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-fast-curve"><span class="header-section-number">3.2</span> Fast algorithm to compute a curve of confidence bounds on a path of selection sets</h2>
<p>Let <span class="math inline">\((i_1,\dotsc, i_m)\)</span> a permutation of <span class="math inline">\(\mathbb{N}_m^*\)</span>, eventually random, and, for all <span class="math inline">\(t\in\mathbb{N}_m^*\)</span>, let <span class="math inline">\(S_t=\{i_1,\dotsc,i_t\}\)</span> and <span class="math inline">\(S_0=\varnothing\)</span>. For example, <span class="math inline">\((i_1,\dotsc, i_m)\)</span> can be the permutation ordering the <span class="math inline">\(p\)</span>-values in increasing order and in that case <span class="math inline">\(S_t\)</span> becomes the set of indices of the <span class="math inline">\(t\)</span> smallest <span class="math inline">\(p\)</span>-values. Assume that we want to compute all <span class="math inline">\(V^*_{\mathfrak{R}}(S_t)\)</span> for all <span class="math inline">\(t\in\{ 0,\dotsc,m\}\)</span>, this is what we call the curve of confidence bounds indexed by <span class="math inline">\((i_1,\dotsc, i_m)\)</span>. Applying <a href="#alg-vstar" class="quarto-xref">Algorithm 1</a> to compute <span class="math inline">\(V^*_{\mathfrak{R}}(S_t)\)</span> for a given <span class="math inline">\(t\)</span> has complexity <span class="math inline">\(O(t|\mathcal{K}|)\)</span>, so using it to sequentially compute the full curve has complexity <span class="math inline">\(O\left(\sum_{t=0}^m t |\mathcal{K}|\right)=O\left(m^2|\mathcal{K}|\right)\)</span>. In this section, we present a new algorithm that computes the curve with a <span class="math inline">\(O\left(m|\mathcal{K}|\right)\)</span> complexity. The algorithm will need that <span class="math inline">\(\mathfrak{R}\)</span> is complete, so if that is not the case we first need to complete <span class="math inline">\(\mathfrak{R}\)</span> following the Algorithm 2 of <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span>, which has a <span class="math inline">\(O(m|\mathcal{K}|)\)</span> complexity. In the remainder of this section we assume that <span class="math inline">\(\mathfrak{R}\)</span> is complete.</p>
<p>We first recall and introduce some notation. Recall that <span class="math inline">\(\phi\)</span> is the depth function inside of <span class="math inline">\(\mathfrak{R}\)</span>, that <span class="math inline">\(\mathfrak P \subseteq \mathcal P(\mathcal{K})\)</span> is the set of subsets of <span class="math inline">\(\mathcal{K}\)</span> that realize a partition, recall the important result stated by Equation <span class="math inline">\(\eqref{eq_vstar_Qpartition}\)</span>, and that <span class="math inline">\(\mathcal{K}^h=\{ k\in\mathcal{K}: \phi(k)=h  \}\)</span> for all <span class="math inline">\(1\leq h\leq H\)</span> where <span class="math inline">\(H=\max_{k\in\mathcal{K}}\phi(k)\)</span>. For any <span class="math inline">\(t\in\mathbb{N}_m^*\)</span> and <span class="math inline">\(1\leq h\leq H\)</span>, we denote by <span class="math inline">\(k^{(t,h)}\)</span> the element of <span class="math inline">\(\mathcal{K}^h\)</span> such that <span class="math inline">\(i_t\in R_{k^{(t,h)}}\)</span> if it exists, and we denote by <span class="math inline">\(h_{\max}(t)\)</span> the highest <span class="math inline">\(h\)</span> such that <span class="math inline">\(k^{(t,h)}\)</span> exists.</p>
<div id="exm-kth" class="theorem example">
<p><span class="theorem-title"><strong>Example 4 (Continuation of <a href="#exm-toy-forest" class="quarto-xref">Example&nbsp;2</a> and <a href="#exm-toy-leaves" class="quarto-xref">Example&nbsp;3</a>)</strong></span> Assume that the reference family of <a href="#exm-toy-forest" class="quarto-xref">Example&nbsp;2</a> has been labeled as in <a href="#exm-toy-leaves" class="quarto-xref">Example&nbsp;3</a> and completed. Let <span class="math inline">\((i_1,\dotsc, i_{25})\)</span> such that <span class="math inline">\(i_1=7\)</span>, <span class="math inline">\(i_2=1\)</span> and <span class="math inline">\(i_3=24\)</span>. Then for <span class="math inline">\(t=1\)</span>, <span class="math inline">\(k^{(t,1)}=(1,5)\)</span>, <span class="math inline">\(k^{(t,2)}=(2,3)\)</span>, <span class="math inline">\(k^{(t,3)}=(3,3)\)</span> and <span class="math inline">\(h_{\max}(t)=H=3\)</span>. For <span class="math inline">\(t=2\)</span>, <span class="math inline">\(k^{(t,1)}=(1,5)\)</span>, <span class="math inline">\(k^{(t,2)}=(1,1)\)</span>, <span class="math inline">\(k^{(t,3)}\)</span> does not exist and <span class="math inline">\(h_{\max}(t)=2\)</span>. For <span class="math inline">\(t=3\)</span>, <span class="math inline">\(k^{(t,1)}=(8,8)\)</span>, <span class="math inline">\(k^{(t,2)}\)</span> does not exist and <span class="math inline">\(h_{\max}(t)=1\)</span>.</p>
</div>
<p>Now we can finally present the new algorithm and the proof that it computes the curve <span class="math inline">\((V^*_{\mathfrak{R}}(S_t))_{t\in\mathbb{N}_m}\)</span>. We present two versions of the algorithm (strictly equivalent): one very formal (<a href="#alg-formal-curve" class="quarto-xref">Algorithm 3</a>), to introduce additional notation used in the proof, and, later, one that is more akin to <a href="#alg-vstar" class="quarto-xref">Algorithm 1</a> and <a href="#alg-pruning" class="quarto-xref">Algorithm 2</a>, that is, it reuses notation from step to step, for implementation and simplicity purposes (<a href="#alg-curve" class="quarto-xref">Algorithm 4</a>).</p>
<div id="alg-formal-curve" class="pseudocode-container quarto-float" data-comment-delimiter="//" data-indent-size="1.2em" data-pseudocode-number="3" data-line-number-punc=":" data-line-number="true" data-caption-prefix="Algorithm" data-no-end="false">
<div class="pseudocode">
\begin{algorithm} \caption{Formal computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$} \begin{algorithmic} \Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$ with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$} \State $\mathcal{P}^0\gets\{(i,i): 1\leq i \leq n\}$ \Comment{the set of all atoms indices} \State $\mathcal{K}^-_0\gets\{k\in\mathcal{K} : \zeta_k=0 \}$ \State $\eta^0_k\gets0$ for all $k\in\mathcal{K}$ \For{$t=1,\dotsc, m$} \If{$i_t\in\bigcup_{k\in\mathcal{K}^-_{t-1}}R_k$} \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$ \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$ \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ \Else \For{$h=1,\dotsc,h_{\max}(t)$} \State $\eta^t_{k^{(t,h)}}\gets\eta^{t-1}_{k^{(t,h)}} + 1$ \If{$\eta^t_{k^{(t,h)}}&lt;\zeta_k$} \State Pass \Else \State $h^f_t \gets h$ \Comment{final depth} \State $\mathcal{P}^t \gets\left( \mathcal{P}^{t-1}\setminus \{ k\in \mathcal{P}^{t-1} : R_k\subseteq R_{k^{(t,h^f_t)}} \}\right)\cup \{ k^{(t,h^f_t)} \}$ \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1} \cup \{k^{(t,h^f_t)}\}$ \State Break the loop \EndIf \EndFor \If{the loop has been broken} \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h^f_t \}$ \Else \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$ \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$ \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h_{\max}(t) \}$ \EndIf \EndIf \EndFor \Return $\mathcal{P}^t, \eta^t_k$ for all $t=1,\dotsc, m$ and $k\in\mathcal{K}$ \EndProcedure \end{algorithmic} \end{algorithm}
</div>
</div>
<p>The core idea of the algorithm is that, as we increase <span class="math inline">\(t\)</span> and add new hypotheses in <span class="math inline">\(S_t\)</span>, we inflate a counter <span class="math inline">\(\eta_k^t\)</span> for each region <span class="math inline">\(R_k\)</span>, by one if <span class="math inline">\(i_t\in R_k\)</span> (line 12), by 0 if not (lines 23 and 27), but only until the counter reaches <span class="math inline">\(\zeta_k\)</span> (line 13). After this point, the hypotheses in <span class="math inline">\(R_k\)</span> don’t contribute to <span class="math inline">\(V^*_{\mathfrak{R}}(S_t)\)</span>, we keep track of those hypotheses with <span class="math inline">\(\mathcal{K}^-_t\)</span> (line 6), so as soon as <span class="math inline">\(\eta^t_{k^{(t,h)}}=\zeta_k\)</span> we update <span class="math inline">\(\mathcal{K}^-_t\)</span> by adding <span class="math inline">\(k^{(t,h)}\)</span> (line 18) to it and we update <span class="math inline">\(\mathcal{P}^t\)</span> accordingly (line 17). We will see that <span class="math inline">\(V^*_{\mathfrak{R}}(S_t)\)</span> is the sum of the <span class="math inline">\(\eta_k^t\)</span> counters for <span class="math inline">\(k\in\mathcal{K}^1\)</span>. Furthermore, the algorithm provides the partition <span class="math inline">\(\mathcal{P}^t\in\mathfrak P\)</span> where the minimum in <span class="math inline">\(\eqref{eq_vstar_Qpartition}\)</span> is realized. We formalize all of that in the following Theorem. We first need a final notation. Let <span class="math display">\[\begin{equation*}
\mathcal{K}_t=\{k\in\mathcal{K}: \exists k'\in \mathcal{P}^t : R_{k'}\subseteq R_k   \}.
\end{equation*}\]</span> The elements of <span class="math inline">\(\mathcal{K}_t\)</span> index the regions of the forest that ``are above’’ the regions of the current partition-realizing <span class="math inline">\(\mathcal{P}^t\)</span>. In particular, we always have, for any <span class="math inline">\(t\in\mathbb{N}_m\)</span>, <span class="math inline">\(\mathcal{K}^1\subseteq\mathcal{K}_t\)</span> and <span class="math inline">\(\mathcal{P}^t\subseteq \mathcal{K}_t\)</span>. We can also remark that the sequence <span class="math inline">\((\mathcal{K}_t)_{0\leq t \leq m}\)</span> is non-increasing for the inclusion relation, and that <span class="math inline">\(\mathcal{K}_0=\mathcal{K}\)</span>.</p>
<div id="thm-curve-path" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (Fast curve computation)</strong></span> Let any <span class="math inline">\(t\in\mathbb{N}_m\)</span>. Then, <span class="math inline">\(\mathcal{P}^t\in\mathfrak P\)</span>, and for all <span class="math inline">\(k\in\mathcal{K}_t\)</span>, we have <span class="math display">\[\begin{equation}
V^*_{\mathfrak{R}}(S_t\cap R_k) = \eta_k^t
\label{eq_vstar_inter_Rk_equal_eta}
\end{equation}\]</span> and <span class="math display">\[\begin{equation}
V^*_{\mathfrak{R}}(S_t\cap R_k) = \sum_{\substack{k'\in \mathcal{P}^t\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge|S_t \cap R_{k'}|.
\label{eq_Pt_good_partition}
\end{equation}\]</span> Furthermore, <span class="math display">\[\begin{equation}
V^*_{\mathfrak{R}}(S_t)  = \sum_{{k\in \mathcal{P}^t}} \zeta_{k}\wedge|S_t \cap R_{k}|= \sum_{k\in\mathcal{K}^1} \eta_k^t.
\label{eq_vstar_equal_sum_eta}
\end{equation}\]</span></p>
</div>
<p>The first equality of Equation <span class="math inline">\(\eqref{eq_vstar_equal_sum_eta}\)</span> confirms that the minimum in <span class="math inline">\(\eqref{eq_vstar_Qpartition}\)</span> is indeed realized on <span class="math inline">\(\mathcal{P}^t\)</span>, and the last equality of the same Equation justifies the simpler <a href="#alg-curve" class="quarto-xref">Algorithm 4</a> to compute the curve on the nested path of selection sets (the <span class="math inline">\(V_t\)</span> notation of <a href="#alg-curve" class="quarto-xref">Algorithm 4</a> is exactly the <span class="math inline">\(\sum_{k\in\mathcal{K}^1} \eta_k^t\)</span> of <a href="#alg-formal-curve" class="quarto-xref">Algorithm 3</a>).</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span><span class="math inline">\(\bullet\)</span> Derivation of <span class="math inline">\(\eqref{eq_vstar_equal_sum_eta}\)</span>.</p>
<p>We first derive <span class="math inline">\(\eqref{eq_vstar_equal_sum_eta}\)</span> from <span class="math inline">\(\eqref{eq_vstar_inter_Rk_equal_eta}\)</span> and <span class="math inline">\(\eqref{eq_Pt_good_partition}\)</span>. First note that for all <span class="math inline">\(Q\in\mathfrak P\)</span>, <span class="math display">\[\begin{equation}
Q=\bigcup_{k\in\mathcal{K}^1}\{ k' \in Q : R_{k'}\subseteq R_k\}
\label{eq_part_K1}
\end{equation}\]</span> and the union is disjoint. From <span class="math inline">\(\eqref{eq_vstar_Qpartition}\)</span>, let <span class="math inline">\(Q^*\in\mathfrak P\)</span> such that <span class="math inline">\(V^*_{\mathfrak{R}}(S_t) = \sum_{k'\in Q^*} \zeta_{k'}\wedge |S_t\cap R_{k'}|\)</span>. Then by <span class="math inline">\(\eqref{eq_part_K1}\)</span>, <span class="math display">\[\begin{align}
V^*_{\mathfrak{R}}(S_t) &amp;= \sum_{k'\in Q^*} \zeta_{k'}\wedge |S_t\cap R_{k'}|\notag\\
&amp;=\sum_{k\in\mathcal{K}^1}  \sum_{\substack{k'\in Q^*\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_t\cap R_{k'}|\notag \\
&amp;=\sum_{k\in\mathcal{K}^1}  \sum_{\substack{k'\in Q^*\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_t\cap (R_{k}\cap R_{k'})| \notag\\
&amp;=\sum_{k\in\mathcal{K}^1}  \sum_{k'\in Q^*} \zeta_{k'}\wedge |(S_t\cap R_{k})\cap R_{k'}| \label{eq_delicate} \\
&amp;\geq \sum_{k\in\mathcal{K}^1} V^*_{\mathfrak{R}}(S_t\cap R_k),\label{eq_delicate_vstar}
\end{align}\]</span> where the equality in <span class="math inline">\(\eqref{eq_delicate}\)</span> comes from the fact that if <span class="math inline">\(R_{k'}\not\subseteq R_k\)</span>, then <span class="math inline">\(R_{k'}\cap R_k=\varnothing\)</span>, that is, <span class="math inline">\(R_{k}\subseteq R_{k'}\)</span> is impossible because <span class="math inline">\(k\in\mathcal K^1\)</span>. Furthermore, <span class="math inline">\(\eqref{eq_delicate_vstar}\)</span> holds again by <span class="math inline">\(\eqref{eq_vstar_Qpartition}\)</span>.</p>
<p>Because <span class="math inline">\(\mathcal{K}^1\subseteq\mathcal{K}_t\)</span>, by <span class="math inline">\(\eqref{eq_Pt_good_partition}\)</span>, <span class="math inline">\(V^*_{\mathfrak{R}}(S_t\cap R_k) = \sum_{\substack{k'\in \mathcal{P}^t\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge|S_t \cap R_{k'}|\)</span> for all <span class="math inline">\(k\in\mathcal{K}^1\)</span>. Then, <span class="math display">\[\begin{align*}
\sum_{k\in\mathcal{K}^1} V^*_{\mathfrak{R}}(S_t\cap R_k)&amp;=  \sum_{k\in\mathcal{K}^1}\sum_{\substack{k'\in \mathcal{P}^t\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge|S_t \cap R_{k'}|\\
&amp;=\sum_{k\in\mathcal{P}^t} \zeta_{k}\wedge |S_t\cap R_{k}| \text{ by \eqref{eq_part_K1}}\\
&amp;\geq V^*_{\mathfrak{R}}(S_t) \text{ by \eqref{eq_vstar_Qpartition}}.\\
\end{align*}\]</span> So we proved that <span class="math inline">\(V^*_{\mathfrak{R}}(S_t)= \sum_{k\in\mathcal{P}^t} \zeta_{k}\wedge |S_t\cap R_{k}|= \sum_{k\in\mathcal{K}^1} V^*_{\mathfrak{R}}(S_t\cap R_k)\)</span> and finally <span class="math inline">\(V^*_{\mathfrak{R}}(S_t)=\sum_{k\in\mathcal{K}^1} V^*_{\mathfrak{R}}(S_t\cap R_k)= \sum_{k\in\mathcal{K}^1}  \eta_k^t\)</span> by <span class="math inline">\(\eqref{eq_vstar_inter_Rk_equal_eta}\)</span>, again because <span class="math inline">\(\mathcal{K}^1\subseteq\mathcal{K}_t\)</span>. Every equality in <span class="math inline">\(\eqref{eq_vstar_equal_sum_eta}\)</span> is proven.</p>
<p><span class="math inline">\(\bullet\)</span> Proof of <span class="math inline">\(\eqref{eq_vstar_inter_Rk_equal_eta}\)</span> and <span class="math inline">\(\eqref{eq_Pt_good_partition}\)</span>.</p>
<p>We show the remainder of the statements by a strong recursion over <span class="math inline">\(t\)</span>. We have <span class="math inline">\(\mathcal{P}^0\in\mathfrak P\)</span> by definition, and given that <span class="math inline">\(S_0=\varnothing\)</span> and <span class="math inline">\(\eta^0_k=0\)</span> for all <span class="math inline">\(k\in\mathcal{K}\)</span> (recall that <span class="math inline">\(\mathcal{K}_0=\mathcal{K}\)</span>), everything is equal to 0 in <span class="math inline">\(\eqref{eq_vstar_inter_Rk_equal_eta}\)</span> and <span class="math inline">\(\eqref{eq_Pt_good_partition}\)</span>.</p>
<p>So we let <span class="math inline">\(t\in\{ 0,\dotsc,m-1\}\)</span>, and assume that <span class="math inline">\(\mathcal{P}^{t'}\in\mathfrak P\)</span> and that <span class="math inline">\(\eqref{eq_vstar_inter_Rk_equal_eta}\)</span> and <span class="math inline">\(\eqref{eq_Pt_good_partition}\)</span> hold for all <span class="math inline">\(t'\leq t\)</span>. In all the following, <span class="math inline">\(\bar k\)</span> is the element of <span class="math inline">\(\mathcal{P}^t\)</span> such that <span class="math inline">\(i_{t+1}\in R_{\bar k}\)</span>. We will distinguish two cases: if <span class="math inline">\(i_{t+1}\in\bigcup_{k\in\mathcal{K}^-_{t}}R_k\)</span> or not. First we show an inequality that will be used in both cases. We have, for all <span class="math inline">\(k\in\mathcal{K}_t\)</span>, <span class="math display">\[\begin{align}
V^*_{\mathfrak{R}}(S_{t+1}\cap R_k)&amp;\leq \sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|.\label{eq_ineq_both_cases}
\end{align}\]</span> Indeed, by <span class="math inline">\(\eqref{eq_vstar_Qpartition}\)</span>, <span class="math display">\[\begin{align*}
V^*_{\mathfrak{R}}(S_{t+1}\cap R_k)&amp;\leq  \sum_{k'\in\mathcal{P}^{t}} \zeta_{k'}\wedge |S_{t+1}\cap R_k \cap R_{k'}|.
\end{align*}\]</span> For any <span class="math inline">\(k'\in\mathcal{P}^{t}\)</span>, we have either <span class="math inline">\(R_{k'}\cap R_k=\varnothing\)</span>, in which case <span class="math inline">\(|S_{t+1}\cap R_k \cap R_{k'}|=0\)</span>, either <span class="math inline">\(R_{k'}\subseteq R_k\)</span>, in which case <span class="math inline">\(|S_{t+1}\cap R_k \cap R_{k'}|=|S_{t+1} \cap R_{k'}|\)</span>, but <span class="math inline">\(R_{k}\subsetneq R_{k'}\)</span> is impossible. Indeed, by definition of <span class="math inline">\(\mathcal{K}_t\)</span>, there exists <span class="math inline">\(\tilde k\in \mathcal{P}^t\)</span> such that <span class="math inline">\(R_{\tilde k}\subseteq R_k\)</span>, so <span class="math inline">\(R_{k}\subsetneq R_{k'}\)</span> would entail <span class="math inline">\(R_{\tilde k}\subsetneq R_{k'}\)</span> which is impossible since <span class="math inline">\(k', \tilde k\in \mathcal{P}^t\in\mathfrak P\)</span> and so <span class="math inline">\(R_{\tilde k}\)</span> and <span class="math inline">\(R_{k'}\)</span> are part of a partition of <span class="math inline">\(\mathbb{N}_m^*\)</span>. This gives <span class="math inline">\(\eqref{eq_ineq_both_cases}\)</span>.</p>
<p><span class="math inline">\(\bullet\bullet\)</span> First case: <span class="math inline">\(i_{t+1}\in\bigcup_{k\in\mathcal{K}^-_{t}}R_k\)</span>.</p>
<p>In this case, <span class="math inline">\(\mathcal{P}^{t+1}=\mathcal{P}^t\in\mathfrak P\)</span> and <span class="math inline">\(\mathcal{K}_{t+1}=\mathcal{K}_t\)</span>. For any <span class="math inline">\(k\in\mathcal{K}_{t+1}\)</span> such that <span class="math inline">\(i_{t+1}\not\in R_k\)</span> (or, equivalently, such that <span class="math inline">\(S_{t+1}\cap R_k=S_t\cap R_k\)</span>), <span class="math display">\[\begin{align*}
\sum_{\substack{k'\in\mathcal{P}^{t+1} \\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|&amp;=\sum_{\substack{k'\in\mathcal{P}^{t} \\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| \\
&amp;=V^*_{\mathfrak{R}}(S_t\cap R_k) \text{ by~\eqref{eq_Pt_good_partition}}\\
&amp;=\eta_k^t \text{ by~\eqref{eq_vstar_inter_Rk_equal_eta}}\\
&amp;=\eta_k^{t+1}
\end{align*}\]</span> because <span class="math inline">\(\eta_k^t=\eta_k^{t+1}\)</span> for all <span class="math inline">\(k\in\mathcal{K}\)</span>. Furthermore <span class="math inline">\(S_{t+1}\cap R_k=S_t\cap R_k\)</span> so <span class="math inline">\(V^*_{\mathfrak{R}}(S_{t+1}\cap R_k)=V^*_{\mathfrak{R}}(S_t\cap R_k)\)</span>. So everything is proved for such a <span class="math inline">\(k\)</span>.</p>
<p>Now we let <span class="math inline">\(k\in\mathcal{K}_{t+1}\)</span> such that <span class="math inline">\(i_{t+1}\in R_k\)</span> or, equivalently, such that <span class="math inline">\(R_{\bar k}\subseteq R_k\)</span>. We first need to show that <span class="math inline">\(\zeta_{\bar k}\leq |S_t\cap R_{\bar k}|\)</span>, and for that we need to distinguish two subcases: if <span class="math inline">\(\bar k\)</span> has been added to <span class="math inline">\(\mathcal{P}^t\)</span> during a previous step of the algorithm, of if not.</p>
<p><span class="math inline">\(\bullet\bullet\bullet\)</span> First subcase: <span class="math inline">\(\bar k\)</span> has never been added during the process of line 17.</p>
<p>Then <span class="math inline">\(\bar k\in\mathcal{P}^0\)</span> and <span class="math inline">\(R_{\bar k}\)</span> is an atom, so <span class="math inline">\(i_{t+1}\in\bigcup_{k'\in\mathcal{K}^-_{t}}R_{k'}\)</span> implies that <span class="math inline">\(R_{\bar k}\subseteq \bigcup_{k'\in\mathcal{K}^-_{t}}R_{k'}\)</span> (because of the forest structure). Let <span class="math inline">\(k'_{\max}\)</span> such that <span class="math display">\[\begin{equation*}
R_{k'_{\max}}=\max\{ R_{k'}\,:\,k'\in\mathcal{K}^-_t, R_{\bar k}\subseteq R_{k'}  \}
\end{equation*}\]</span> (this a maximum for the inclusion relation, and it is well defined thanks to the forest structure). By reductio ad absurdum we show that <span class="math inline">\(k'_{\max}=\bar k\)</span>. If that wasn’t the case, by the joint construction of <span class="math inline">\(\mathcal{P}^t\)</span> and <span class="math inline">\(\mathcal{K}^-_t\)</span> during the algorithm we would have <span class="math inline">\(k'_{\max}\in\mathcal{P}^t\)</span> and a contradiction with the fact that <span class="math inline">\(\mathcal{P}^t\in\mathfrak P\)</span>: we can’t have both <span class="math inline">\(\bar k\in\mathcal{P}^t\)</span> and <span class="math inline">\(k'_{\max}\in\mathcal{P}^t\)</span> if they are distinct. So <span class="math inline">\(k'_{\max}=\bar k\)</span>, so <span class="math inline">\(\bar k\in  \mathcal{K}^-_t\)</span>, but it cannot have been added to <span class="math inline">\(\mathcal{K}^-_t\)</span> during a previous step of the algorithm, otherwise it would have been added to <span class="math inline">\(\mathcal{P}^t\)</span>, too. Hence <span class="math inline">\(\bar k\in \mathcal{K}^-_0\)</span> which means that <span class="math inline">\(\zeta_{\bar k}=0\)</span> and <span class="math inline">\(\zeta_{\bar k}=0\leq |S_t\cap R_{\bar k}|\)</span>.</p>
<p><span class="math inline">\(\bullet\bullet\bullet\)</span> Second subcase: <span class="math inline">\(\bar k\)</span> has been added to <span class="math inline">\(\mathcal{P}^t\)</span> at a previous step.</p>
<p>Let <span class="math inline">\(t'\leq t\)</span> be this step. This means that <span class="math inline">\(\bar k = k^{(t',h^f_{t'})}\)</span> and that at that step <span class="math inline">\(\eta^{t'}_{\bar k}=\zeta_{\bar k}\)</span>. Indeed, the if condition in line 13 failed so <span class="math inline">\(\eta^{t'}_{\bar k}\geq\zeta_{\bar k}\)</span>, but for all <span class="math inline">\(t''&lt;t'\)</span> we had <span class="math inline">\(\eta^{t''}_{\bar k}\leq\zeta_{\bar k}\)</span> which implies equality. Also <span class="math inline">\(\bar k\in \mathcal{P}^{t'}\)</span> so <span class="math inline">\(\bar k\in \mathcal{K}_{t'}\)</span> so we can write <span class="math display">\[\begin{align*}
\zeta_{\bar k}&amp;=\eta^{t'}_{\bar k}\\
&amp;=V^*_{\mathfrak{R}}(S_{t'}\cap R_{\bar k})  \text{ by~\eqref{eq_vstar_inter_Rk_equal_eta}} \\
&amp;\leq | S_{t'}\cap R_{\bar k} |\\
&amp;\leq  | S_{t}\cap R_{\bar k} |.\\
\end{align*}\]</span></p>
<p>This concludes the two subcases dichotomy: <span class="math inline">\(\zeta_{\bar k}\leq |S_t\cap R_{\bar k}|\)</span> and we can go back to our <span class="math inline">\(k\in\mathcal{K}_{t+1}\)</span> such that <span class="math inline">\(i_{t+1}\in R_k\)</span> and <span class="math inline">\(R_{\bar k}\subseteq R_k\)</span>.</p>
<p>We write the following chain: <span class="math display">\[\begin{align*}
V^*_{\mathfrak{R}}(S_{t+1}\cap R_k)&amp;\leq \sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|\text{ by~\eqref{eq_ineq_both_cases} and }\mathcal{K}_{t+1}\subseteq\mathcal{K}_t\\
&amp;=\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| + \zeta_{\bar k}\wedge |S_{t+1}\cap R_{\bar k}| \\
&amp;=\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge( |S_{t}\cap R_{\bar k}| +1)\\
&amp;=\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge|S_{t}\cap R_{\bar k}|\text{ because $\zeta_{\bar k}\leq |S_t\cap R_{\bar k}|$}\\
&amp;=\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| \\
&amp;=V^*_{\mathfrak{R}}(S_t\cap R_k)  \text{ by~\eqref{eq_Pt_good_partition}} \\
&amp;= \eta_k^t  \text{ by~\eqref{eq_vstar_inter_Rk_equal_eta}} \\
&amp;= \eta_k^{t+1}.\\
\end{align*}\]</span> But on the other hand, <span class="math inline">\(S_t\subseteq S_{t+1}\)</span> and so <span class="math inline">\(\eqref{eq_vstar_Qpartition}\)</span> also gives <span class="math inline">\(V^*_{\mathfrak{R}}(S_t\cap R_k) \leq V^*_{\mathfrak{R}}(S_{t+1}\cap R_k)\)</span> and so in the end we have the desired outcome: <span class="math display">\[\begin{equation*}
V^*_{\mathfrak{R}}(S_{t+1}\cap R_k) =  \eta_k^{t+1} =  \sum_{\substack{k'\in\mathcal{P}^{t+1}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| ,
\end{equation*}\]</span> which concludes this first case.</p>
<p><span class="math inline">\(\bullet\bullet\)</span> Second case: <span class="math inline">\(i_{t+1}\not\in\bigcup_{k\in\mathcal{K}^-_{t}}R_k\)</span>.</p>
<p>We first prove that <span class="math inline">\(\mathcal{P}^{t+1}\in\mathfrak P\)</span> whether it came form the adjustment in line 17 or not. If it didn’t, it stayed equal to <span class="math inline">\(\mathcal{P}^t\in\mathfrak P\)</span>. If it did, we have <span class="math display">\[\begin{equation}\label{eq_rel_rec_p}
\mathcal{P}^{t+1}=\left(\mathcal{P}^t \setminus\{k\in\mathcal{P}^t, R_k\subseteq R_{  k^{(t+1,h^f_{t+1})}   }   \}  \right)\cup \{ k^{(t+1,h^f_{t+1})} \}.
\end{equation}\]</span> To prove that <span class="math inline">\(\mathcal{P}^{t+1}\in\mathfrak P\)</span> in that case, it suffices to prove there are no <span class="math inline">\(k'\in\mathcal{P}^t\)</span> such that <span class="math inline">\(R_{  k^{(t+1,h^f_{t+1})}} \subsetneq  R_{k'}\)</span>. If it was the case, because of the strict inclusion, we would have <span class="math inline">\(k'\not\in\mathcal{P}^0\)</span>, so <span class="math inline">\(k'\)</span> would have been added to <span class="math inline">\(\mathcal{P}^{t'}\)</span> at a previous step <span class="math inline">\(t'\leq t\)</span> of the algorithm, but in that case it would also have been added to <span class="math inline">\(\mathcal{K}_{t'}^-\subseteq \mathcal{K}_{t}^-\)</span>. So in the end we would have <span class="math display">\[\begin{equation*}
i_{t+1}\in R_{  k^{(t+1,h^f_{t+1})}} \subsetneq R_{k'} \subseteq \bigcup_{k\in\mathcal{K}^-_{t}}R_k
\end{equation*}\]</span> which is a contradiction and so <span class="math inline">\(\mathcal{P}^{t+1}\in\mathfrak P\)</span>.</p>
<p>Like in the first case, considering a <span class="math inline">\(k\in\mathcal{K}_{t+1}\subseteq \mathcal{K}_t\)</span> such that <span class="math inline">\(i_{t+1}\not\in R_k\)</span> is not problematic, because in that case <span class="math inline">\(k\)</span> is not visited at all by the algorithm at step <span class="math inline">\(t+1\)</span> : <span class="math inline">\(\eta^{t+1}_k=\eta^{t}_k\)</span>, <span class="math inline">\(\{k'\in\mathcal{P}^{t+1}\,:\,R_{k'}\subseteq R_k\}=\{k'\in\mathcal{P}^{t}\,:\,R_{k'}\subseteq R_k\}\)</span>, and for all <span class="math inline">\(k'\in \mathcal{K}\)</span> such that <span class="math inline">\(R_{k'}\subseteq R_k\)</span>, <span class="math inline">\(S_{t+1}\cap R_{k'}=S_{t}\cap R_{k'}\)</span>. Hence, from <span class="math display">\[\begin{equation*}
V^*_{\mathfrak{R}}(S_{t}\cap R_k) =  \eta_k^{t} =  \sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| ,
\end{equation*}\]</span> we directly have <span class="math display">\[\begin{equation*}
V^*_{\mathfrak{R}}(S_{t+1}\cap R_k) =  \eta_k^{t+1} =  \sum_{\substack{k'\in\mathcal{P}^{t+1}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| .
\end{equation*}\]</span></p>
<p>So we now focus on the <span class="math inline">\(k\in\mathcal{K}_{t+1}\)</span> such that <span class="math inline">\(i_{t+1}\in R_k\)</span>. Note that for such <span class="math inline">\(k\)</span>, <span class="math display">\[\begin{equation*}
\eta^{t+1}_k=\eta^t_k+1=V^*_{\mathfrak{R}}(S_t\cap R_k)+1=\sum_{\substack{k'\in \mathcal{P}^t\\ R_{k'}\subseteq R_k}}\zeta_{k'}\wedge|S_t\cap R_{k'}|+1
\end{equation*}\]</span> by construction, by <span class="math inline">\(\eqref{eq_vstar_inter_Rk_equal_eta}\)</span> and by <span class="math inline">\(\eqref{eq_Pt_good_partition}\)</span>. Indeed, such a <span class="math inline">\(k\)</span> is equal to a <span class="math inline">\(k^{(t+1,h)}\)</span> with <span class="math inline">\(h\leq h_{max}(t+1)\)</span>, and even <span class="math inline">\(h\leq h^f_{t+1}\)</span> if the latter exists.</p>
<p>Also, similarly to the first case, for all <span class="math inline">\(k\in\mathcal{K}_{t+1}\)</span> such that <span class="math inline">\(i_{t+1}\in R_k\)</span> (recall that this is equivalent to <span class="math inline">\(R_{\bar k}\subseteq R_k\)</span>), we can write: <span class="math display">\[\begin{align}
V^*_{\mathfrak{R}}(S_{t+1}\cap R_k)&amp;\leq \sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| \text{ by \eqref{eq_ineq_both_cases} and }\mathcal{K}_{t+1}\subseteq\mathcal{K}_t\notag\\
&amp;=\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| + \zeta_{\bar k}\wedge |S_{t+1}\cap R_{\bar k}| \notag\\
&amp;=\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge( |S_{t}\cap R_{\bar k}| +1)\notag\\
&amp;\leq \sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k\\ k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge|S_{t}\cap R_{\bar k}| +1\notag\\
&amp;=\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}|  + 1\notag\\
&amp;=V^*_{\mathfrak{R}}(S_t\cap R_k) +1  \text{ by \eqref{eq_Pt_good_partition}}.\label{eq_ineq_}
\end{align}\]</span></p>
<p>Note that by the joint construction of <span class="math inline">\(\mathcal{K}^-_t\)</span> and <span class="math inline">\(\mathcal{P}^t\)</span> on lines 17 and 18, the fact that <span class="math inline">\(i_{t+1}\not\in\bigcup_{k\in\mathcal{K}^-_{t}}R_k\)</span> implies that <span class="math inline">\(\bar k\)</span> is the index of an atom, so actually <span class="math inline">\(h_{\max}(t+1)=\phi(\bar k)\)</span>, <span class="math inline">\(\bar k = k^{(t+1,\phi(\bar k))}\)</span> and the <span class="math inline">\(R_k\)</span>, <span class="math inline">\(k\in\mathcal{K}_{t}\)</span>, such that <span class="math inline">\(R_{\bar k}\subseteq R_k\)</span> are nested and are exactly indexed by the <span class="math inline">\(k^{(t+1,h)}\)</span>, <span class="math inline">\(1\leq h\leq \phi(\bar k)\)</span>. We now prove that for all of them, <span class="math inline">\(V^*_{\mathfrak{R}}(S_{t+1}\cap R_k)\geq V^*_{\mathfrak{R}}(S_{t}\cap R_k)+1\)</span>, which will be true in particular for the ones that are in <span class="math inline">\(\mathcal{K}_{t+1}\)</span>, given that <span class="math inline">\(\mathcal{K}_{t+1}\subseteq \mathcal{K}_t\)</span>. We do that by constructing some sets <span class="math inline">\(A_h\)</span> with good properties with a descending recursion on <span class="math inline">\(h\)</span>, starting from <span class="math inline">\(\phi(\bar k)\)</span>. We only give the first two steps of the construction, because every other step is exactly the same as the second one, which contains the recursive arguments. We go back to the real definition of <span class="math inline">\(V^*_{\mathfrak{R}}\)</span> to do so, for any <span class="math inline">\(S\subseteq \mathbb{N}_m\)</span>: <span class="math display">\[\begin{equation}
\label{eq_Vstar_au_max} V^*_{\mathfrak{R}}(S)=\max_{\substack{A\subseteq \mathbb{N}_m\\\forall k'\in\mathcal{K}, |A\cap R_{k'}|\leq \zeta_{k'}}} |A\cap S| =\max_{\substack{A\subseteq S\\\forall k'\in\mathcal{K}, |A\cap R_{k'}|\leq \zeta_{k'}}} |A|  .
\end{equation}\]</span></p>
<p>By <span class="math inline">\(\eqref{eq_Vstar_au_max}\)</span>, we have that <span class="math inline">\(V^*_{\mathfrak{R}}(S_t \cap R_{k^{(t+1,\phi(\bar k))}})=|A_{\phi(\bar k)}|\)</span> for a given <span class="math inline">\(A_{\phi(\bar k)}\subseteq S_t \cap R_{k^{(t+1,\phi(\bar k))}}\)</span> and such that <span class="math inline">\(|A_{\phi(\bar k)}\cap R_{k'}|\leq \zeta_{k'}\)</span> for all <span class="math inline">\(k'\in\mathcal{K}\)</span>. Now for the second set, we construct <span class="math inline">\(A_{\phi(\bar k)-1}\)</span>. Note that <span class="math inline">\(V^*_{\mathfrak{R}}(S_t \cap R_{k^{(t+1,\phi(\bar k)-1)}})=|B|\)</span> for some <span class="math inline">\(B\subseteq S_t \cap R_{k^{(t+1,\phi(\bar k)-1)}}\)</span> and such that <span class="math inline">\(|B\cap R_{k'}|\leq \zeta_{k'}\)</span> for all <span class="math inline">\(k'\in\mathcal{K}\)</span>. By reductio ad absurdum, if there are strictly less than <span class="math inline">\(V^*_{\mathfrak{R}}(S_t \cap R_{k^{(t+1,\phi(\bar k)-1)}}) - V^*_{\mathfrak{R}}(S_t \cap R_{k^{(t+1,\phi(\bar k))}})=|B|-|A_{\phi(\bar k)}|\)</span> elements in <span class="math inline">\(S_t\cap R_{k^{(t+1,\phi(\bar k)-1)}} \setminus S_t\cap R_{k^{(t+1,\phi(\bar k))}}\)</span>, then <span class="math inline">\(|B|+|S_t \cap R_{k^{(t+1,\phi(\bar k))}}|-|S_t \cap R_{k^{(t+1,\phi(\bar k)-1)}}|&gt;|A_{\phi(\bar k)}|=V^*_{\mathfrak{R}}(S_t \cap R_{k^{(t+1,\phi(\bar k))}})\)</span>. Given that <span class="math inline">\(B\cup (S_t\cap R_{k^{(t+1,\phi(\bar k))}})\subseteq S_t \cap R_{k^{(t+1,\phi(\bar k)-1)}}\)</span>, this entails <span class="math inline">\(|B\cap S_t\cap R_{k^{(t+1,\phi(\bar k))}}| =|B|+|S_t \cap R_{k^{(t+1,\phi(\bar k))}}| -| B\cup (S_t\cap R_{k^{(t+1,\phi(\bar k))}})| &gt; V^*_{\mathfrak{R}}(S_t \cap R_{k^{(t+1,\phi(\bar k))}})\)</span> which contradicts the maximality of <span class="math inline">\(A_{\phi(\bar k)}\)</span> in <span class="math inline">\(\eqref{eq_Vstar_au_max}\)</span>.</p>
<p>So we construct <span class="math inline">\(A_{\phi(\bar k)-1}\)</span> by taking the disjoint union of <span class="math inline">\(A_{\phi(\bar k)}\)</span> and <span class="math inline">\(V^*_{\mathfrak{R}}(S_t \cap R_{k^{(t+1,\phi(\bar k)-1)}}) - V^*_{\mathfrak{R}}(S_t \cap R_{k^{(t+1,\phi(\bar k))}})\)</span> elements of <span class="math inline">\(S_t\cap R_{k^{(t+1,\phi(\bar k)-1)}} \setminus S_t\cap R_{k^{(t+1,\phi(\bar k))}}\)</span>. We now establish the properties of <span class="math inline">\(A_{\phi(\bar k)-1}\)</span>. First, <span class="math inline">\(A_{\phi(\bar k)-1}\subseteq S_t \cap R_{k^{(t+1,\phi(\bar k)-1)}}\)</span>, and <span class="math inline">\(|A_{\phi(\bar k)-1}|=V^*_{\mathfrak{R}}(S_t \cap R_{k^{(t+1,\phi(\bar k)-1)}})\)</span>. For all <span class="math inline">\(k'\in\mathcal{K}\)</span> such that <span class="math inline">\(R_{k^{(t+1,\phi(\bar k)-1)}} \cap R_{k'}=\varnothing\)</span>, we have <span class="math inline">\(|A_{\phi(\bar k)-1}\cap R_{k'}|=0\leq \zeta_k'\)</span>. Furthermore, <span class="math display">\[\begin{align*}
|A_{\phi(\bar k)-1}\cap R_{   k^{(t+1,\phi(\bar k))}   }|&amp;=|A_{\phi(\bar k)}\cap R_{   k^{(t+1,\phi(\bar k))}   }|\\
&amp;\leq \zeta_{ k^{(t+1,\phi(\bar k))} }
\end{align*}\]</span> by construction of <span class="math inline">\(A_{\phi(\bar k)}\)</span>. Finally, for all <span class="math inline">\(k'\)</span> such that <span class="math inline">\(R_{k^{(t+1,\phi(\bar k)-1)}}\subseteq R_{k'}\)</span>, <span class="math inline">\(|A_{\phi(\bar k)-1}\cap R_{k'}|=|A_{\phi(\bar k)-1}|=V^*_{\mathfrak{R}}(S_t \cap R_{k^{(t+1,\phi(\bar k)-1)}})=|B|\)</span> with the previously defined <span class="math inline">\(B\)</span>, in particular <span class="math inline">\(|B\cap R_{k'}|\leq \zeta_{k'}\)</span>, but given that <span class="math inline">\(B\subseteq S_t \cap R_{k^{(t+1,\phi(\bar k)-1)}}\)</span>, <span class="math inline">\(|B\cap R_{k'}|=|B|\)</span>. Wrapping all those equalities, it comes that <span class="math inline">\(|A_{\phi(\bar k)-1}\cap R_{k'}|\leq \zeta_{k'}\)</span>. In the end, <span class="math inline">\(|A_{\phi(\bar k)-1}\cap R_{k'}|\leq \zeta_{k'}\)</span> for all <span class="math inline">\(k'\in\mathcal{K}\)</span>, so <span class="math inline">\(A_{\phi(\bar k)-1}\)</span> realizes the maximum in <span class="math inline">\(\eqref{eq_Vstar_au_max}\)</span> for <span class="math inline">\(S_t \cap R_{k^{(t+1,\phi(\bar k)-1)}}\)</span>.</p>
<p>By applying exactly the same method, we recursively construct a non-increasing sequence <span class="math inline">\(A_{\phi(\bar k)}\subseteq\dotsb\subseteq A_1\)</span> such that for all <span class="math inline">\(\ell\in\{1,\dotsc, \phi(\bar k)\}\)</span> and <span class="math inline">\(k'\in\mathcal{K}\)</span>, <span class="math inline">\(A_\ell\subseteq S_t\cap R_{k^{(t+1,\ell)}}\)</span>, <span class="math inline">\(V^*_{\mathfrak{R}}(S_t\cap R_{k^{(t+1,\ell)}})=|A_\ell|\)</span>, and <span class="math inline">\(|A_\ell\cap R_{k'}|\leq \zeta_{k'}\)</span>. Furthermore for <span class="math inline">\(\ell'&gt;\ell\)</span>, <span class="math inline">\(A_{\ell}\setminus A_{\ell'}\subseteq S_t\cap R_{k^{(t+1,\ell)}}\setminus S_t\cap R_{k^{(t+1,\ell')}}\)</span>. Also note that the fact that <span class="math inline">\(i_{t+1}\not\in\bigcup_{k\in\mathcal{K}^-_{t}}R_k\)</span> implies that <span class="math inline">\(\eta^t_{k^{(t+1,\ell)}}&lt;\zeta_{k^{(t+1,\ell)}}\)</span> for all <span class="math inline">\(\ell\in\{1,\dotsc, \phi(\bar k)\}\)</span>. So by <span class="math inline">\(\eqref{eq_vstar_inter_Rk_equal_eta}\)</span>, <span class="math inline">\(|A_\ell|&lt;\zeta_{k^{(t+1,\ell)}}\)</span>.</p>
<p>Let, for any <span class="math inline">\(\ell\in\{1,\dotsc, \phi(\bar k)\}\)</span>, <span class="math inline">\(\widetilde A_\ell=A_\ell \cup \{ i_{t+1}\}\)</span>. Given that <span class="math inline">\(A_\ell\subseteq S_t\cap R_{k^{(t+1,\ell)}}\)</span> and that <span class="math inline">\(i_{t+1}\in S_{t+1}\setminus S_t\)</span>, <span class="math inline">\(\widetilde A_\ell\subseteq S_{t+1}\cap R_{k^{(t+1,\ell)}}\)</span>, <span class="math inline">\(|\widetilde A_\ell|=| A_\ell|+1\)</span>, and for all <span class="math inline">\(\ell'\in\{1,\dotsc, \phi(\bar k)\}\)</span>, <span class="math inline">\(|\widetilde A_\ell \cap R_{k^{(t+1,\ell')}} |=| A_\ell\cap R_{k^{(t+1,\ell')}}|+1\)</span>. Note that if, furthermore, <span class="math inline">\(\ell\geq \ell'\)</span>, then <span class="math inline">\(A_\ell\subseteq A_{\ell'}\)</span>, so <span class="math display">\[\begin{align*}
|\widetilde A_\ell \cap R_{k^{(t+1,\ell')}} |&amp;=| A_\ell\cap R_{k^{(t+1,\ell')}}|+1\\
&amp;\leq | A_{\ell'}\cap R_{k^{(t+1,\ell')}}|+1\\
&amp;= | A_{\ell'}|+1\\
&amp;&lt;\zeta_{k^{(t+1,\ell')}}+1.\\
\end{align*}\]</span> On the contrary, if <span class="math inline">\(\ell&lt; \ell'\)</span>, we write that <span class="math display">\[\begin{align*}
|\widetilde A_\ell \cap R_{k^{(t+1,\ell')}} |&amp;=| A_\ell\cap R_{k^{(t+1,\ell')}}|+1\\
&amp;= | (A_{\ell}\setminus A_{\ell'}) \cap R_{k^{(t+1,\ell')}}   | + | A_{\ell'}\cap R_{k^{(t+1,\ell')}}|+1\\
&amp;&lt;  0 +  \zeta_{k^{(t+1,\ell')}} +1,
\end{align*}\]</span> because <span class="math inline">\(A_{\ell}\setminus A_{\ell'} \subseteq   R_{k^{(t+1,\ell)}}\setminus  R_{k^{(t+1,\ell')}}\)</span> hence <span class="math inline">\((A_{\ell}\setminus A_{\ell'}) \cap R_{k^{(t+1,\ell')}}  =\varnothing\)</span>. In both cases, <span class="math inline">\(|\widetilde A_\ell \cap R_{k^{(t+1,\ell')}} |&lt; \zeta_{k^{(t+1,\ell')}} +1\)</span> so <span class="math inline">\(|\widetilde A_\ell \cap R_{k^{(t+1,\ell')}} |\leq \zeta_{k^{(t+1,\ell')}}\)</span>. Additionally, for all <span class="math inline">\(k'\in\mathcal{K}\)</span> such that <span class="math inline">\(i_{t+1}\not\in R_{k'}\)</span>, <span class="math inline">\(|\widetilde A_\ell \cap R_{k'} |=| A_\ell \cap R_{k'} |\leq \zeta_{k'}\)</span>.</p>
<p>In the end, <span class="math inline">\(|\widetilde A_\ell \cap R_{k'} |\leq \zeta_{k'}\)</span> for all <span class="math inline">\(k'\in\mathcal{K}\)</span>, so <span class="math display">\[\begin{align*}
V^*_{\mathfrak{R}}( S_{t+1}\cap R_{k^{(t+1,\ell)}})&amp;\geq | \widetilde A_\ell | \text{ by \eqref{eq_Vstar_au_max}}\\
&amp;=  |  A_\ell | +1\\
&amp;= V^*_{\mathfrak{R}}( S_{t}\cap R_{k^{(t+1,\ell)}}) +1.
\end{align*}\]</span> So, as we wanted, <span class="math inline">\(V^*_{\mathfrak{R}}(S_{t+1}\cap R_k)\geq V^*_{\mathfrak{R}}(S_{t}\cap R_k)+1\)</span> for all <span class="math inline">\(k\in\mathcal{K}_{t}\)</span> such that <span class="math inline">\(i_{t+1}\in R_k\)</span> and so for all such <span class="math inline">\(k\)</span> that are in <span class="math inline">\(\mathcal{K}_{t+1}\)</span>. So every inequality in <span class="math inline">\(\eqref{eq_ineq_}\)</span> becomes an equality and we have proven that <span class="math display">\[\begin{equation*}
V^*_{\mathfrak{R}}(S_{t+1}\cap R_k) = V^*_{\mathfrak{R}}(S_{t}\cap R_k)+1 =\eta^t_k+1= \eta^{t+1}_k,
\end{equation*}\]</span> that is, <span class="math inline">\(\eqref{eq_vstar_inter_Rk_equal_eta}\)</span> is true at <span class="math inline">\(t+1\)</span>. Looking at the first line of <span class="math inline">\(\eqref{eq_ineq_}\)</span> , we also proved that <span class="math display">\[\begin{equation}
V^*_{\mathfrak{R}}(S_{t+1}\cap R_k) =  \sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| . \label{eq_Pt_instead}
\end{equation}\]</span> The only thing left to prove is that <span class="math inline">\(\eqref{eq_Pt_instead}\)</span> is also true with <span class="math inline">\(\mathcal{P}^{t+1}\)</span> instead of <span class="math inline">\(\mathcal{P}^{t}\)</span>, that is that <span class="math inline">\(\eqref{eq_Pt_good_partition}\)</span> also holds at <span class="math inline">\(t+1\)</span>, or, put differently, that <span class="math display">\[\begin{equation}\label{eq_last_goal}
\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|=\sum_{\substack{k'\in\mathcal{P}^{t+1}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|.
\end{equation}\]</span> If <span class="math inline">\(h^f_{t+1}\)</span> does not exist, meaning that we didn’t break the loop, <span class="math inline">\(\mathcal{P}^{t+1}=\mathcal{P}^t\)</span> so there is nothing to prove.</p>
<p>Now assume that <span class="math inline">\(h^f_{t+1}\)</span> exists. So <span class="math inline">\(\eqref{eq_rel_rec_p}\)</span> holds. We will split each term in <span class="math inline">\(\eqref{eq_last_goal}\)</span> in a sum of two terms. First, note that by <span class="math inline">\(\eqref{eq_rel_rec_p}\)</span>, for any <span class="math inline">\(k'\in\mathcal{K}\)</span> such that <span class="math inline">\(R_{k'}\cap  R_{  k^{(t+1,h^f_{t+1})} } = \varnothing\)</span>, we have that <span class="math inline">\(k'\in\mathcal{P}^{t+1}\)</span> if and only if <span class="math inline">\(k'\in \mathcal{P}^{t}\)</span>. And so, <span class="math display">\[\begin{align*}
\sum_{\substack{k'\in\mathcal{P}^{t+1}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| &amp;=  \sum_{\substack{k'\in\mathcal{P}^{t+1}\\R_{k'}\cap  R_{  k^{(t+1,h^f_{t+1})} } = \varnothing \\R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| +  \zeta_{ k^{(t+1,h^f_{t+1})}}\wedge |S_{t+1}\cap R_{ k^{(t+1,h^f_{t+1})}}|\\
&amp;=  \sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\cap  R_{  k^{(t+1,h^f_{t+1})} } = \varnothing \\R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| +  \zeta_{ k^{(t+1,h^f_{t+1})}}\wedge |S_{t+1}\cap R_{ k^{(t+1,h^f_{t+1})}}|.
\end{align*}\]</span></p>
<p>Recall that we already proved that there is no <span class="math inline">\(k'\in \mathcal{P}^t\)</span> such that <span class="math inline">\(R_{  k^{(t+1,h^f_{t+1})} }\subsetneq R_{k'}\)</span>, so for any <span class="math inline">\(k'\in \mathcal{P}^t\)</span>, either <span class="math inline">\(R_{k'}\cap  R_{  k^{(t+1,h^f_{t+1})} } = \varnothing\)</span> or <span class="math inline">\(R_{k'}\subseteq  R_{  k^{(t+1,h^f_{t+1})}}\)</span>. Hence the split <span class="math display">\[\begin{align*}
\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| &amp;=  \sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\cap  R_{  k^{(t+1,h^f_{t+1})} } = \varnothing \\R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|  \;   + \sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq  R_{  k^{(t+1,h^f_{t+1})}}\\ R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|\\
&amp;=\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\cap  R_{  k^{(t+1,h^f_{t+1})} } = \varnothing \\R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|  \;   + \sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq  R_{  k^{(t+1,h^f_{t+1})}}}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|,
\end{align*}\]</span> where the last equality comes from the fact that <span class="math inline">\(R_{  k^{(t+1,h^f_{t+1})} }\subseteq R_k\)</span>, because <span class="math inline">\(k\in\mathcal{K}_{t+1}\)</span>, <span class="math inline">\(i_{t+1}\in R_k\)</span>, and <span class="math inline">\(k^{(t+1,h^f_{t+1})}\in \mathcal{P}^{t+1}\)</span>.</p>
<p>Given the two previously made splits, it remains to prove that <span class="math display">\[\begin{equation*}
\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq  R_{  k^{(t+1,h^f_{t+1})}} }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| =  \zeta_{ k^{(t+1,h^f_{t+1})}}\wedge |S_{t+1}\cap R_{ k^{(t+1,h^f_{t+1})}}|.
\end{equation*}\]</span> Interestingly, this does not depend on <span class="math inline">\(k\)</span> anymore. By <span class="math inline">\(\eqref{eq_Pt_instead}\)</span>, the left-hand side is equal to <span class="math inline">\(V^*_{\mathfrak{R}}( S_{t+1}\cap  R_{  k^{(t+1,h^f_{t+1})}  } )\)</span>. Because we are breaking the loop at step <span class="math inline">\(h^f_{t+1}\)</span>, <span class="math inline">\(\eta^{t+1}_{k^{(t+1,h^f_{t+1})} }= \zeta_{ k^{(t+1,h^f_{t+1})}}\)</span>. Finally, because <span class="math inline">\(\eqref{eq_vstar_inter_Rk_equal_eta}\)</span> holds at <span class="math inline">\(t+1\)</span>, <span class="math inline">\(\eta^{t+1}_{k^{(t+1,h^f_{t+1})} }=V^*_{\mathfrak{R}}( S_{t+1}\cap  R_{  k^{(t+1,h^f_{t+1})}  } )\)</span>. Wrapping all these assertions: <span class="math display">\[\begin{align*}
\sum_{\substack{k'\in\mathcal{P}^{t}\\R_{k'}\subseteq  R_{  k^{(t+1,h^f_{t+1})}} }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| &amp;= V^*_{\mathfrak{R}}( S_{t+1}\cap  R_{  k^{(t+1,h^f_{t+1})}  } )\\
&amp;=V^*_{\mathfrak{R}}( S_{t+1}\cap  R_{  k^{(t+1,h^f_{t+1})}  } )\wedge  |S_{t+1}\cap R_{ k^{(t+1,h^f_{t+1})}}|\\
&amp;=\eta^{t+1}_{k^{(t+1,h^f_{t+1})} }\wedge  |S_{t+1}\cap R_{ k^{(t+1,h^f_{t+1})}}|\\
&amp;=  \zeta_{ k^{(t+1,h^f_{t+1})}}\wedge |S_{t+1}\cap R_{ k^{(t+1,h^f_{t+1})}}|,
\end{align*}\]</span> which achieves the second case and so the proof.</p>
<p><span class="math inline">\(\square\)</span></p>
</div>
<p>We deduce from the proof the following light corollary, that is useful for the implementation, because it makes it useless to compute <span class="math inline">\(\mathcal{K}^1\)</span>. It justifies the line 19 of <a href="#alg-curve" class="quarto-xref">Algorithm 4</a>.</p>
<div id="cor-easy-impl" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 1 (Easy computation)</strong></span> For <span class="math inline">\(t\in\{0,\dotsc, m-1 \}\)</span>, <span class="math inline">\(V^*_{\mathfrak{R}}(S_{t+1})=V^*_{\mathfrak{R}}(S_{t})\)</span> if <span class="math inline">\(i_{t+1}\in \bigcup_{k\in\mathcal{K}^-_t}R_k\)</span>, and <span class="math inline">\(V^*_{\mathfrak{R}}(S_{t+1})=V^*_{\mathfrak{R}}(S_{t}) + 1\)</span> if not.</p>
</div>
<p>Finally, we present <a href="#alg-curve" class="quarto-xref">Algorithm 4</a>, the alternative version of <a href="#alg-formal-curve" class="quarto-xref">Algorithm 3</a>, written with practical implementation in mind rather than formalism of notation, and using <a href="#cor-easy-impl" class="quarto-xref">Corollary&nbsp;1</a>. It is easy to see that each step <span class="math inline">\(t\)</span> has a complexity in <span class="math inline">\(O(|\mathcal{K}|)\)</span> hence the total complexity is in <span class="math inline">\(O(m|\mathcal{K}|)\)</span>. This is because, if the regions are carefully stocked in memory, especially if their bounds (in terms of hypothesis index) are stocked, then finding <span class="math inline">\(k^{(t,h)}\)</span> has a complexity in <span class="math inline">\(O(|\mathcal{K}^h|)\)</span> and checking if <span class="math inline">\(i_t\in\bigcup_{k\in\mathcal{K}^-_{t-1}}R_k\)</span> has a complexity in <span class="math inline">\(O(|\mathcal{K}|)\)</span>.</p>
<div id="alg-curve" class="pseudocode-container quarto-float" data-comment-delimiter="//" data-indent-size="1.2em" data-pseudocode-number="4" data-line-number-punc=":" data-line-number="true" data-caption-prefix="Algorithm" data-no-end="false">
<div class="pseudocode">
\begin{algorithm} \caption{Practical computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$} \begin{algorithmic} \Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$ with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$} \State $V_0\gets 0$ \State $\mathcal{K}^-\gets\{k\in\mathcal{K} : \zeta_k=0 \}$ \State $\eta_k\gets 0$ for all $k\in\mathcal{K}$ \For{$t=1,\dotsc, m$} \If{$i_t\in\bigcup_{k\in\mathcal{K}^-}R_k$} \State $V_{t}\gets V_{t-1}$ \Else \For{$h=1,\dotsc,h_{\max}(t)$} \State find $k^{(t,h)}\in\mathcal{K}^{h}$ such that $i_t\in R_{k^{(t,h)}}$ \State $\eta_{k^{(t,h)}}\gets\eta_{k^{(t,h)}} + 1$ \If{$\eta_{k^{(t,h)}}&lt;\zeta_k$} \State pass \Else \State $\mathcal{K}^- \gets \mathcal{K}^-\cup \{ k^{(t,h)} \}$ \State break the loop \EndIf \EndFor \State $V_{t}\gets V_{t-1} + 1$ \EndIf \EndFor \Return $(V_t)_{1\leq t \leq m}$ \EndProcedure \end{algorithmic} \end{algorithm}
</div>
</div>
</section>
</section>
<section id="sec-implementation" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Implementation</h1>
<p>All algorithms discussed in this manuscript are already implemented in the <code>R</code> <span class="citation" data-cites="R-base">(<a href="#ref-R-base" role="doc-biblioref">R Core Team 2024</a>)</span> package <code>sanssouci</code> <span class="citation" data-cites="sanssouci">(<a href="#ref-sanssouci" role="doc-biblioref">Neuvial et al. 2024</a>)</span> which is available on GitHub (see the References for the link) and is dedicated to the computation of confidence bounds for the number of false positives. It also hosts the implementation of the methods described in <span class="citation" data-cites="MR4124323">Blanchard, Neuvial, and Roquain (<a href="#ref-MR4124323" role="doc-biblioref">2020</a>)</span> and <span class="citation" data-cites="10.1093/bioinformatics/btac693">Enjalbert-Courrech and Neuvial (<a href="#ref-10.1093/bioinformatics/btac693" role="doc-biblioref">2022</a>)</span>. <a href="#alg-vstar" class="quarto-xref">Algorithm 1</a> is implemented as the <code>V.star</code> function, <a href="#alg-pruning" class="quarto-xref">Algorithm 2</a> is implemented as the <code>pruning</code> function, and <a href="#alg-curve" class="quarto-xref">Algorithm 4</a> is implemented as the <code>curve.V.star.forest.fast</code> function (whereas the <code>curve.V.star.forest.naive</code> function just repeatedly calls <code>V.star</code>). Note that the <code>pruning</code> function has a <code>delete.gaps</code> option that speeds up the computation even more by removing unnecessary gaps introduced in the data structure by the pruning operation, those gaps being due to the specific structure that is used to store the information of <span class="math inline">\(\mathcal{K}\)</span>.</p>
<p>The functions <code>dyadic.from.leaf_list</code>, <code>dyadic.from.window.size</code>, and <code>dyadic.from.height</code> return the appropriate data structure to represent a <span class="math inline">\(\mathcal{K}\)</span> that can be described as a dyadic tree, based on some entry parameters that can be inferred from the names of the functions. The completion of a forest structure, mentioned in <a href="#sec-forest-structure" class="quarto-xref">Section&nbsp;2.3</a>, is done by the <code>forest.completion</code> function. Finally, the <span class="math inline">\(\zeta_k\)</span> are computed as in <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> by the <code>zetas.tree</code> function with <code>method=zeta.DKWM</code>.</p>
</section>
<section id="sec-numeric" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Numerical experiments</h1>
<p>In this Section, we present some numerical experiments aiming to demonstrate the impact of the pruning of <a href="#alg-pruning" class="quarto-xref">Algorithm 2</a> (using the <code>delete.gaps</code> option mentioned in <a href="#sec-implementation" class="quarto-xref">Section&nbsp;4</a>) and of the fast <a href="#alg-curve" class="quarto-xref">Algorithm 4</a>, in terms of computation time, compared to the only previously available method to compute a curve of confidence bounds. As mentioned in <a href="#sec-forest-structure" class="quarto-xref">Section&nbsp;2.3</a> and <a href="#sec-implementation" class="quarto-xref">Section&nbsp;4</a>, this naive method simply consisted in a <code>for</code> loop repeatedly applying <a href="#alg-vstar" class="quarto-xref">Algorithm 1</a>.</p>
<p>To compare the computation time, we use the <code>R</code> package <code>microbenchmark</code> version 1.5.0 <span class="citation" data-cites="microbenchmark">(<a href="#ref-microbenchmark" role="doc-biblioref">Mersmann 2024</a>)</span> with <code>R</code> version 4.4.0 (2024-04-24) and <code>sanssouci</code> version 0.13.0, on a MacBook Air M1 (2020) running macOS 15.1.1. The package <code>microbenchmark</code> allows to run code snippets a given number <code>n_repl</code> of times, and to compute summary statistics on the computation time. The script executing the computation can be found in the same repository as this manuscript.</p>
<p>Four scenarios are studied, all based on a common setting which we first describe. A number <span class="math inline">\(m\)</span> of hypotheses is tested. We use a reference family <span class="math inline">\((R_k,\zeta_k)\)</span> such that the <span class="math inline">\(R_k\)</span>’s have a forest structure of maximal depth <span class="math inline">\(H=10\)</span>. The graph of the inclusion relations between the <span class="math inline">\(R_k\)</span>’s is a binary tree, hence there are <span class="math inline">\(2^H-1=1023\)</span> <span class="math inline">\(R_k\)</span>’s and in particular <span class="math inline">\(2^{H-1}=512\)</span> atoms. <span class="math inline">\(P\)</span>-values are generated in a gaussian one-sided fashion where <span class="math inline">\(H_{0,i}= \{ \mathcal N(\boldsymbol{\mu}, \mathrm{Id})  :\mu_i=0 \}\)</span>, <span class="math inline">\(H_{1,i}=\{ \mathcal N(\boldsymbol{\mu}, \mathrm{Id}) :\mu_i=4 \}\)</span>, and <span class="math inline">\(p_i(X)=1-\Phi(X_i)\)</span>. <span class="math inline">\(\mathcal{H}_1\)</span> is comprised of the leafs 1, 5, 9 and 10, that is <span class="math inline">\(\mathcal{H}_1=P_1\cup P_5\cup P_9\cup P_{10}\)</span>. For each scenario, the curve <span class="math inline">\(\left(V^*_{\mathfrak{R}}(\{1,\dotsc,t \})\right)_{t\in\mathbb{N}_m^*}\)</span> is computed. For the experiments including pruning, the pruning is done once before the <code>n_repl</code> replications, to mimick the practice where pruning only needs to be done once and for all, while the user may be interested in computing multiple bounds and curves after that.</p>
<p>In scenarios 1 and 2, <span class="math inline">\(m=1024\)</span> (so the atoms are of size 2), in scenarios 3 and 4, <span class="math inline">\(m=10240\)</span> (so the atoms are of size 10). In scenarios 1 and 3, the <span class="math inline">\(\zeta_k\)</span>’s are estimated trivially by <span class="math inline">\(\zeta_k=|R_k|\)</span>, and in scenarios 2 and 4, they are computed as in <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span> with the DKWM inequality <span class="citation" data-cites="MR0083864 MR1062069">(<a href="#ref-MR0083864" role="doc-biblioref">Dvoretzky, Kiefer, and Wolfowitz 1956</a>; <a href="#ref-MR1062069" role="doc-biblioref">Massart 1990</a>)</span>. Because of the size of <span class="math inline">\(m\)</span> and the poor performances of the naive approach, we set <code>n_repl=100</code> in scenarios 1 and 2 and <code>n_repl=10</code> only in scenario s 3 and 4. The differences between the scenarios are summarized in <a href="#tbl-scenarios" class="quarto-xref">Table&nbsp;1</a>.</p>
<div id="tbl-scenarios" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-scenarios-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Differences between the scenarios
</figcaption>
<div aria-describedby="tbl-scenarios-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead>
<tr class="header">
<th>parameter</th>
<th>Scenario 1</th>
<th>Scenario 2</th>
<th>Scenario 3</th>
<th>Scenario 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(m\)</span></td>
<td>1024</td>
<td>1024</td>
<td>10240</td>
<td>10240</td>
</tr>
<tr class="even">
<td>zeta computation</td>
<td>trivial</td>
<td>DKWM</td>
<td>trivial</td>
<td>DKWM</td>
</tr>
<tr class="odd">
<td><code>n_repl</code></td>
<td>100</td>
<td>100</td>
<td>10</td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>For the trivial <span class="math inline">\(\zeta_k\)</span> computation of scenarios 1 and 3, the pruning obviously deletes all non-atom regions so <span class="math inline">\(|\mathcal{K}^{\mathfrak{pr}}|=512\)</span>. Whereas, for the particular instance <span class="math inline">\(\omega\in\Omega\)</span> in the experiments, <span class="math inline">\(|\mathcal{K}^{\mathfrak{pr}}|=541\)</span> for scenario 2, and <span class="math inline">\(|\mathcal{K}^{\mathfrak{pr}}|=573\)</span> for scenario 4. Those results alone illustrate the benefits of pruning with respect to the reduction of the cardinality of the reference family: the regions above atoms with no signal (or no detectable signal in the trivial scenarios) are pruned. The fact that the regions above atoms with detectable signal are not pruned means that they are relevant for the confidences bounds (which had already been demonstrated in the simulation study of <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span>).</p>
<p>The summary statistics of the computation time in each scenario are presented in <a href="#tbl-benchmark01" class="quarto-xref">Table&nbsp;2</a>, <a href="#tbl-benchmark02" class="quarto-xref">Table&nbsp;3</a>, <a href="#tbl-benchmark03" class="quarto-xref">Table&nbsp;4</a>, and <a href="#tbl-benchmark04" class="quarto-xref">Table&nbsp;5</a>, and they are also presented as boxplots in <a href="#fig-benchmark01" class="quarto-xref">Figure&nbsp;3</a>, <a href="#fig-benchmark02" class="quarto-xref">Figure&nbsp;4</a>, <a href="#fig-benchmark03" class="quarto-xref">Figure&nbsp;5</a> and <a href="#fig-benchmark04" class="quarto-xref">Figure&nbsp;6</a>. The time unit is the second.</p>
<div class="cell">
<div id="tbl-benchmark01" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-benchmark01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: Scenario 1
</figcaption>
<div aria-describedby="tbl-benchmark01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell caption-top table table-sm table-striped small">
<colgroup>
<col style="width: 20%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">expr</th>
<th style="text-align: right;">min</th>
<th style="text-align: right;">lq</th>
<th style="text-align: right;">mean</th>
<th style="text-align: right;">median</th>
<th style="text-align: right;">uq</th>
<th style="text-align: right;">max</th>
<th style="text-align: right;">neval</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">naive.not.pruned</td>
<td style="text-align: right;">3.6924007</td>
<td style="text-align: right;">3.7943906</td>
<td style="text-align: right;">3.8521256</td>
<td style="text-align: right;">3.8386487</td>
<td style="text-align: right;">3.8780412</td>
<td style="text-align: right;">4.5247099</td>
<td style="text-align: right;">100</td>
</tr>
<tr class="even">
<td style="text-align: left;">naive.pruned</td>
<td style="text-align: right;">3.2822354</td>
<td style="text-align: right;">3.4126177</td>
<td style="text-align: right;">3.4758338</td>
<td style="text-align: right;">3.4614076</td>
<td style="text-align: right;">3.5061541</td>
<td style="text-align: right;">3.8822089</td>
<td style="text-align: right;">100</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fast.not.pruned</td>
<td style="text-align: right;">0.1332744</td>
<td style="text-align: right;">0.1367000</td>
<td style="text-align: right;">0.1383806</td>
<td style="text-align: right;">0.1385039</td>
<td style="text-align: right;">0.1392707</td>
<td style="text-align: right;">0.1768691</td>
<td style="text-align: right;">100</td>
</tr>
<tr class="even">
<td style="text-align: left;">fast.pruned</td>
<td style="text-align: right;">0.0921422</td>
<td style="text-align: right;">0.0945472</td>
<td style="text-align: right;">0.0974025</td>
<td style="text-align: right;">0.0954231</td>
<td style="text-align: right;">0.0978687</td>
<td style="text-align: right;">0.1908498</td>
<td style="text-align: right;">100</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<div class="cell">
<div id="tbl-benchmark02" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-benchmark02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;3: Scenario 2
</figcaption>
<div aria-describedby="tbl-benchmark02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell caption-top table table-sm table-striped small">
<colgroup>
<col style="width: 20%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">expr</th>
<th style="text-align: right;">min</th>
<th style="text-align: right;">lq</th>
<th style="text-align: right;">mean</th>
<th style="text-align: right;">median</th>
<th style="text-align: right;">uq</th>
<th style="text-align: right;">max</th>
<th style="text-align: right;">neval</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">naive.not.pruned</td>
<td style="text-align: right;">3.7280744</td>
<td style="text-align: right;">3.8025695</td>
<td style="text-align: right;">3.8514710</td>
<td style="text-align: right;">3.8451367</td>
<td style="text-align: right;">3.8831009</td>
<td style="text-align: right;">4.1891831</td>
<td style="text-align: right;">100</td>
</tr>
<tr class="even">
<td style="text-align: left;">naive.pruned</td>
<td style="text-align: right;">3.3556131</td>
<td style="text-align: right;">3.4533210</td>
<td style="text-align: right;">3.4926114</td>
<td style="text-align: right;">3.4906796</td>
<td style="text-align: right;">3.5182172</td>
<td style="text-align: right;">3.8501820</td>
<td style="text-align: right;">100</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fast.not.pruned</td>
<td style="text-align: right;">0.1214844</td>
<td style="text-align: right;">0.1246071</td>
<td style="text-align: right;">0.1265674</td>
<td style="text-align: right;">0.1260760</td>
<td style="text-align: right;">0.1279640</td>
<td style="text-align: right;">0.1407320</td>
<td style="text-align: right;">100</td>
</tr>
<tr class="even">
<td style="text-align: left;">fast.pruned</td>
<td style="text-align: right;">0.0815349</td>
<td style="text-align: right;">0.0827995</td>
<td style="text-align: right;">0.0841622</td>
<td style="text-align: right;">0.0835618</td>
<td style="text-align: right;">0.0851062</td>
<td style="text-align: right;">0.0896013</td>
<td style="text-align: right;">100</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<div class="cell">
<div id="tbl-benchmark03" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-benchmark03-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4: Scenario 3
</figcaption>
<div aria-describedby="tbl-benchmark03-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell caption-top table table-sm table-striped small">
<colgroup>
<col style="width: 17%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 6%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">expr</th>
<th style="text-align: right;">min</th>
<th style="text-align: right;">lq</th>
<th style="text-align: right;">mean</th>
<th style="text-align: right;">median</th>
<th style="text-align: right;">uq</th>
<th style="text-align: right;">max</th>
<th style="text-align: right;">neval</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">naive.not.pruned</td>
<td style="text-align: right;">332.1856576</td>
<td style="text-align: right;">335.5148922</td>
<td style="text-align: right;">337.9856658</td>
<td style="text-align: right;">338.2432916</td>
<td style="text-align: right;">340.3329972</td>
<td style="text-align: right;">344.6255264</td>
<td style="text-align: right;">10</td>
</tr>
<tr class="even">
<td style="text-align: left;">naive.pruned</td>
<td style="text-align: right;">328.3186707</td>
<td style="text-align: right;">329.3081834</td>
<td style="text-align: right;">332.1861199</td>
<td style="text-align: right;">331.4335773</td>
<td style="text-align: right;">333.3563651</td>
<td style="text-align: right;">338.7111614</td>
<td style="text-align: right;">10</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fast.not.pruned</td>
<td style="text-align: right;">1.4881838</td>
<td style="text-align: right;">1.4966417</td>
<td style="text-align: right;">1.5066370</td>
<td style="text-align: right;">1.5078498</td>
<td style="text-align: right;">1.5151194</td>
<td style="text-align: right;">1.5217546</td>
<td style="text-align: right;">10</td>
</tr>
<tr class="even">
<td style="text-align: left;">fast.pruned</td>
<td style="text-align: right;">0.9354581</td>
<td style="text-align: right;">0.9418174</td>
<td style="text-align: right;">0.9498806</td>
<td style="text-align: right;">0.9512573</td>
<td style="text-align: right;">0.9550453</td>
<td style="text-align: right;">0.9675895</td>
<td style="text-align: right;">10</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<div class="cell">
<div id="tbl-benchmark04" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-benchmark04-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;5: Scenario 4
</figcaption>
<div aria-describedby="tbl-benchmark04-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell caption-top table table-sm table-striped small">
<colgroup>
<col style="width: 17%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 6%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">expr</th>
<th style="text-align: right;">min</th>
<th style="text-align: right;">lq</th>
<th style="text-align: right;">mean</th>
<th style="text-align: right;">median</th>
<th style="text-align: right;">uq</th>
<th style="text-align: right;">max</th>
<th style="text-align: right;">neval</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">naive.not.pruned</td>
<td style="text-align: right;">331.0124665</td>
<td style="text-align: right;">335.6357519</td>
<td style="text-align: right;">349.7740812</td>
<td style="text-align: right;">337.6459728</td>
<td style="text-align: right;">342.1652204</td>
<td style="text-align: right;">401.4881647</td>
<td style="text-align: right;">10</td>
</tr>
<tr class="even">
<td style="text-align: left;">naive.pruned</td>
<td style="text-align: right;">331.2567637</td>
<td style="text-align: right;">332.2215437</td>
<td style="text-align: right;">363.5822362</td>
<td style="text-align: right;">333.0651271</td>
<td style="text-align: right;">335.8347696</td>
<td style="text-align: right;">493.5124771</td>
<td style="text-align: right;">10</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fast.not.pruned</td>
<td style="text-align: right;">1.3575818</td>
<td style="text-align: right;">1.3588461</td>
<td style="text-align: right;">1.3733567</td>
<td style="text-align: right;">1.3641336</td>
<td style="text-align: right;">1.3762178</td>
<td style="text-align: right;">1.4460291</td>
<td style="text-align: right;">10</td>
</tr>
<tr class="even">
<td style="text-align: left;">fast.pruned</td>
<td style="text-align: right;">0.9287399</td>
<td style="text-align: right;">0.9441687</td>
<td style="text-align: right;">0.9551275</td>
<td style="text-align: right;">0.9520622</td>
<td style="text-align: right;">0.9624959</td>
<td style="text-align: right;">0.9972532</td>
<td style="text-align: right;">10</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-benchmark01" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-benchmark01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="algo-curve_files/figure-html/fig-benchmark01-1.svg" id="fig-benchmark01" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-benchmark01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-benchmark02" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-benchmark02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="algo-curve_files/figure-html/fig-benchmark02-1.svg" id="fig-benchmark02" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-benchmark02-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-benchmark03" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-benchmark03-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="algo-curve_files/figure-html/fig-benchmark03-1.svg" id="fig-benchmark03" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-benchmark03-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-benchmark04" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-benchmark04-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="algo-curve_files/figure-html/fig-benchmark04-1.svg" id="fig-benchmark04" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-benchmark04-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6
</figcaption>
</figure>
</div>
</div>
</div>
<p>On each scenario, using the fast algorithm is much faster than the naive approach, while pruning always gives a slight improvement over not pruning.</p>
<p>Comparing scenarios 1 and 2 first, we see that, as expected, there is no significant change in computation time for <code>naive.not.pruned</code>, while <code>naive.pruned</code> is faster in scenario 1, given that we prune more. But, on the other hand, <code>fast.not.pruned</code> and <code>fast.pruned</code> are both faster in scenario 2, even if we prune less. This is because, for the regions with signal, said signal is detected and so those regions are quickly saturated, in the sense that we quickly have <span class="math inline">\(\eta_k^t=\zeta_k\)</span> and <span class="math inline">\(k\)</span> added <span class="math inline">\(\mathcal{K}^-_k\)</span>, which saves a lot of time.</p>
<p>The comparison between scenarios 3 and 4 is similar, except that this time we prune even less in scenario 4 and so the effect of the saturation is not enough to compensate. Although, with only <code>n_repl=10</code>, the statistics seem less accurate, this can be confirmed with additional experiments (<code>n_repl</code> can also be set to 100 without problem is we don’t include <code>naive</code> methods).</p>
<p>Finally, comparing scenarios 3 &amp; 4 with scenarios 1 &amp; 2, we see that multiplying the number of hypotheses by 10 effectively multiplies the computation time by <span class="math inline">\(\sim10\)</span> when using <a href="#alg-curve" class="quarto-xref">Algorithm 4</a> and by <span class="math inline">\(\sim100\)</span> when using <a href="#alg-vstar" class="quarto-xref">Algorithm 1</a> naively, which illustrates the stated complexities of <span class="math inline">\(O(m|\mathcal{K}|)\)</span> and <span class="math inline">\(O(m^2|\mathcal{K}|)\)</span>, respectively.</p>
</section>
<section id="conclusion" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Conclusion</h1>
<p>In conclusion, we effectively introduced a new algorithm to compute a curve of confidence upper bounds, much faster the previous alternative, with one power of <span class="math inline">\(m\)</span> less in the complexity.</p>
<p>To develop new confidence upper bounds methodology and test them on simulations, it was previously not conceivable to replicate experiments a sufficient number of times while computing whole curves. For instance, in the simulation study of <span class="citation" data-cites="MR4178188">Durand et al. (<a href="#ref-MR4178188" role="doc-biblioref">2020</a>)</span>, the number of replications chosen was 10 and the whole curve was not computed, only ten values along the curve were computed, for an <code>m</code> set to 12800, that is 0.078% of the curve had been computed. Now, simulation studies with an adequate number of replications and 100% of the curve become feasible.</p>
<p>A lot of work remains to be done on the <code>sanssouci</code> package. For example, to make the data format of a forest structure <span class="math inline">\((R_k)_{k\in\mathcal{K}}\)</span> less convoluted and more user-friendly is an interesting project. Another one would be to implement inside the package the methods of the paper <span class="citation" data-cites="blain22notip">Blain, Thirion, and Neuvial (<a href="#ref-blain22notip" role="doc-biblioref">2022</a>)</span>, which are currently only available in the Python language <span class="citation" data-cites="10.5555/1593511">(<a href="#ref-10.5555/1593511" role="doc-biblioref">Van Rossum and Drake 2009</a>)</span>, and the methods of the paper <span class="citation" data-cites="JMLR:v25:23-1025">Iqraa, Gilles, and Etienne (<a href="#ref-JMLR:v25:23-1025" role="doc-biblioref">2024</a>)</span>.</p>
<p>Other current works include the development of new reference families with theoretical JER control that could better account for realistic models, such as models with dependence between the <span class="math inline">\(p\)</span>-values, see for example <span class="citation" data-cites="perrot2023selective">Perrot-Dockès et al. (<a href="#ref-perrot2023selective" role="doc-biblioref">2023</a>)</span>, or models with discreteness.</p>
</section>
<section id="acknowledgements" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Acknowledgements</h1>
<p>This work has been supported by ANR-20-IDEES-0002 (PIA), ANR-19-CHIA-0021 (BISCOTTE), ANR-23-CE40-0018 (BACKUP) and ANR-21-CE23-0035 (ASCAI). Thanks to Romain Périer for being the first to extensively use the new implemented algorithms.</p>
</section>
<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-MR1325392" class="csl-entry" role="listitem">
Benjamini, Yoav, and Yosef Hochberg. 1995. <span>“Controlling the False Discovery Rate: A Practical and Powerful Approach to Multiple Testing.”</span> <em>J. Roy. Statist. Soc. Ser. B</em> 57 (1): 289–300. <a href="https://www.jstor.org/stable/2346101">https://www.jstor.org/stable/2346101</a>.
</div>
<div id="ref-blain22notip" class="csl-entry" role="listitem">
Blain, Alexandre, Bertrand Thirion, and Pierre Neuvial. 2022. <span>“<span class="nocase">Notip: Non-parametric True Discovery Proportion control for brain imaging</span>.”</span> <em>Neuroimage</em> 260 (October). <a href="https://doi.org/10.1016/j.neuroimage.2022.119492">https://doi.org/10.1016/j.neuroimage.2022.119492</a>.
</div>
<div id="ref-MR4124323" class="csl-entry" role="listitem">
Blanchard, Gilles, Pierre Neuvial, and Etienne Roquain. 2020. <span>“Post Hoc Confidence Bounds on False Positives Using Reference Families.”</span> <em>Ann. Statist.</em> 48 (3): 1281–1303. <a href="https://doi.org/10.1214/19-AOS1847">https://doi.org/10.1214/19-AOS1847</a>.
</div>
<div id="ref-MR3418717" class="csl-entry" role="listitem">
Bogdan, Małgorzata, Ewout van den Berg, Chiara Sabatti, Weijie Su, and Emmanuel J. Candès. 2015. <span>“S<span>LOPE</span>—Adaptive Variable Selection via Convex Optimization.”</span> <em>Ann. Appl. Stat.</em> 9 (3): 1103–40. <a href="https://doi.org/10.1214/15-AOAS842">https://doi.org/10.1214/15-AOAS842</a>.
</div>
<div id="ref-MR4178188" class="csl-entry" role="listitem">
Durand, Guillermo, Gilles Blanchard, Pierre Neuvial, and Etienne Roquain. 2020. <span>“Post Hoc False Positive Control for Structured Hypotheses.”</span> <em>Scand. J. Stat.</em> 47 (4): 1114–48. <a href="https://doi.org/10.1111/sjos.12453">https://doi.org/10.1111/sjos.12453</a>.
</div>
<div id="ref-MR0083864" class="csl-entry" role="listitem">
Dvoretzky, A., J. Kiefer, and J. Wolfowitz. 1956. <span>“Asymptotic Minimax Character of the Sample Distribution Function and of the Classical Multinomial Estimator.”</span> <em>Ann. Math. Statist.</em> 27: 642–69. <a href="https://doi.org/10.1214/aoms/1177728174">https://doi.org/10.1214/aoms/1177728174</a>.
</div>
<div id="ref-10.1093/bioinformatics/btac693" class="csl-entry" role="listitem">
Enjalbert-Courrech, Nicolas, and Pierre Neuvial. 2022. <span>“Powerful and Interpretable Control of False Discoveries in Two-Group Differential Expression Studies.”</span> <em>Bioinformatics</em> 38 (23): 5214–21. <a href="https://doi.org/10.1093/bioinformatics/btac693">https://doi.org/10.1093/bioinformatics/btac693</a>.
</div>
<div id="ref-MR2279468" class="csl-entry" role="listitem">
Genovese, Christopher R., and Larry Wasserman. 2006. <span>“Exceedance Control of the False Discovery Proportion.”</span> <em>J. Amer. Statist. Assoc.</em> 101 (476): 1408–17. <a href="https://doi.org/10.1198/016214506000000339">https://doi.org/10.1198/016214506000000339</a>.
</div>
<div id="ref-MR2951390" class="csl-entry" role="listitem">
Goeman, Jelle J., and Aldo Solari. 2011. <span>“Multiple Testing for Exploratory Research.”</span> <em>Statist. Sci.</em> 26 (4): 584–97. <a href="https://doi.org/10.1214/11-STS356">https://doi.org/10.1214/11-STS356</a>.
</div>
<div id="ref-JMLR:v25:23-1025" class="csl-entry" role="listitem">
Iqraa, Meah, Blanchard Gilles, and Roquain Etienne. 2024. <span>“False Discovery Proportion Envelopes with m-Consistency.”</span> <em>Journal of Machine Learning Research</em> 25 (270): 1–52. <a href="http://jmlr.org/papers/v25/23-1025.html">http://jmlr.org/papers/v25/23-1025.html</a>.
</div>
<div id="ref-MR468056" class="csl-entry" role="listitem">
Marcus, Ruth, Eric Peritz, and K. R. Gabriel. 1976. <span>“On Closed Testing Procedures with Special Reference to Ordered Analysis of Variance.”</span> <em>Biometrika</em> 63 (3): 655–60. <a href="https://doi.org/10.1093/biomet/63.3.655">https://doi.org/10.1093/biomet/63.3.655</a>.
</div>
<div id="ref-MR1062069" class="csl-entry" role="listitem">
Massart, P. 1990. <span>“The Tight Constant in the <span>D</span>voretzky-<span>K</span>iefer-<span>W</span>olfowitz Inequality.”</span> <em>Ann. Probab.</em> 18 (3): 1269–83. <a href="http://links.jstor.org/sici?sici=0091-1798(199007)18:3<1269:TTCITD>2.0.CO;2-Q&amp;origin=MSN">http://links.jstor.org/sici?sici=0091-1798(199007)18:3&lt;1269:TTCITD&gt;2.0.CO;2-Q&amp;origin=MSN</a>.
</div>
<div id="ref-MR3305943" class="csl-entry" role="listitem">
Meijer, Rosa J., Thijmen J. P. Krebs, and Jelle J. Goeman. 2015. <span>“A Region-Based Multiple Testing Method for Hypotheses Ordered in Space or Time.”</span> <em>Stat. Appl. Genet. Mol. Biol.</em> 14 (1): 1–19. <a href="https://doi.org/10.1515/sagmb-2013-0075">https://doi.org/10.1515/sagmb-2013-0075</a>.
</div>
<div id="ref-MR2279639" class="csl-entry" role="listitem">
Meinshausen, Nicolai. 2006. <span>“False Discovery Control for Multiple Tests of Association Under General Dependence.”</span> <em>Scand. J. Statist.</em> 33 (2): 227–37. <a href="https://doi.org/10.1111/j.1467-9469.2005.00488.x">https://doi.org/10.1111/j.1467-9469.2005.00488.x</a>.
</div>
<div id="ref-microbenchmark" class="csl-entry" role="listitem">
Mersmann, Olaf. 2024. <em>Microbenchmark: Accurate Timing Functions</em>. <a href="https://CRAN.R-project.org/package=microbenchmark">https://CRAN.R-project.org/package=microbenchmark</a>.
</div>
<div id="ref-sanssouci" class="csl-entry" role="listitem">
Neuvial, Pierre, Gilles Blanchard, Guillermo Durand, Nicolas Enjalbert-Courrech, and Etienne Roquain. 2024. <em>Sanssouci: Post Hoc Multiple Testing Inference</em>. <a href="https://sanssouci-org.github.io/sanssouci">https://sanssouci-org.github.io/sanssouci</a>.
</div>
<div id="ref-perrot2023selective" class="csl-entry" role="listitem">
Perrot-Dockès, Marie, Gilles Blanchard, Pierre Neuvial, and Etienne Roquain. 2023. <span>“Selective Inference for False Discovery Proportion in a Hidden Markov Model.”</span> <em>TEST</em>, 1–27.
</div>
<div id="ref-R-base" class="csl-entry" role="listitem">
R Core Team. 2024. <em>R: A Language and Environment for Statistical Computing</em>. Vienna, Austria: R Foundation for Statistical Computing. <a href="https://www.R-project.org/">https://www.R-project.org/</a>.
</div>
<div id="ref-10.5555/1593511" class="csl-entry" role="listitem">
Van Rossum, Guido, and Fred L. Drake. 2009. <em>Python 3 Reference Manual</em>. Scotts Valley, CA: CreateSpace.
</div>
<div id="ref-MR4731977" class="csl-entry" role="listitem">
Vesely, Anna, Livio Finos, and Jelle J. Goeman. 2023. <span>“Permutation-Based True Discovery Guarantee by Sum Tests.”</span> <em>J. R. Stat. Soc. Ser. B. Stat. Methodol.</em> 85 (3): 664–83. <a href="https://doi.org/10.1093/jrsssb/qkad019">https://doi.org/10.1093/jrsssb/qkad019</a>.
</div>
</div>
</section>


<div id="quarto-appendix" class="default"><section id="session-information" class="level1 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">Session information</h2><div class="quarto-appendix-contents">

<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>R version 4.4.1 (2024-06-14)
Platform: x86_64-pc-linux-gnu
Running under: Ubuntu 24.04.1 LTS

Matrix products: default
BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.12.0 
LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.12.0

locale:
 [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       
 [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   
 [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          
[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   

time zone: Etc/UTC
tzcode source: system (glibc)

attached base packages:
[1] stats     graphics  grDevices datasets  utils     methods   base     

other attached packages:
[1] microbenchmark_1.5.0

loaded via a namespace (and not attached):
 [1] compiler_4.4.1    fastmap_1.1.1     cli_3.6.2         htmltools_0.5.8.1
 [5] tools_4.4.1       yaml_2.3.8        rmarkdown_2.26    knitr_1.46       
 [9] jsonlite_1.8.8    xfun_0.43         digest_0.6.35     rlang_1.1.3      
[13] renv_1.0.7        evaluate_0.23    </code></pre>
</div>
</div>
<!-- -->

</div></section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{durand2024,
  author = {Durand, Guillermo},
  publisher = {Société Française de Statistique},
  title = {A Fast Algorithm to Compute a Curve of Confidence Upper
    Bounds for the {False} {Discovery} {Proportion} Using a Reference
    Family with a Forest Structure},
  journal = {Computo},
  date = {2024-12-26},
  url = {https://computo.sfds.asso.fr/algo-curve},
  doi = {xxxx},
  issn = {2824-7795},
  langid = {en},
  abstract = {This paper presents a new algorithm (and an additional
    trick) that allows to compute fastly an entire curve of post hoc
    bounds for the False Discovery Proportion when the underlying bound
    \$V\^{}*\_\{\textbackslash mathfrak\{R\}\}\$ construction is based
    on a reference family \$\textbackslash mathfrak\{R\}\$ with a forest
    structure à la @MR4178188. By an entire curve, we mean the values
    \$V\^{}*\_\{\textbackslash mathfrak\{R\}\}(S\_1),\textbackslash
    dotsc,V\^{}*\_\{\textbackslash mathfrak\{R\}\}(S\_m)\$ computed on a
    path of increasing selection sets \$S\_1\textbackslash
    subsetneq\textbackslash dotsb\textbackslash subsetneq S\_m\$,
    \$\textbar S\_t\textbar=t\$. The new algorithm leverages the fact
    that going from \$S\_t\$ to \$S\_\{t+1\}\$ is done by adding only
    one hypothesis.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-durand2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Durand, Guillermo. 2024. <span>“A Fast Algorithm to Compute a Curve of
Confidence Upper Bounds for the False Discovery Proportion Using a
Reference Family with a Forest Structure.”</span> <em>Computo</em>,
December. <a href="https://doi.org/xxxx">https://doi.org/xxxx</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb3" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "A fast algorithm to compute a curve of confidence upper bounds for the False Discovery Proportion using a reference family with a forest structure"</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># subtitle: ""</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Guillermo Durand</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    email: guillermo.durand@universite-paris-saclay.fr</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://durandg12.github.io/</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0003-4056-5631</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Université Paris-Saclay</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Laboratoire de Mathématiques d'Orsay</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.imo.universite-paris-saclay.fr/fr/</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co">  This paper presents a new algorithm (and an additional trick) that allows to compute fastly an entire curve of post hoc bounds for the False Discovery Proportion when the underlying bound $V^*_{\mathfrak{R}}$ construction is based on a reference family $\mathfrak{R}$ with a forest structure à la @MR4178188. By an entire curve, we mean the values $V^*_{\mathfrak{R}}(S_1),\dotsc,V^*_{\mathfrak{R}}(S_m)$ computed on a path of increasing selection sets $S_1\subsetneq\dotsb\subsetneq S_m$, $|S_t|=t$. The new algorithm leverages the fact that going from $S_t$ to $S_{t+1}$ is done by adding only one hypothesis.</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [multiple testing, algorithmic, post hoc inference, false discovery proportion, confidence bound]</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "xxxx"</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/algo-curve</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> algo-curve.bib</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> durandg12</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "algo-curve"</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true # set to false once the build is running</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false # will be set to true once accepted</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="an">number-sections:</span><span class="co"> true</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: </span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="co">    html-math-method: mathjax</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="co">    include-in-header:</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="co">      - text: |</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="co">          &lt;script&gt;</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span class="co">          window.MathJax = {</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="co">            tex: {</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="co">              tags: 'ams'</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a><span class="co">            }</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="co">          };</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span class="co">          &lt;/script&gt;</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a><span class="co">    crossrefs-hover: true</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: </span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a><span class="co">    include-in-header:</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a><span class="co">      - text: |</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a><span class="co">          \usepackage{amsmath}</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a><span class="co">    cite-method: natbib</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a><span class="co">    natbiboptions: round</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a><span class="co">    keep-tex: true</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a><span class="co">    crossrefs-hover: true</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>::: {.hidden}</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a> \newcommand{\comp}<span class="co">[</span><span class="ot">1</span><span class="co">]</span>{{#1}^{\mathsf{c}}}</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a> \newcommand{\Pro}<span class="co">[</span><span class="ot">1</span><span class="co">]</span>{\mathbb{P}\left(#1\right)} </span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a> \newcommand{\Esp}<span class="co">[</span><span class="ot">1</span><span class="co">]</span>{\mathbb{E}\left<span class="co">[</span><span class="ot"> #1 \right</span><span class="co">]</span>}</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a> \newcommand{\ind}<span class="co">[</span><span class="ot">1</span><span class="co">]</span>{\mathbb{1}_{\left<span class="sc">\{</span>#1 \right<span class="sc">\}</span>}}</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a> \newcommand{\cH}{\mathcal{H}}</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a> \newcommand{\cK}{\mathcal{K}}</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a> \newcommand{\cP}{\mathcal{P}}</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a> \newcommand{\FDP}{\mathrm{FDP}}</span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a> \newcommand{\FDR}{\mathrm{FDR}}</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a> \newcommand{\JER}{\mathrm{JER}}</span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a> \newcommand{\Rfam}{\mathfrak{R}}</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a> \newcommand{\Hoi}{H_{0,i}}</span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a> \newcommand{\Vhat}{\widehat V}</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a> \newcommand{\Vstar}{V^*_{\Rfam}}</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a> \newcommand{\Nm}{\mathbb{N}_m}</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a> \newcommand{\pr}{\mathfrak{pr}}</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a> \newcommand{\kth}<span class="co">[</span><span class="ot">2</span><span class="co">]</span>{k^{(#1,#2)}}</span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a> \newcommand{\RR}{\mathbb{R}}</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a> \newcommand{\telque}{\,:\,}</span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>Multiple testing theory is often used for exploratory analysis, like Genome-Wide Association Studies, where multiple features are tested to find promising ones. Classical multiple testing theory like Family-Wise Error Rate (FWER) control or False Discovery Rate (FDR) control <span class="co">[</span><span class="ot">@MR1325392</span><span class="co">]</span> can be used, but a more recent trend consists in the computation of post hoc bounds, also named post selection bounds or confidence envelopes, for the number of false positives, or, equivalently, for the False Discovery Proportion (FDP). This approach is notably advocated for in the context of exploratory research by <span class="co">[</span><span class="ot">@MR2951390, Section 1</span><span class="co">]</span>. </span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>Mathematically speaking, a confidence upper bound (we prefer to say upper bound instead of envelope for obvious reasons) is a function $\Vhat : \cP(\Nm^*) \to \Nm$, where $\Nm=\{0,\dotsc,m\}$, $\Nm^*=<span class="sc">\{</span>1,\dotsc,m<span class="sc">\}</span>$ and $m$ is the number of hypotheses, such that </span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>\forall \alpha \in ]0,1[, \Pro{\forall S \subseteq \Nm^*, |S\cap \cH_0|\leq \Vhat(S)}\geq 1-\alpha.</span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>\label{eq_confidence}</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>Here, $\alpha$ is a target error rate and $\cH_0$ is the set of hypotheses indices that are true null hypotheses. Note that the construction of $\Vhat$ depends on $\alpha$ and on the random data $X$ and the dependence is omitted to lighten notation and because there is no ambiguity. The meaning of Equation \eqref{eq_confidence} is that $\Vhat$ provides an upper bound of the number of null hypotheses in $S$ for any selection set $S\subseteq \Nm^*$, which allows the user to perform post hoc selection on their data without breaching the statistical guarantee. Also note that by dividing by $|S|\vee 1$ in Equation \eqref{eq_confidence} we also get a confidence bound for the FDP:</span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>\forall \alpha \in ]0,1[, \Pro{\forall S \subseteq \Nm^*, \FDP(S)\leq \frac{\Vhat(S)}{|S|\vee 1}}\geq 1-\alpha.</span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a>\label{eq_confidence_fdp}</span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a>So post hoc bounds provide ways to construct FDP-controlling sets instead of FDR-controlling sets, which is much more desirable given the nature of the FDR as an expected value. See for example <span class="co">[</span><span class="ot">@MR3418717, Figure 4</span><span class="co">]</span> for a credible example where the FDR is controlled but the FDP has a highly undesirable behavior (either 0 because no discoveries at all are made, either higher than the target level).</span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a>The first confidence bounds are found in @MR2279468 and @MR2279639, although, in the latter, only for selection sets of the form $<span class="sc">\{</span>i\in\Nm : P_i\leq t<span class="sc">\}</span>$ where $P_i$ is the $p$-value associated to the null hypothesis $\Hoi$. In @MR2951390 the authors re-wrote the generic construction of @MR2279468 in terms of closed testing @MR468056, proposed several practical constructions and sparked a new interest in multiple testing procedures based on confidence envelopes. This work was followed by a prolific series of works like @MR3305943 or @MR4731977. In @MR4124323, the authors introduce the new point of view of references families (see @sec-reference-fam) to construct post hoc bounds, and show the links between this meta-technique and the closed testing one, along with new bounds. </span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>Following the reference family trail, in @MR4178188 the authors introduce new reference families with a special set-theoretic constraint that allows an efficient computation of the bound denoted by $\Vstar$ on a single selection set $S$. The problem is that one often wants to compute $\Vstar$ on a whole path of selection sets $(S_t)_{t\in\Nm^*}$, for example the hypotheses attached to the $t$ smallest $p$-values. Whereas the algorithm provided in the aforementioned work [@MR4178188, Algorithm 1], which is reproduced here, see @alg-vstar, is fast for a single evaluation, it is slow and inefficient to repeatedly call it to compute each $\Vstar(S_t)$. If the $S_t$'s are nested, and growing by one, that is $S_1\subsetneq\dotsb\subsetneq S_m$ and $|S_t|=t$, there is a way to efficiently compute $\left(\Vstar(S_t)\right)_{t\in\Nm}$ by leveraging the nested structure. </span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a>This is the main contribution of the present paper: a new and fast algorithm computing the curve $\left(\Vstar(S_t)\right)_{t\in\Nm}$ for a nested path of selection sets, that is presented in @sec-fast-curve. An additional algorithm that can speed up computations both for the single-evaluation algorithm and the new curve-evaluation algorithm is also presented, in @sec-pruning. In @sec-notation, all necessary notation and vocabulary is re-introduced, most of it being the same as in @MR4178188. In @sec-implementation we discuss the current implementations of all the presented algorithms in the <span class="in">`R`</span> <span class="co">[</span><span class="ot">@R-base</span><span class="co">]</span> package <span class="in">`sanssouci`</span> <span class="co">[</span><span class="ot">@sanssouci</span><span class="co">]</span>. Finally, a few numerical experiments are presented in Section @sec-numeric to demonstrate the computation time gain.</span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a><span class="fu"># Notation and reference family methodology</span></span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a><span class="fu">## Multiple testing notation {#sec-notation}</span></span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>As is usual in multiple testing theory, we consider a probability space $(\Omega,\mathcal A, \mathbb P)$, a model $\mathcal{P}$ on a measurable space $(\mathcal{X},\mathfrak{X})$, and data that is represented by a random variable $X:(\Omega,\mathcal A)\to(\mathcal{X},\mathfrak{X})$ with $X\sim P\in \mathcal{P}$, that is, the law of $X$ is comprised in the model $\mathcal{P}$.</span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>Then we consider $m\geq1$ null hypotheses $H_{0,1}, \dotsc, H_{0,m}$ which formally are submodels, that is subsets of $\mathcal{P}$. The associated alternative hypotheses $H_{1,1}, \dotsc, H_{1,m}$ are submodels such that $\Hoi\cap H_{1,i}=\varnothing$ for all $i\in\Nm^*$. We denote by $\cH_0=\cH_0(P)$ (the dependence in $P$ will be dropped when there is no ambiguity) the set of all null hypotheses that are true, that is $\cH_0(P)=\{i\in\Nm^* : P\in \Hoi\}$. In other words, $\Hoi$ is true if and only if $i\in\cH_0$. For testing each $\Hoi, i\in\Nm^*$, we have at hand a $p$-value $p_i=p_i(X)$ (the dependence in $X$ will be dropped when there is no ambiguity) which is a random variable with the following property : if $i\in\cH_0$, then the law of $p_i$ is super-uniform, which is sometimes denoted $\mathcal L(p_i)\succeq \mathcal{U}(<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>)$. This means that in such case, the cumulative distribution function (cdf) of $p_i$ is always smaller than or equal to the cdf of a random variable $U\sim \mathcal{U}(<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>)$ :</span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>\forall x \in \RR, \Pro{p_i\leq x}\leq \Pro{U\leq x} = 0\vee(x\wedge 1).</span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>\label{eq_super_unif}</span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>For every subset of hypotheses $S\subseteq\Nm^*$, let $V(S)=|S\cap\cH_0|$. If we think of $S$ as a selection set of hypotheses deemed significant, $V(S)$ is then the number of false positives (FP) in $S$. $V(S)$ is our main object of interest and the quantity that we wish to over-estimate with confidence upper bounds (see Equation \eqref{eq_confidence} or the more formal Equation \eqref{eq_confidence_formal} below).</span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a>Finally let us consider the following toy example, that will be re-used in the remainder of the paper.</span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a>::: {#exm-gauss}</span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a><span class="fu">## Gaussian one-sided</span></span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>In this case we assume that $X=(X_1,\dotsc,X_m)$ is a Gaussian vector and the null hypotheses refer to the nullity of the means in contrast to their positivity. That is, formally, $(\mathcal{X},\mathfrak{X})=(\mathbb R^m, \mathcal B\left(\mathbb R^m  \right))$, $\mathcal P=<span class="sc">\{</span> \mathcal N(\boldsymbol{\mu}, \Sigma) : \forall j \in\Nm^*, \mu_j\geq 0, \Sigma \text{ positive semidefinite}  \}$, for each $i\in\Nm^*$, $\Hoi= <span class="sc">\{</span> \mathcal N(\boldsymbol{\mu}, \Sigma) \in \mathcal P :\mu_i=0 <span class="sc">\}</span>$ and $H_{1,i}=<span class="sc">\{</span> \mathcal N(\boldsymbol{\mu}, \Sigma) \in \mathcal P :\mu_i&gt;0 <span class="sc">\}</span>$. Then we can construct $p$-values by letting $p_i(X)=\bar\Phi(X_i)=1-\Phi(X_i)$, where $\Phi$ denotes the cdf of $\mathcal N(0,1)$ and $\bar\Phi$ the associated survival function.</span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a><span class="fu">## Post hoc bounds with reference families {#sec-reference-fam}</span></span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a>With the formalism introduced in last section, a confidence upper bound is a functional $\Vhat :\mathcal X\times ]0,1[\to(\mathcal P(\Nm^*) \to \Nm)$  such that,</span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a>\forall P\in\mathcal P, \forall X\sim P, \forall \alpha \in ]0,1[, \Pro{\forall S \subseteq \Nm^*, V(S)\leq \Vhat(X,\alpha)(S)}\geq 1-\alpha.</span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a>\label{eq_confidence_formal}</span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a>In the remainder, the dependence in $(X,\alpha)$ will be dropped when there is no ambiguity and $\Vhat(X,\alpha)$ will simply be written $\Vhat$.</span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a>As said in the Introduction, many constructions, ultimately theoretically equivalent but differing by the practical steps involved, exist, and in this paper we focus on the meta-construction of @MR4124323 based on reference families. A reference family is a family $\Rfam=\Rfam(X,\alpha)=(R_k,\zeta_k)_{k\in \mathcal K}$ with $|\mathcal K|\leq 2^m$, $R_k\subseteq\Nm^*$, $\zeta_k\in\left<span class="sc">\{</span>0,\dotsc,|R_k|\right<span class="sc">\}</span>$ where everything (that is, $\mathcal K$ and all the $R_k$ and $\zeta_k$) depends on $(X,\alpha)$ but the dependency is not explicitly written. The $R_k$ are all distinct. We also define the following error criterion for a reference family, named Joint Error Rate (JER):</span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a>\JER(\Rfam) = \Pro{\exists k\in\mathcal K, |R_k\cap\cH_0| &gt; \zeta_k } = \Pro{\exists k\in\mathcal K, V(R_k) &gt; \zeta_k }.</span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a>\label{eq_jer}</span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a>In the following, we are only interested in reference families that control the JER at level $\alpha$:</span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a>\forall P\in\mathcal P, \forall X\sim P, \forall \alpha \in ]0,1[, 1-\JER(\Rfam(X,\alpha))=\Pro{\forall k\in\mathcal K, V(R_k)\leq \zeta_k} \geq 1-\alpha.</span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a>\label{eq_jer_control}</span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a>Note that Equation \eqref{eq_jer_control} is really similar to Equation \eqref{eq_confidence_formal} except that the uniform guarantee, instead of being over all $S\subseteq \Nm^*$, is only over all the $R_k\subseteq \Nm^*, k\in\mathcal K$, with $\mathcal K$ having cardinality potentially much smaller than $2^m$. A global confidence bound is then derived from a JER-controlling reference family by interpolation. Let </span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a>\mathcal A(\Rfam)= \left<span class="sc">\{</span>A\subseteq \Nm^*:  \forall k\in\mathcal K, |R_k\cap A| \leq \zeta_k \right<span class="sc">\}</span>.</span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a>\label{eq_a}</span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a>What says the JER control is that $\cH_0\in\mathcal A(\Rfam)$. We leverage this information with the following confidence bound construction:</span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>\Vstar(S) = \max_{A\in\mathcal A(\Rfam)}|S\cap A|</span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a>\label{eq-vstar}</span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a>which optimally uses the information provided by the JER control of the reference family, as proven by Proposition 2.1 of @MR4124323. Because of the $\max_{A\in\mathcal A(\Rfam)}$, the computation of $\Vstar(S)$ is generally intractable (see Proposition 2.2 of @MR4124323), but for specific structures of reference families, a polynomial computation can be derived. This is the topic of @MR4178188 and of next section.</span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a><span class="fu">## Regions with a forest structure {#sec-forest-structure}</span></span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a>The core concept of this section is to assume that the regions $R_k$'s of the reference family are what we called in @MR4178188 a forest structure, that is two regions are either disjoint or nested:</span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a>\forall k,k'\in\mathcal{K} , R_k \cap R_{k'} \in <span class="sc">\{</span> R_k,  R_{k'} , \varnothing <span class="sc">\}</span>.</span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a>\label{eq-forest}</span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a>Representing the $R_k$'s with a directed graph, where there is an oriented edge $R_k \leftarrow R_{k'}$ if and only if $R_k \subset R_{k'}$ and there is no $R_{k''}$ such that $R_k \subsetneq R_{k''}\subsetneq R_{k'}$ gives a forest, hence the name. See @exm-toy-forest and its representation in @fig-forest-exm.</span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a>We also need to introduce the notion of depth with the following function:</span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a>\phi \:  : \: \left<span class="sc">\{</span></span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a>\begin{array}{l  c l  }</span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a> \cK &amp; \to &amp; \mathbb{N}^*<span class="sc">\\</span></span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a>k &amp; \mapsto &amp; 1 + \left| <span class="sc">\{</span>k'\in\cK: R_k\subsetneq R_{k'} <span class="sc">\}</span> \right|   .</span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a>\end{array}</span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a>\right.</span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a>\label{eq-depth}</span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a>::: {#exm-toy-forest}</span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a>Let $m=25$, $R_1 = <span class="sc">\{</span>1, \dotsc , 20 <span class="sc">\}</span>$, $R_2  =  <span class="sc">\{</span>1, 2  <span class="sc">\}</span>$, $R_3   =   <span class="sc">\{</span>3 , \dotsc , 10 <span class="sc">\}</span>$, $R_4  =    <span class="sc">\{</span>11, \dotsc , 20 <span class="sc">\}</span>$, $R_5 =  <span class="sc">\{</span>5, \dotsc , 10 <span class="sc">\}</span>$, $R_6   =     <span class="sc">\{</span>11, \dotsc , 16 <span class="sc">\}</span>$, $R_7  =   <span class="sc">\{</span>17, \dotsc ,20  <span class="sc">\}</span>$, $R_8=<span class="sc">\{</span>21,22<span class="sc">\}</span>$, $R_9 = <span class="sc">\{</span>22<span class="sc">\}</span>$. This is the same example as Example 2 of @MR4178188 and it is graphically depicted in @fig-forest-exm. The sets $R_1$, $R_8$ are of depth $1$; the sets $R_2,R_3,R_4,R_9$ are of depth $2$; the sets $R_5,R_6,R_7$ are of depth $3$.</span>
<span id="cb3-176"><a href="#cb3-176" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-177"><a href="#cb3-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a>:::{#fig-forest-exm}</span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a><span class="in">``` {.tikz opt-additional-packages="\usetikzlibrary{arrows}"}</span></span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a><span class="in">%%| filename: ../figure-tikz/fig-tikz-01</span></span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{tikzpicture}[scale=0.85]</span></span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a><span class="in"> \tikzstyle{quadri}=[circle,draw,text=black, thick]</span></span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a><span class="in"> \tikzstyle{estun}=[-&gt;,&gt;=latex,very thick]</span></span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R1) at (0,3) {$R_1$};</span></span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R2) at (-2,1) {$R_2$};</span></span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R3) at (0,1) {$R_3$};</span></span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R4) at (2,1) {$R_4$};</span></span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R5) at (0,-1) {$R_5$};</span></span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R6) at (1.5,-1) {$R_6$};</span></span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R7) at (2.5,-1) {$R_7$};</span></span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R8) at (4,3) {$R_8$};</span></span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R9) at (4,1) {$R_9$};</span></span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R1)--(R2);</span></span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R1)--(R3);</span></span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R1)--(R4);</span></span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R3)--(R5);</span></span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R4)--(R6);</span></span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R4)--(R7);</span></span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R8)--(R9);</span></span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a><span class="in">\end{tikzpicture}</span></span>
<span id="cb3-202"><a href="#cb3-202" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-203"><a href="#cb3-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-204"><a href="#cb3-204" aria-hidden="true" tabindex="-1"></a>The regions of @exm-toy-forest.</span>
<span id="cb3-205"><a href="#cb3-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-206"><a href="#cb3-206" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-207"><a href="#cb3-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-208"><a href="#cb3-208" aria-hidden="true" tabindex="-1"></a>Another tool of @MR4178188 that will be used is its Lemma 2, that is the identification of $\Rfam$ with a set $\mathcal C\subset \left<span class="sc">\{</span>(i,j)\in \left({\mathbb N_N}^*\right)^2 \: : i\leq j\right\}$ such that for $(i,j), (i',j')\in\mathcal C$, $\{i,\dotsc, j\}\cap\{i',\dotsc,j'\}\in\left\{\varnothing, \{i,\dotsc, j\},\{i',\dotsc j'\}  \right\}$. With this identification, each $R_k=R_{(i,j)}$ can be written as $P_{i:j}=\bigcup_{i\leq n\leq j}P_n$ where $(P_n)_{1\leq n \leq N}$ is a partition of $\Nm^*$. The $P_n$'s were called atoms in @MR4178188 because they have the thinnest granularity in the structure, but to continue the analogy with graphs, forests and trees, they can also be called leafs. See @exm-toy-leaves for a concrete example.</span>
<span id="cb3-209"><a href="#cb3-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-210"><a href="#cb3-210" aria-hidden="true" tabindex="-1"></a>::: {#exm-toy-leaves}</span>
<span id="cb3-211"><a href="#cb3-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-212"><a href="#cb3-212" aria-hidden="true" tabindex="-1"></a><span class="fu">## Continuation of @exm-toy-forest</span></span>
<span id="cb3-213"><a href="#cb3-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-214"><a href="#cb3-214" aria-hidden="true" tabindex="-1"></a>For the reference family given in @exm-toy-forest, a partition of atoms is given by $P_1 =R_2$, $P_2  =   R_3\setminus R_5$, $P_3  =   R_5$, $P_4=R_6$, $P_5=R_7$, $P_6=R_8\setminus R_9$, $P_7=R_9$, $P_8=\Nm^* \setminus <span class="sc">\{</span>R_1 \cup R_8 <span class="sc">\}</span>$. Then $R_1=P_{1:5}$, $R_3=P_{2:3}$, $R_4=P_{4:5}$ and $R_8=P_{6:7}$. Note that not all atoms are regions of the family. Those new labels are graphically depicted in @fig-leaves-exm. The nodes that correspond to atoms that are not in the family are depicted with a dashed circle, and all atoms are depicted in gray. This is the same example as Example 3 of @MR4178188.</span>
<span id="cb3-215"><a href="#cb3-215" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-216"><a href="#cb3-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-217"><a href="#cb3-217" aria-hidden="true" tabindex="-1"></a>:::{#fig-leaves-exm}</span>
<span id="cb3-218"><a href="#cb3-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-219"><a href="#cb3-219" aria-hidden="true" tabindex="-1"></a><span class="in">``` {.tikz opt-additional-packages="\usetikzlibrary{arrows}"}</span></span>
<span id="cb3-220"><a href="#cb3-220" aria-hidden="true" tabindex="-1"></a><span class="in">%%| filename: ../figure-tikz/fig-tikz-02</span></span>
<span id="cb3-221"><a href="#cb3-221" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{tikzpicture}[scale=0.85]</span></span>
<span id="cb3-222"><a href="#cb3-222" aria-hidden="true" tabindex="-1"></a><span class="in"> \tikzstyle{quadri}=[circle,draw,text=black,thick]</span></span>
<span id="cb3-223"><a href="#cb3-223" aria-hidden="true" tabindex="-1"></a><span class="in"> \tikzstyle{estun}=[-&gt;,&gt;=latex,very thick]</span></span>
<span id="cb3-224"><a href="#cb3-224" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R1) at (0,3) {$P_{1:5}$};</span></span>
<span id="cb3-225"><a href="#cb3-225" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri, fill=gray!25] (R2) at (-2,1) {$P_1$};</span></span>
<span id="cb3-226"><a href="#cb3-226" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R3) at (0,1) {$P_{2:3}$};</span></span>
<span id="cb3-227"><a href="#cb3-227" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R4) at (2,1) {$P_{4:5}$};</span></span>
<span id="cb3-228"><a href="#cb3-228" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri, dashed,fill=gray!25] (P2) at (-0.5,-1) {$P_2$};</span></span>
<span id="cb3-229"><a href="#cb3-229" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri,fill=gray!25] (R5) at (0.5,-1) {$P_3$};</span></span>
<span id="cb3-230"><a href="#cb3-230" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri,fill=gray!25] (R6) at (1.5,-1) {$P_4$};</span></span>
<span id="cb3-231"><a href="#cb3-231" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri,fill=gray!25] (R7) at (2.5,-1) {$P_5$};</span></span>
<span id="cb3-232"><a href="#cb3-232" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri] (R8) at (4,3) {$P_{6:7}$};</span></span>
<span id="cb3-233"><a href="#cb3-233" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri,dashed,fill=gray!25] (P6) at (3.5,1) {$P_6$};</span></span>
<span id="cb3-234"><a href="#cb3-234" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri,fill=gray!25] (R9) at (4.5,1) {$P_7$};</span></span>
<span id="cb3-235"><a href="#cb3-235" aria-hidden="true" tabindex="-1"></a><span class="in"> \node[quadri,dashed,fill=gray!25] (P8) at (6,3) {$P_8$};</span></span>
<span id="cb3-236"><a href="#cb3-236" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R1)--(R2);</span></span>
<span id="cb3-237"><a href="#cb3-237" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R1)--(R3);</span></span>
<span id="cb3-238"><a href="#cb3-238" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R1)--(R4);</span></span>
<span id="cb3-239"><a href="#cb3-239" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R3)--(R5);</span></span>
<span id="cb3-240"><a href="#cb3-240" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun,dashed,thick] (R3)--(P2);</span></span>
<span id="cb3-241"><a href="#cb3-241" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R4)--(R6);</span></span>
<span id="cb3-242"><a href="#cb3-242" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R4)--(R7);</span></span>
<span id="cb3-243"><a href="#cb3-243" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun] (R8)--(R9);</span></span>
<span id="cb3-244"><a href="#cb3-244" aria-hidden="true" tabindex="-1"></a><span class="in"> \draw[estun,dashed,thick] (R8)--(P6);</span></span>
<span id="cb3-245"><a href="#cb3-245" aria-hidden="true" tabindex="-1"></a><span class="in">\end{tikzpicture}</span></span>
<span id="cb3-246"><a href="#cb3-246" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-247"><a href="#cb3-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-248"><a href="#cb3-248" aria-hidden="true" tabindex="-1"></a>The regions of @exm-toy-forest but with the labels of @exm-toy-leaves.</span>
<span id="cb3-249"><a href="#cb3-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-250"><a href="#cb3-250" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-251"><a href="#cb3-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-252"><a href="#cb3-252" aria-hidden="true" tabindex="-1"></a>When all leaves are regions of the family, it is said that the family is complete. If this is not the case, the family can easily be completed by adding the missing leaves (and using their cardinality as associated $\zeta$) without changing the value $\Vstar$. See Definition 2, Lemma 6 and Algorithm 2 of @MR4178188 for the details.</span>
<span id="cb3-253"><a href="#cb3-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-254"><a href="#cb3-254" aria-hidden="true" tabindex="-1"></a>@MR4178188 also proved in their Theorem 1 that: </span>
<span id="cb3-255"><a href="#cb3-255" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-256"><a href="#cb3-256" aria-hidden="true" tabindex="-1"></a>V^*_{\Rfam}(S)=\min_{Q\subseteq\cK}\left(\sum_{k'\in Q}\zeta_{k'}\wedge|S\cap R_{k'}|+\left| S\setminus\bigcup_{k'\in Q} R_{k'}   \right|\right)</span>
<span id="cb3-257"><a href="#cb3-257" aria-hidden="true" tabindex="-1"></a>\label{eq_vstar_Q} </span>
<span id="cb3-258"><a href="#cb3-258" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-259"><a href="#cb3-259" aria-hidden="true" tabindex="-1"></a>and, even better, in their Corollary 1 *(iii)* that:</span>
<span id="cb3-260"><a href="#cb3-260" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-261"><a href="#cb3-261" aria-hidden="true" tabindex="-1"></a>\Vstar(S) = \min_{Q\in \mathfrak P}\sum_{k'\in Q}\zeta_{k'}\wedge|S\cap R_{k'}|,</span>
<span id="cb3-262"><a href="#cb3-262" aria-hidden="true" tabindex="-1"></a>\label{eq_vstar_Qpartition}</span>
<span id="cb3-263"><a href="#cb3-263" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-264"><a href="#cb3-264" aria-hidden="true" tabindex="-1"></a>provided that the family is complete. Here, $\mathfrak P \subseteq \mathcal P(\cK)$ is the set of subsets of $\cK$ that realize a partition, that is, the set of $Q\subseteq\cK$ such that the $R_k$, $k\in Q$, form a partition of $\Nm^*$. So the minimum in Equation \eqref{eq_vstar_Qpartition} is over way less elements than in Equation \eqref{eq_vstar_Q}.</span>
<span id="cb3-265"><a href="#cb3-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-266"><a href="#cb3-266" aria-hidden="true" tabindex="-1"></a>Finally, that paper provides a polynomial algorithm to $V^*_{\Rfam}(S)$ for a single $S\subseteq\Nm^*$, which we reproduce here in @alg-vstar. The family is assumed complete, otherwise the first step would be to complete it. In the original paper, $\cK^h$ used to designate the elements of $\cK$ at depth $h$ plus the atoms at depth $\leq h$. Actually one can realize that the last assumption is not needed for this algorithm to perform exactly the same, with the added benefit of not repeating computations at the atoms that don't have the maximal depth. The only change is that sometimes $Succ_k$ can be empty, in which case we simply let $newVec_k=\zeta_k\wedge|S\cap R_k|$. Thus, here in this paper, we define $\cK^h$ as only the elements of $\cK$ at depth $h$ (the previous intricate definition may still be necessary for the proof of Theorem 1 of @MR4178188): $\cK^h=<span class="sc">\{</span> (i,j)\in\cK : \phi(i,j)=h      <span class="sc">\}</span>, \:\:\:h\geq 1.$ This is the only deviation from the notation of @MR4178188. Finally note that in the ongoing analogy with graph theory, the elements of $\cK^1$ are the roots of the different trees making up the forest.</span>
<span id="cb3-267"><a href="#cb3-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-268"><a href="#cb3-268" aria-hidden="true" tabindex="-1"></a>::: {.content-visible when-format="html"}</span>
<span id="cb3-269"><a href="#cb3-269" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb3-270"><a href="#cb3-270" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-vstar</span></span>
<span id="cb3-271"><a href="#cb3-271" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb3-272"><a href="#cb3-272" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb3-273"><a href="#cb3-273" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb3-274"><a href="#cb3-274" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb3-275"><a href="#cb3-275" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb3-276"><a href="#cb3-276" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb3-277"><a href="#cb3-277" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb3-278"><a href="#cb3-278" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb3-279"><a href="#cb3-279" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Computation of a given $V^*_{\mathfrak{R}}(S)$}</span></span>
<span id="cb3-280"><a href="#cb3-280" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb3-281"><a href="#cb3-281" aria-hidden="true" tabindex="-1"></a><span class="in">\Procedure{Vstar}{S, $\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete}</span></span>
<span id="cb3-282"><a href="#cb3-282" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $ H \gets \max_{k\in\mathcal{K}} \phi(k)  $ \Comment{maximum depth}</span></span>
<span id="cb3-283"><a href="#cb3-283" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$h = H-1, \dotsc, 1$}</span></span>
<span id="cb3-284"><a href="#cb3-284" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h  \}$</span></span>
<span id="cb3-285"><a href="#cb3-285" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $newVec\gets (0)_{k \in  \mathcal{K}^h}$</span></span>
<span id="cb3-286"><a href="#cb3-286" aria-hidden="true" tabindex="-1"></a><span class="in">    \For{$k \in  \mathcal{K}^h$}</span></span>
<span id="cb3-287"><a href="#cb3-287" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $Succ_k \gets \{ k' \in  \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$</span></span>
<span id="cb3-288"><a href="#cb3-288" aria-hidden="true" tabindex="-1"></a><span class="in">      \If{$Succ_k=\varnothing$}</span></span>
<span id="cb3-289"><a href="#cb3-289" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $newVec_k \gets \zeta_k\wedge|S\cap R_k|$</span></span>
<span id="cb3-290"><a href="#cb3-290" aria-hidden="true" tabindex="-1"></a><span class="in">      \Else</span></span>
<span id="cb3-291"><a href="#cb3-291" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $newVec_k \gets \min\left( \zeta_{k}\wedge|S\cap R_k| ,  \sum_{k'\in Succ_k} Vec_{k'}   \right)$</span></span>
<span id="cb3-292"><a href="#cb3-292" aria-hidden="true" tabindex="-1"></a><span class="in">      \EndIf</span></span>
<span id="cb3-293"><a href="#cb3-293" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndFor</span></span>
<span id="cb3-294"><a href="#cb3-294" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $Vec\gets newVec$</span></span>
<span id="cb3-295"><a href="#cb3-295" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb3-296"><a href="#cb3-296" aria-hidden="true" tabindex="-1"></a><span class="in">  \Return $\sum_{k\in\mathcal{K}^1} Vec_k  $</span></span>
<span id="cb3-297"><a href="#cb3-297" aria-hidden="true" tabindex="-1"></a><span class="in">\EndProcedure</span></span>
<span id="cb3-298"><a href="#cb3-298" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb3-299"><a href="#cb3-299" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb3-300"><a href="#cb3-300" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-301"><a href="#cb3-301" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-302"><a href="#cb3-302" aria-hidden="true" tabindex="-1"></a>::: {.content-hidden when-format="html"}</span>
<span id="cb3-303"><a href="#cb3-303" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb3-304"><a href="#cb3-304" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-vstar</span></span>
<span id="cb3-305"><a href="#cb3-305" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb3-306"><a href="#cb3-306" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb3-307"><a href="#cb3-307" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb3-308"><a href="#cb3-308" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb3-309"><a href="#cb3-309" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb3-310"><a href="#cb3-310" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb3-311"><a href="#cb3-311" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb3-312"><a href="#cb3-312" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb3-313"><a href="#cb3-313" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Computation of a given $V^*_{\mathfrak{R}}(S)$}</span></span>
<span id="cb3-314"><a href="#cb3-314" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb3-315"><a href="#cb3-315" aria-hidden="true" tabindex="-1"></a><span class="in">\Procedure{Vstar}{S, $\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete}</span></span>
<span id="cb3-316"><a href="#cb3-316" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $ H \gets \max_{k\in\mathcal{K}} \phi(k)  $ \Comment{maximum depth}</span></span>
<span id="cb3-317"><a href="#cb3-317" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$h = H-1, \dotsc, 1$}</span></span>
<span id="cb3-318"><a href="#cb3-318" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h  \}$</span></span>
<span id="cb3-319"><a href="#cb3-319" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $newVec\gets (0)_{k \in  \mathcal{K}^h}$</span></span>
<span id="cb3-320"><a href="#cb3-320" aria-hidden="true" tabindex="-1"></a><span class="in">    \For{$k \in  \mathcal{K}^h$}</span></span>
<span id="cb3-321"><a href="#cb3-321" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $Succ_k \gets \{ k' \in  \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$</span></span>
<span id="cb3-322"><a href="#cb3-322" aria-hidden="true" tabindex="-1"></a><span class="in">      \If{$Succ_k=\varnothing$}</span></span>
<span id="cb3-323"><a href="#cb3-323" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $newVec_k \gets \zeta_k\wedge|S\cap R_k|$</span></span>
<span id="cb3-324"><a href="#cb3-324" aria-hidden="true" tabindex="-1"></a><span class="in">      \Else</span></span>
<span id="cb3-325"><a href="#cb3-325" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $newVec_k \gets \min\left( \zeta_{k}\wedge|S\cap R_k| ,  \sum_{k'\in Succ_k} Vec_{k'}   \right)$</span></span>
<span id="cb3-326"><a href="#cb3-326" aria-hidden="true" tabindex="-1"></a><span class="in">      \EndIf</span></span>
<span id="cb3-327"><a href="#cb3-327" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndFor</span></span>
<span id="cb3-328"><a href="#cb3-328" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $Vec\gets newVec$</span></span>
<span id="cb3-329"><a href="#cb3-329" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb3-330"><a href="#cb3-330" aria-hidden="true" tabindex="-1"></a><span class="in">  \State\Return $\sum_{k\in\mathcal{K}^1} Vec_k  $</span></span>
<span id="cb3-331"><a href="#cb3-331" aria-hidden="true" tabindex="-1"></a><span class="in">\EndProcedure</span></span>
<span id="cb3-332"><a href="#cb3-332" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb3-333"><a href="#cb3-333" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb3-334"><a href="#cb3-334" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-335"><a href="#cb3-335" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-336"><a href="#cb3-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-337"><a href="#cb3-337" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb3-338"><a href="#cb3-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-339"><a href="#cb3-339" aria-hidden="true" tabindex="-1"></a>In the practical implementation of this algorithm (and of the following @alg-pruning), $Vec$ and $newVec$ are always of size $N$ (the number of leaves) instead of the cardinality of $\cK^h$. And the sum $\sum_{k'\in Succ_k} Vec_{k'}$ is really easy to compute: if $R_k= R_{(i_0,i_{p}-1)}= \bigcup_{ j=1}^{p} R_{(i_{ j-1}, i_{ j}-1)}=\bigcup_{i_0\leq n\leq i_{p}-1}P_n\in\cK^h$ for some $p\geq2$, a strictly increasing sequence $(i_0,\dotsc,i_{p})$ and $R_{(i_{ j-1}, i_{ j}-1)}\in\cK^{h+1}$ for all $1\leq j\leq p$, then we simply sum $Vec$ over the indices from $i_{0}$ to $i_{p}-1$. After that, the computed quantity is set in $newVec$ at index $i_0$. So actually computing $Succ_k$ is not needed and not done.</span>
<span id="cb3-340"><a href="#cb3-340" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-341"><a href="#cb3-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-342"><a href="#cb3-342" aria-hidden="true" tabindex="-1"></a>The computation time of the algorithm is in $O(m|\cK|)$, which is fast for a single evaluation, but calling it repeatedly on a path of selection sets $(S_t)_{t\in\Nm^*}$ has complexity $O(m^2|\cK|)$ which is not desirable and makes computations difficult in practice, hence the need for a new, faster algorithm.</span>
<span id="cb3-343"><a href="#cb3-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-344"><a href="#cb3-344" aria-hidden="true" tabindex="-1"></a>::: {#rem-zeta}</span>
<span id="cb3-345"><a href="#cb3-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-346"><a href="#cb3-346" aria-hidden="true" tabindex="-1"></a>The specific computation of the $R_k$'s and the $\zeta_k$'s such that Equation \eqref{eq_jer_control} holds is outside the scope of the present paper, but different constructions can be found in @MR4124323, @MR4178188 or @blain22notip for example.</span>
<span id="cb3-347"><a href="#cb3-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-348"><a href="#cb3-348" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-349"><a href="#cb3-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-350"><a href="#cb3-350" aria-hidden="true" tabindex="-1"></a><span class="fu"># New algorithms</span></span>
<span id="cb3-351"><a href="#cb3-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-352"><a href="#cb3-352" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pruning the forest {#sec-pruning}</span></span>
<span id="cb3-353"><a href="#cb3-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-354"><a href="#cb3-354" aria-hidden="true" tabindex="-1"></a>We remark the simple fact that if, for example, $(1,1), (2,2), (1,2)\in\cK$, and $\zeta_{(1,2)}\geq \zeta_{(1,1)}+\zeta_{(2,2)}$, then $R_{(1,2)}$ never contributes to the computation of any $\Vstar(S)$ and it could just be removed from $\Rfam$. We now formalize and prove this pruning scheme.</span>
<span id="cb3-355"><a href="#cb3-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-356"><a href="#cb3-356" aria-hidden="true" tabindex="-1"></a>::: {#def-pruning}</span>
<span id="cb3-357"><a href="#cb3-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-358"><a href="#cb3-358" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pruning</span></span>
<span id="cb3-359"><a href="#cb3-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-360"><a href="#cb3-360" aria-hidden="true" tabindex="-1"></a>We define by $\cK^{\pr}$ ($\cK$ pruned) the set of elements of $\cK$ such that we removed all $(i,i')$ such that there exists $p\geq2$ and integers $i_1,\dotsc,i_{p-1}$ such that, when setting $i_0=i$ and $i_{p}=i'+1$, the sequence $(i_0,\dotsc,i_{p})$ is strictly increasing, $(i_{j-1},i_{j}-1)\in\cK$ for all $1\leq j\leq p$ and finally $\zeta_{(i,i')}=\zeta_{(i_0,i_{p}-1)}\geq \sum_{j=1}^{p} \zeta_{(i_{j-1}, i_{j}-1)}$.</span>
<span id="cb3-361"><a href="#cb3-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-362"><a href="#cb3-362" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-363"><a href="#cb3-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-364"><a href="#cb3-364" aria-hidden="true" tabindex="-1"></a>An important note is that for a removed $(i,i')\in\cK\setminus\cK^{\pr}$, we can always choose the indices $i_1,\dotsc,i_{p-1}$ such that actually $(i_j,i_{j+1}-1)\in\cK^{\pr}$ and not only $\cK$, because if  $(i_j,i_{j+1}-1)\in\cK\setminus\cK^{\pr}$ it can itself be fragmented, and this decreasing recursion eventually ends (the later possible being at the atoms of the forest structure). Also note that removing elements from $\cK$ does not alter the fact that we have at hand a forest structure, that is, the reference family defined by $\Rfam^{\pr}=(R_k,\zeta_k)_{k\in\cK^{\pr}}$ has a forest structure. Because pruning a forest structure does not touch the atoms, note finally that if $\cK$ is complete then so is $\cK^{\pr}$.</span>
<span id="cb3-365"><a href="#cb3-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-366"><a href="#cb3-366" aria-hidden="true" tabindex="-1"></a>The following proposition states that pruning the forest does not alter the bound.</span>
<span id="cb3-367"><a href="#cb3-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-368"><a href="#cb3-368" aria-hidden="true" tabindex="-1"></a>::: {#prp-pruning}</span>
<span id="cb3-369"><a href="#cb3-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-370"><a href="#cb3-370" aria-hidden="true" tabindex="-1"></a>For any $S\subseteq \Nm^*$, $\Vstar(S)=V^*_{\Rfam^{\pr}}(S)$.</span>
<span id="cb3-371"><a href="#cb3-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-372"><a href="#cb3-372" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-373"><a href="#cb3-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-374"><a href="#cb3-374" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb3-375"><a href="#cb3-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-376"><a href="#cb3-376" aria-hidden="true" tabindex="-1"></a>Recall Equation \eqref{eq_vstar_Q} and, because $\Rfam^{\pr}$ also has a forest structure,</span>
<span id="cb3-377"><a href="#cb3-377" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-378"><a href="#cb3-378" aria-hidden="true" tabindex="-1"></a>V^*_{\Rfam^{\pr}}(S)=\min_{Q\subseteq\cK^{\pr}}\left(\sum_{k'\in Q}\zeta_{k'}\wedge|S\cap R_{k'}|+\left| S\setminus\bigcup_{k'\in Q} R_{k'}   \right|\right),</span>
<span id="cb3-379"><a href="#cb3-379" aria-hidden="true" tabindex="-1"></a>\label{eq_vstarpruned_Q}</span>
<span id="cb3-380"><a href="#cb3-380" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-381"><a href="#cb3-381" aria-hidden="true" tabindex="-1"></a>so we immediately get that $\Vstar(S)\leq V^*_{\Rfam^{\pr}}(S)$. </span>
<span id="cb3-382"><a href="#cb3-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-383"><a href="#cb3-383" aria-hidden="true" tabindex="-1"></a>Let any $Q\subseteq \cK$. We split $Q$ in $A$ elements of $\cK\setminus\cK^{\pr}$, denoted $(i_{0,a}, i_{p_a,a}-1)$, $1\leq a\leq A$ for some $p_a\geq2$, and $B$ elements of $\cK^{\pr}$, simply denoted $k_b$, $1\leq b\leq B$. By the definition of $\cK^{\pr}$ and the previous remarks, for any $1\leq a \leq A$, there exist integers $i_{1,a},\dotsc,i_{p_a-1,a}$ such that $i_{0,a}&lt;i_{1,a}&lt;\dotsb&lt;i_{p_a-1,a} &lt; i_{p_a,a}$, $(i_{j-1,a},i_{j,a}-1)\in\cK^{\pr}$ for all $1\leq j\leq p_a$, and $\zeta_{(i_{0,a}, i_{p_a,a}-1)}\geq \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)}$. Now let</span>
<span id="cb3-384"><a href="#cb3-384" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-385"><a href="#cb3-385" aria-hidden="true" tabindex="-1"></a>Q^{\pr}=<span class="sc">\{</span>k_b : 1\leq b\leq B <span class="sc">\}</span> \cup <span class="sc">\{</span> (i_{j-1,a},i_{j,a}-1) :  1\leq a\leq A, 1\leq j\leq p_a  <span class="sc">\}</span>.</span>
<span id="cb3-386"><a href="#cb3-386" aria-hidden="true" tabindex="-1"></a>\label{eq_Qpr}</span>
<span id="cb3-387"><a href="#cb3-387" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-388"><a href="#cb3-388" aria-hidden="true" tabindex="-1"></a>We have that $Q^{\pr}\subseteq \cK^{\pr}$ and $\bigcup_{k\in Q}R_k=\bigcup_{k\in Q^{\pr}}R_k$. Then,</span>
<span id="cb3-389"><a href="#cb3-389" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-390"><a href="#cb3-390" aria-hidden="true" tabindex="-1"></a>\sum_{k\in Q}\zeta_k\wedge|S\cap R_k|+\left| S\setminus\bigcup_{k\in Q} R_k   \right|&amp;=\sum_{b=1}^B\zeta_{k_b}\wedge|S\cap R_{k_b}| <span class="sc">\\</span></span>
<span id="cb3-391"><a href="#cb3-391" aria-hidden="true" tabindex="-1"></a>&amp;\qquad+\sum_{a=1}^A\zeta_{(i_{0,a}, i_{p_a,a}-1)}\wedge |S\cap R_{(i_{0,a}, i_{p_a,a}-1)}| <span class="sc">\\</span></span>
<span id="cb3-392"><a href="#cb3-392" aria-hidden="true" tabindex="-1"></a>&amp;\qquad+ \left| S\setminus\bigcup_{k\in Q} R_k   \right|    , </span>
<span id="cb3-393"><a href="#cb3-393" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-394"><a href="#cb3-394" aria-hidden="true" tabindex="-1"></a>but  for all $1\leq a\leq A$,</span>
<span id="cb3-395"><a href="#cb3-395" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-396"><a href="#cb3-396" aria-hidden="true" tabindex="-1"></a>\zeta_{(i_{0,a}, i_{p_a,a}-1)}&amp;\geq  \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} <span class="sc">\\</span></span>
<span id="cb3-397"><a href="#cb3-397" aria-hidden="true" tabindex="-1"></a>&amp;\geq   \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} \wedge |S\cap R_{(i_{j-1,a}, i_{j,a}-1)}| ,</span>
<span id="cb3-398"><a href="#cb3-398" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-399"><a href="#cb3-399" aria-hidden="true" tabindex="-1"></a>so the term $\sum_{a=1}^A\zeta_{(i_{0,a}, i_{p_a,a}-1)}\wedge |S\cap R_{(i_{0,a}, i_{p_a,a}-1)}|$ is greater than or equal to </span>
<span id="cb3-400"><a href="#cb3-400" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb3-401"><a href="#cb3-401" aria-hidden="true" tabindex="-1"></a>\sum_{a=1}^A\left(  \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} \wedge |S\cap R_{(i_{j-1,a}, i_{j,a}-1)}| \right)\wedge |S\cap R_{(i_{0,a}, i_{p_a,a}-1)}| ,</span>
<span id="cb3-402"><a href="#cb3-402" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb3-403"><a href="#cb3-403" aria-hidden="true" tabindex="-1"></a> which is simply equal to</span>
<span id="cb3-404"><a href="#cb3-404" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb3-405"><a href="#cb3-405" aria-hidden="true" tabindex="-1"></a> \sum_{a=1}^A  \sum_{j=1}^{p_a}\zeta_{(i_{j-1,a},i_{j,a}-1)} \wedge |S\cap R_{(i_{j-1,a}, i_{j,a}-1)}|.</span>
<span id="cb3-406"><a href="#cb3-406" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb3-407"><a href="#cb3-407" aria-hidden="true" tabindex="-1"></a>Furthermore $\left|S\setminus\bigcup_{k\in Q} R_k\right|= \left|S\setminus\bigcup_{k\in Q^{\pr}} R_k\right|$ so finally:</span>
<span id="cb3-408"><a href="#cb3-408" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb3-409"><a href="#cb3-409" aria-hidden="true" tabindex="-1"></a>\sum_{k\in Q}\zeta_k\wedge|S\cap R_k|+\left| S\setminus\bigcup_{k\in Q} R_k   \right| &amp;\geq \sum_{k\in Q^{\pr}}\zeta_k\wedge|S\cap R_k|+\left| S\setminus\bigcup_{k\in Q^{\pr}} R_k   \right|   \label{pruning_ineq}<span class="sc">\\</span></span>
<span id="cb3-410"><a href="#cb3-410" aria-hidden="true" tabindex="-1"></a>&amp;\geq V^*_{\Rfam^{\pr}}(S). \notag</span>
<span id="cb3-411"><a href="#cb3-411" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb3-412"><a href="#cb3-412" aria-hidden="true" tabindex="-1"></a>Note that Equation \eqref{pruning_ineq} is true even if there are some $b\in<span class="sc">\{</span> 1,\dotsc,B<span class="sc">\}</span>, a\in<span class="sc">\{</span> 1,\dotsc,A<span class="sc">\}</span>, j\in<span class="sc">\{</span> 1,\dotsc,p_a<span class="sc">\}</span>$ such that $k_b=(i_{j-1,a}, i_{j,a}-1)$.</span>
<span id="cb3-413"><a href="#cb3-413" aria-hidden="true" tabindex="-1"></a>We minimize over all $Q$ to get that $\Vstar(S)\geq V^*_{\Rfam^{\pr}}(S)$. $\square$</span>
<span id="cb3-414"><a href="#cb3-414" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-415"><a href="#cb3-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-416"><a href="#cb3-416" aria-hidden="true" tabindex="-1"></a>This gives a practical way to speed up computations by first pruning the family before computing any $\Vstar(S)$, because $\cK^{\pr}$ is smaller than $\cK$, and by the above Proposition there is no theoretical loss in doing so. </span>
<span id="cb3-417"><a href="#cb3-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-418"><a href="#cb3-418" aria-hidden="true" tabindex="-1"></a>Furthermore, pruning can be done really simply by following @alg-vstar for $S=\Nm^*$, and pruning when appropriate. This gives the following @alg-pruning, assuming, for simplicity, that the family is complete. The computation time of the algorithm is the same as @alg-vstar, that is $O(m|\cK|)$. Note that the only differences between @alg-pruning and @alg-vstar are the pruning step and $\zeta_k$ replacing $\zeta_k\wedge|S\cap R_k|$, because $\zeta_k\leq|R_k|$ and here $S=\Nm^*$, so $\zeta_k\wedge|\Nm^*\cap R_k|=\zeta_k$. Also note that the algorithm returns $\Vstar(\Nm^*)$ as a by-product. The following proposition states that @alg-pruning indeed produces the pruned region as in @def-pruning. </span>
<span id="cb3-419"><a href="#cb3-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-420"><a href="#cb3-420" aria-hidden="true" tabindex="-1"></a>::: {.content-visible when-format="html"}</span>
<span id="cb3-421"><a href="#cb3-421" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb3-422"><a href="#cb3-422" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-pruning</span></span>
<span id="cb3-423"><a href="#cb3-423" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb3-424"><a href="#cb3-424" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb3-425"><a href="#cb3-425" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb3-426"><a href="#cb3-426" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb3-427"><a href="#cb3-427" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb3-428"><a href="#cb3-428" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb3-429"><a href="#cb3-429" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb3-430"><a href="#cb3-430" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb3-431"><a href="#cb3-431" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Pruning of $\mathfrak{R}$}</span></span>
<span id="cb3-432"><a href="#cb3-432" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb3-433"><a href="#cb3-433" aria-hidden="true" tabindex="-1"></a><span class="in">\Procedure{Pruning}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete}</span></span>
<span id="cb3-434"><a href="#cb3-434" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\mathcal{L}\gets\mathcal{K}$</span></span>
<span id="cb3-435"><a href="#cb3-435" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $ H \gets \max_{k\in\mathcal{K}} \phi(k)  $ \Comment{maximum depth}</span></span>
<span id="cb3-436"><a href="#cb3-436" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$h = H-1, \dotsc, 1$}</span></span>
<span id="cb3-437"><a href="#cb3-437" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h  \}$</span></span>
<span id="cb3-438"><a href="#cb3-438" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $newVec\gets (0)_{k \in  \mathcal{K}^h}$</span></span>
<span id="cb3-439"><a href="#cb3-439" aria-hidden="true" tabindex="-1"></a><span class="in">    \For{$k \in  \mathcal{K}^h$}</span></span>
<span id="cb3-440"><a href="#cb3-440" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $Succ_k \gets \{ k' \in  \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$</span></span>
<span id="cb3-441"><a href="#cb3-441" aria-hidden="true" tabindex="-1"></a><span class="in">      \If{$Succ_k=\varnothing$}</span></span>
<span id="cb3-442"><a href="#cb3-442" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $newVec_k \gets \zeta_k$</span></span>
<span id="cb3-443"><a href="#cb3-443" aria-hidden="true" tabindex="-1"></a><span class="in">      \Else</span></span>
<span id="cb3-444"><a href="#cb3-444" aria-hidden="true" tabindex="-1"></a><span class="in">        \If{$\zeta_{k} \geq  \sum_{k'\in Succ_k} Vec_{k'}$}</span></span>
<span id="cb3-445"><a href="#cb3-445" aria-hidden="true" tabindex="-1"></a><span class="in">          \State $\mathcal{L}\gets \mathcal{L}\setminus \{ k \}$ \Comment{pruning of the region indexed by $k$}</span></span>
<span id="cb3-446"><a href="#cb3-446" aria-hidden="true" tabindex="-1"></a><span class="in">        \EndIf</span></span>
<span id="cb3-447"><a href="#cb3-447" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $newVec_k \gets \min\left( \zeta_{k} ,  \sum_{k'\in Succ_k} Vec_{k'}   \right)$</span></span>
<span id="cb3-448"><a href="#cb3-448" aria-hidden="true" tabindex="-1"></a><span class="in">      \EndIf</span></span>
<span id="cb3-449"><a href="#cb3-449" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndFor</span></span>
<span id="cb3-450"><a href="#cb3-450" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $Vec\gets newVec$</span></span>
<span id="cb3-451"><a href="#cb3-451" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb3-452"><a href="#cb3-452" aria-hidden="true" tabindex="-1"></a><span class="in">  \Return $(\mathcal{L},\sum_{k\in\mathcal{K}^1} Vec_k  )$</span></span>
<span id="cb3-453"><a href="#cb3-453" aria-hidden="true" tabindex="-1"></a><span class="in">\EndProcedure</span></span>
<span id="cb3-454"><a href="#cb3-454" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb3-455"><a href="#cb3-455" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb3-456"><a href="#cb3-456" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-457"><a href="#cb3-457" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-458"><a href="#cb3-458" aria-hidden="true" tabindex="-1"></a>::: {.content-hidden when-format="html"}</span>
<span id="cb3-459"><a href="#cb3-459" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb3-460"><a href="#cb3-460" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-pruning</span></span>
<span id="cb3-461"><a href="#cb3-461" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb3-462"><a href="#cb3-462" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb3-463"><a href="#cb3-463" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb3-464"><a href="#cb3-464" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb3-465"><a href="#cb3-465" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb3-466"><a href="#cb3-466" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb3-467"><a href="#cb3-467" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb3-468"><a href="#cb3-468" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb3-469"><a href="#cb3-469" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Pruning of $\mathfrak{R}$}</span></span>
<span id="cb3-470"><a href="#cb3-470" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb3-471"><a href="#cb3-471" aria-hidden="true" tabindex="-1"></a><span class="in">\Procedure{Pruning}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete}</span></span>
<span id="cb3-472"><a href="#cb3-472" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\mathcal{L}\gets\mathcal{K}$</span></span>
<span id="cb3-473"><a href="#cb3-473" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $ H \gets \max_{k\in\mathcal{K}} \phi(k)  $ \Comment{maximum depth}</span></span>
<span id="cb3-474"><a href="#cb3-474" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$h = H-1, \dotsc, 1$}</span></span>
<span id="cb3-475"><a href="#cb3-475" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h  \}$</span></span>
<span id="cb3-476"><a href="#cb3-476" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $newVec\gets (0)_{k \in  \mathcal{K}^h}$</span></span>
<span id="cb3-477"><a href="#cb3-477" aria-hidden="true" tabindex="-1"></a><span class="in">    \For{$k \in  \mathcal{K}^h$}</span></span>
<span id="cb3-478"><a href="#cb3-478" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $Succ_k \gets \{ k' \in  \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$</span></span>
<span id="cb3-479"><a href="#cb3-479" aria-hidden="true" tabindex="-1"></a><span class="in">      \If{$Succ_k=\varnothing$}</span></span>
<span id="cb3-480"><a href="#cb3-480" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $newVec_k \gets \zeta_k$</span></span>
<span id="cb3-481"><a href="#cb3-481" aria-hidden="true" tabindex="-1"></a><span class="in">      \Else</span></span>
<span id="cb3-482"><a href="#cb3-482" aria-hidden="true" tabindex="-1"></a><span class="in">        \If{$\zeta_{k} \geq  \sum_{k'\in Succ_k} Vec_{k'}$}</span></span>
<span id="cb3-483"><a href="#cb3-483" aria-hidden="true" tabindex="-1"></a><span class="in">          \State $\mathcal{L}\gets \mathcal{L}\setminus \{ k \}$ \Comment{pruning of the region indexed by $k$}</span></span>
<span id="cb3-484"><a href="#cb3-484" aria-hidden="true" tabindex="-1"></a><span class="in">        \EndIf</span></span>
<span id="cb3-485"><a href="#cb3-485" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $newVec_k \gets \min\left( \zeta_{k} ,  \sum_{k'\in Succ_k} Vec_{k'}   \right)$</span></span>
<span id="cb3-486"><a href="#cb3-486" aria-hidden="true" tabindex="-1"></a><span class="in">      \EndIf</span></span>
<span id="cb3-487"><a href="#cb3-487" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndFor</span></span>
<span id="cb3-488"><a href="#cb3-488" aria-hidden="true" tabindex="-1"></a><span class="in">    \State $Vec\gets newVec$</span></span>
<span id="cb3-489"><a href="#cb3-489" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb3-490"><a href="#cb3-490" aria-hidden="true" tabindex="-1"></a><span class="in">  \State\Return $(\mathcal{L},\sum_{k\in\mathcal{K}^1} Vec_k  )$</span></span>
<span id="cb3-491"><a href="#cb3-491" aria-hidden="true" tabindex="-1"></a><span class="in">\EndProcedure</span></span>
<span id="cb3-492"><a href="#cb3-492" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb3-493"><a href="#cb3-493" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb3-494"><a href="#cb3-494" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-495"><a href="#cb3-495" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-496"><a href="#cb3-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-497"><a href="#cb3-497" aria-hidden="true" tabindex="-1"></a>::: {#prp-pruning-correct}</span>
<span id="cb3-498"><a href="#cb3-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-499"><a href="#cb3-499" aria-hidden="true" tabindex="-1"></a>The final $\mathcal{L}$ returned by @alg-pruning is equal to $\cK^{\pr}$: $\mathcal{L}=\cK^{\pr}$.</span>
<span id="cb3-500"><a href="#cb3-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-501"><a href="#cb3-501" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-502"><a href="#cb3-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-503"><a href="#cb3-503" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb3-504"><a href="#cb3-504" aria-hidden="true" tabindex="-1"></a>First, $\cK\setminus\mathcal{L}\subseteq\cK\setminus\cK^{\pr}$ is trivial: a $k$ such that $\zeta_{k} \geq  \sum_{k'\in Succ_k} Vec_{k'}$ obviously satisfies the condition of @def-pruning to be pruned.</span>
<span id="cb3-505"><a href="#cb3-505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-506"><a href="#cb3-506" aria-hidden="true" tabindex="-1"></a>Now let $(i,i')\in \cK\setminus\cK^{\pr}$ an element that is pruned by @def-pruning, so there exists $p\geq2$ and integers $i_1,\dotsc,i_{p-1}$ such that, when setting $i_0=i$ and $i_{p}=i'+1$, the sequence $(i_0,\dotsc,i_{p})$ is strictly increasing, $(i_{j-1},i_{j}-1)\in\cK$ for all $1\leq j\leq p$ and finally $\zeta_{(i,i')}=\zeta_{(i_0,i_{p}-1)}\geq \sum_{j=1}^{p} \zeta_{(i_{j-1}, i_{j}-1)}$. Then by the proof of Theorem 1 of @MR4178188 but applied to $S=R_{(i,i')}$ we have that $\sum_{j=1}^{p} \zeta_{(i_{j-1}, i_{j}-1)}\geq  \sum_{k'\in Succ_{(i,i')}} Vec_{k'}$ (see the unnumbered line just above Equation (A4) in that paper) and so $\zeta_{(i,i')}\geq \sum_{k'\in Succ_{(i,i')}} Vec_{k'}$ hence $(i,i')$ is pruned by @alg-pruning and $\cK\setminus\cK^{\pr}\subseteq\cK\setminus\mathcal{L}$.</span>
<span id="cb3-507"><a href="#cb3-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-508"><a href="#cb3-508" aria-hidden="true" tabindex="-1"></a>In the end, $\cK\setminus\cK^{\pr}=\cK\setminus\mathcal{L}$ so $\cK^{\pr}=\mathcal{L}$. $\square$</span>
<span id="cb3-509"><a href="#cb3-509" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-510"><a href="#cb3-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-511"><a href="#cb3-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-512"><a href="#cb3-512" aria-hidden="true" tabindex="-1"></a><span class="fu">## Fast algorithm to compute a curve of confidence bounds on a path of selection sets {#sec-fast-curve}</span></span>
<span id="cb3-513"><a href="#cb3-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-514"><a href="#cb3-514" aria-hidden="true" tabindex="-1"></a>Let $(i_1,\dotsc, i_m)$ a permutation of $\Nm^*$, eventually random, and, for all $t\in\Nm^*$, let $S_t=<span class="sc">\{</span>i_1,\dotsc,i_t<span class="sc">\}</span>$ and $S_0=\varnothing$. For example, $(i_1,\dotsc, i_m)$ can be the permutation ordering the $p$-values in increasing order and in that case $S_t$ becomes the set of indices of the $t$ smallest $p$-values. Assume that we want to compute all $\Vstar(S_t)$ for all $t\in<span class="sc">\{</span> 0,\dotsc,m<span class="sc">\}</span>$, this is what we call the curve of confidence bounds indexed by $(i_1,\dotsc, i_m)$. Applying @alg-vstar to compute $\Vstar(S_t)$ for a given $t$ has complexity $O(t|\cK|)$, so using it to sequentially compute the full curve has complexity $O\left(\sum_{t=0}^m t |\cK|\right)=O\left(m^2|\cK|\right)$. In this section, we present a new algorithm that computes the curve with a $O\left(m|\cK|\right)$ complexity. The algorithm will need that $\Rfam$ is complete, so if that is not the case we first need to complete $\Rfam$ following the Algorithm 2 of @MR4178188, which has a $O(m|\cK|)$ complexity. In the remainder of this section we assume that $\Rfam$ is complete.</span>
<span id="cb3-515"><a href="#cb3-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-516"><a href="#cb3-516" aria-hidden="true" tabindex="-1"></a>We first recall and introduce some notation. Recall that $\phi$ is the depth function inside of $\Rfam$, that $\mathfrak P \subseteq \mathcal P(\cK)$ is the set of subsets of $\cK$ that realize a partition, recall the important result stated by Equation \eqref{eq_vstar_Qpartition}, and that $\cK^h=<span class="sc">\{</span> k\in\cK : \phi(k)=h  <span class="sc">\}</span>$ for all $1\leq h\leq H$ where $H=\max_{k\in\cK}\phi(k)$. For any $t\in\Nm^*$ and $1\leq h\leq H$, we denote by $\kth{t}{h}$ the element of $\cK^h$ such that $i_t\in R_{\kth{t}{h}}$ if it exists, and we denote by $h_{\max}(t)$ the highest $h$ such that $\kth{t}{h}$ exists.</span>
<span id="cb3-517"><a href="#cb3-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-518"><a href="#cb3-518" aria-hidden="true" tabindex="-1"></a>::: {#exm-kth}</span>
<span id="cb3-519"><a href="#cb3-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-520"><a href="#cb3-520" aria-hidden="true" tabindex="-1"></a><span class="fu">## Continuation of @exm-toy-forest and @exm-toy-leaves</span></span>
<span id="cb3-521"><a href="#cb3-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-522"><a href="#cb3-522" aria-hidden="true" tabindex="-1"></a>Assume that the reference family of @exm-toy-forest has been labeled as in @exm-toy-leaves and completed. Let $(i_1,\dotsc, i_{25})$ such that $i_1=7$, $i_2=1$ and $i_3=24$. Then for $t=1$, $\kth{t}{1}=(1,5)$, $\kth{t}{2}=(2,3)$, $\kth{t}{3}=(3,3)$ and $h_{\max}(t)=H=3$. For $t=2$, $\kth{t}{1}=(1,5)$, $\kth{t}{2}=(1,1)$, $\kth{t}{3}$ does not exist and $h_{\max}(t)=2$. For $t=3$, $\kth{t}{1}=(8,8)$, $\kth{t}{2}$ does not exist and $h_{\max}(t)=1$.</span>
<span id="cb3-523"><a href="#cb3-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-524"><a href="#cb3-524" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-525"><a href="#cb3-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-526"><a href="#cb3-526" aria-hidden="true" tabindex="-1"></a>Now we can finally present the new algorithm and the proof that it computes the curve $(\Vstar(S_t))_{t\in\Nm}$. We present two versions of the algorithm (strictly equivalent): one very formal (@alg-formal-curve), to introduce additional notation used in the proof, and, later, one that is more akin to @alg-vstar and @alg-pruning, that is, it reuses notation from step to step, for implementation and simplicity purposes (@alg-curve). </span>
<span id="cb3-527"><a href="#cb3-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-528"><a href="#cb3-528" aria-hidden="true" tabindex="-1"></a>::: {.content-visible when-format="html"}</span>
<span id="cb3-529"><a href="#cb3-529" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb3-530"><a href="#cb3-530" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-formal-curve</span></span>
<span id="cb3-531"><a href="#cb3-531" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb3-532"><a href="#cb3-532" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb3-533"><a href="#cb3-533" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb3-534"><a href="#cb3-534" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb3-535"><a href="#cb3-535" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb3-536"><a href="#cb3-536" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb3-537"><a href="#cb3-537" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb3-538"><a href="#cb3-538" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb3-539"><a href="#cb3-539" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Formal computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}</span></span>
<span id="cb3-540"><a href="#cb3-540" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb3-541"><a href="#cb3-541" aria-hidden="true" tabindex="-1"></a><span class="in">\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}</span></span>
<span id="cb3-542"><a href="#cb3-542" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\mathcal{P}^0\gets\{(i,i): 1\leq i \leq n\}$ \Comment{the set of all atoms indices}</span></span>
<span id="cb3-543"><a href="#cb3-543" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\mathcal{K}^-_0\gets\{k\in\mathcal{K} : \zeta_k=0  \}$</span></span>
<span id="cb3-544"><a href="#cb3-544" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\eta^0_k\gets0$ for all $k\in\mathcal{K}$</span></span>
<span id="cb3-545"><a href="#cb3-545" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$t=1,\dotsc, m$}</span></span>
<span id="cb3-546"><a href="#cb3-546" aria-hidden="true" tabindex="-1"></a><span class="in">    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-_{t-1}}R_k$}</span></span>
<span id="cb3-547"><a href="#cb3-547" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$</span></span>
<span id="cb3-548"><a href="#cb3-548" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$</span></span>
<span id="cb3-549"><a href="#cb3-549" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$</span></span>
<span id="cb3-550"><a href="#cb3-550" aria-hidden="true" tabindex="-1"></a><span class="in">    \Else</span></span>
<span id="cb3-551"><a href="#cb3-551" aria-hidden="true" tabindex="-1"></a><span class="in">      \For{$h=1,\dotsc,h_{\max}(t)$}</span></span>
<span id="cb3-552"><a href="#cb3-552" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\eta^t_{k^{(t,h)}}\gets\eta^{t-1}_{k^{(t,h)}} + 1$</span></span>
<span id="cb3-553"><a href="#cb3-553" aria-hidden="true" tabindex="-1"></a><span class="in">        \If{$\eta^t_{k^{(t,h)}}&lt;\zeta_k$}</span></span>
<span id="cb3-554"><a href="#cb3-554" aria-hidden="true" tabindex="-1"></a><span class="in">          \State Pass</span></span>
<span id="cb3-555"><a href="#cb3-555" aria-hidden="true" tabindex="-1"></a><span class="in">        \Else</span></span>
<span id="cb3-556"><a href="#cb3-556" aria-hidden="true" tabindex="-1"></a><span class="in">          \State $h^f_t \gets h$ \Comment{final depth}</span></span>
<span id="cb3-557"><a href="#cb3-557" aria-hidden="true" tabindex="-1"></a><span class="in">          \State $\mathcal{P}^t \gets\left( \mathcal{P}^{t-1}\setminus \{ k\in \mathcal{P}^{t-1} : R_k\subseteq R_{k^{(t,h^f_t)}} \}\right)\cup \{ k^{(t,h^f_t)} \}$</span></span>
<span id="cb3-558"><a href="#cb3-558" aria-hidden="true" tabindex="-1"></a><span class="in">          \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1} \cup \{k^{(t,h^f_t)}\}$</span></span>
<span id="cb3-559"><a href="#cb3-559" aria-hidden="true" tabindex="-1"></a><span class="in">          \State Break the loop</span></span>
<span id="cb3-560"><a href="#cb3-560" aria-hidden="true" tabindex="-1"></a><span class="in">        \EndIf</span></span>
<span id="cb3-561"><a href="#cb3-561" aria-hidden="true" tabindex="-1"></a><span class="in">      \EndFor</span></span>
<span id="cb3-562"><a href="#cb3-562" aria-hidden="true" tabindex="-1"></a><span class="in">      \If{the loop has been broken}</span></span>
<span id="cb3-563"><a href="#cb3-563" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h^f_t   \}$</span></span>
<span id="cb3-564"><a href="#cb3-564" aria-hidden="true" tabindex="-1"></a><span class="in">      \Else</span></span>
<span id="cb3-565"><a href="#cb3-565" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$</span></span>
<span id="cb3-566"><a href="#cb3-566" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$</span></span>
<span id="cb3-567"><a href="#cb3-567" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h_{\max}(t)   \}$</span></span>
<span id="cb3-568"><a href="#cb3-568" aria-hidden="true" tabindex="-1"></a><span class="in">      \EndIf</span></span>
<span id="cb3-569"><a href="#cb3-569" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndIf</span></span>
<span id="cb3-570"><a href="#cb3-570" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb3-571"><a href="#cb3-571" aria-hidden="true" tabindex="-1"></a><span class="in">  \Return $\mathcal{P}^t, \eta^t_k$ for all $t=1,\dotsc, m$ and $k\in\mathcal{K}$</span></span>
<span id="cb3-572"><a href="#cb3-572" aria-hidden="true" tabindex="-1"></a><span class="in">\EndProcedure</span></span>
<span id="cb3-573"><a href="#cb3-573" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb3-574"><a href="#cb3-574" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb3-575"><a href="#cb3-575" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-576"><a href="#cb3-576" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-577"><a href="#cb3-577" aria-hidden="true" tabindex="-1"></a>::: {.content-hidden when-format="html"}</span>
<span id="cb3-578"><a href="#cb3-578" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb3-579"><a href="#cb3-579" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-formal-curve</span></span>
<span id="cb3-580"><a href="#cb3-580" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb3-581"><a href="#cb3-581" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb3-582"><a href="#cb3-582" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb3-583"><a href="#cb3-583" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb3-584"><a href="#cb3-584" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb3-585"><a href="#cb3-585" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb3-586"><a href="#cb3-586" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb3-587"><a href="#cb3-587" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb3-588"><a href="#cb3-588" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Formal computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}</span></span>
<span id="cb3-589"><a href="#cb3-589" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb3-590"><a href="#cb3-590" aria-hidden="true" tabindex="-1"></a><span class="in">\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}</span></span>
<span id="cb3-591"><a href="#cb3-591" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\mathcal{P}^0\gets\{(i,i): 1\leq i \leq n\}$ \Comment{the set of all atoms indices}</span></span>
<span id="cb3-592"><a href="#cb3-592" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\mathcal{K}^-_0\gets\{k\in\mathcal{K} : \zeta_k=0  \}$</span></span>
<span id="cb3-593"><a href="#cb3-593" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\eta^0_k\gets0$ for all $k\in\mathcal{K}$</span></span>
<span id="cb3-594"><a href="#cb3-594" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$t=1,\dotsc, m$}</span></span>
<span id="cb3-595"><a href="#cb3-595" aria-hidden="true" tabindex="-1"></a><span class="in">    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-_{t-1}}R_k$}</span></span>
<span id="cb3-596"><a href="#cb3-596" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$</span></span>
<span id="cb3-597"><a href="#cb3-597" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$</span></span>
<span id="cb3-598"><a href="#cb3-598" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$</span></span>
<span id="cb3-599"><a href="#cb3-599" aria-hidden="true" tabindex="-1"></a><span class="in">    \Else</span></span>
<span id="cb3-600"><a href="#cb3-600" aria-hidden="true" tabindex="-1"></a><span class="in">      \For{$h=1,\dotsc,h_{\max}(t)$}</span></span>
<span id="cb3-601"><a href="#cb3-601" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\eta^t_{k^{(t,h)}}\gets\eta^{t-1}_{k^{(t,h)}} + 1$</span></span>
<span id="cb3-602"><a href="#cb3-602" aria-hidden="true" tabindex="-1"></a><span class="in">        \If{$\eta^t_{k^{(t,h)}}&lt;\zeta_k$}</span></span>
<span id="cb3-603"><a href="#cb3-603" aria-hidden="true" tabindex="-1"></a><span class="in">          \State Pass</span></span>
<span id="cb3-604"><a href="#cb3-604" aria-hidden="true" tabindex="-1"></a><span class="in">        \Else</span></span>
<span id="cb3-605"><a href="#cb3-605" aria-hidden="true" tabindex="-1"></a><span class="in">          \State $h^f_t \gets h$ \Comment{final depth}</span></span>
<span id="cb3-606"><a href="#cb3-606" aria-hidden="true" tabindex="-1"></a><span class="in">          \State $\mathcal{P}^t \gets\left( \mathcal{P}^{t-1}\setminus \{ k\in \mathcal{P}^{t-1} : R_k\subseteq R_{k^{(t,h^f_t)}} \}\right)\cup \{ k^{(t,h^f_t)} \}$</span></span>
<span id="cb3-607"><a href="#cb3-607" aria-hidden="true" tabindex="-1"></a><span class="in">          \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1} \cup \{k^{(t,h^f_t)}\}$</span></span>
<span id="cb3-608"><a href="#cb3-608" aria-hidden="true" tabindex="-1"></a><span class="in">          \State Break the loop</span></span>
<span id="cb3-609"><a href="#cb3-609" aria-hidden="true" tabindex="-1"></a><span class="in">        \EndIf</span></span>
<span id="cb3-610"><a href="#cb3-610" aria-hidden="true" tabindex="-1"></a><span class="in">      \EndFor</span></span>
<span id="cb3-611"><a href="#cb3-611" aria-hidden="true" tabindex="-1"></a><span class="in">      \If{the loop has been broken}</span></span>
<span id="cb3-612"><a href="#cb3-612" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h^f_t   \}$</span></span>
<span id="cb3-613"><a href="#cb3-613" aria-hidden="true" tabindex="-1"></a><span class="in">      \Else</span></span>
<span id="cb3-614"><a href="#cb3-614" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$</span></span>
<span id="cb3-615"><a href="#cb3-615" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$</span></span>
<span id="cb3-616"><a href="#cb3-616" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h_{\max}(t)   \}$</span></span>
<span id="cb3-617"><a href="#cb3-617" aria-hidden="true" tabindex="-1"></a><span class="in">      \EndIf</span></span>
<span id="cb3-618"><a href="#cb3-618" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndIf</span></span>
<span id="cb3-619"><a href="#cb3-619" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb3-620"><a href="#cb3-620" aria-hidden="true" tabindex="-1"></a><span class="in">  \State\Return $\mathcal{P}^t, \eta^t_k$ for all $t=1,\dotsc, m$ and $k\in\mathcal{K}$</span></span>
<span id="cb3-621"><a href="#cb3-621" aria-hidden="true" tabindex="-1"></a><span class="in">\EndProcedure</span></span>
<span id="cb3-622"><a href="#cb3-622" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb3-623"><a href="#cb3-623" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb3-624"><a href="#cb3-624" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-625"><a href="#cb3-625" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-626"><a href="#cb3-626" aria-hidden="true" tabindex="-1"></a>The core idea of the algorithm is that, as we increase $t$ and add new hypotheses in $S_t$, we inflate a counter $\eta_k^t$ for each region $R_k$, by one if $i_t\in R_k$ (line 12), by 0 if not (lines 23 and 27), but only until the counter reaches $\zeta_k$ (line 13). After this point, the hypotheses in $R_k$ don't contribute to $\Vstar(S_t)$, we keep track of those hypotheses with $\cK^-_t$ (line 6), so as soon as $\eta^t_{\kth th}=\zeta_k$ we update $\cK^-_t$ by adding $\kth th$ (line 18) to it and we update $\cP^t$ accordingly (line 17). We will see that $\Vstar(S_t)$ is the sum of the $\eta_k^t$ counters for $k\in\cK^1$. Furthermore, the algorithm provides the partition $\cP^t\in\mathfrak P$ where the minimum in \eqref{eq_vstar_Qpartition} is realized. We formalize all of that in the following Theorem. We first need a final notation. Let</span>
<span id="cb3-627"><a href="#cb3-627" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb3-628"><a href="#cb3-628" aria-hidden="true" tabindex="-1"></a>\cK_t=<span class="sc">\{</span>k\in\cK : \exists k'\in \cP^t : R_{k'}\subseteq R_k   <span class="sc">\}</span>.</span>
<span id="cb3-629"><a href="#cb3-629" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb3-630"><a href="#cb3-630" aria-hidden="true" tabindex="-1"></a>The elements of $\cK_t$ index the regions of the forest that ``are above'' the regions of the current partition-realizing $\cP^t$. In particular, we always have, for any $t\in\Nm$, $\cK^1\subseteq\cK_t$ and $\cP^t\subseteq \cK_t$. We can also remark that the sequence $(\cK_t)_{0\leq t \leq m}$ is non-increasing for the inclusion relation, and that $\cK_0=\cK$.</span>
<span id="cb3-631"><a href="#cb3-631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-632"><a href="#cb3-632" aria-hidden="true" tabindex="-1"></a>::: {#thm-curve-path}</span>
<span id="cb3-633"><a href="#cb3-633" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-634"><a href="#cb3-634" aria-hidden="true" tabindex="-1"></a><span class="fu">## Fast curve computation</span></span>
<span id="cb3-635"><a href="#cb3-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-636"><a href="#cb3-636" aria-hidden="true" tabindex="-1"></a>Let any $t\in\Nm$. Then, $\cP^t\in\mathfrak P$, and for all $k\in\cK_t$, we have</span>
<span id="cb3-637"><a href="#cb3-637" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-638"><a href="#cb3-638" aria-hidden="true" tabindex="-1"></a>\Vstar(S_t\cap R_k) = \eta_k^t</span>
<span id="cb3-639"><a href="#cb3-639" aria-hidden="true" tabindex="-1"></a>\label{eq_vstar_inter_Rk_equal_eta}</span>
<span id="cb3-640"><a href="#cb3-640" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-641"><a href="#cb3-641" aria-hidden="true" tabindex="-1"></a>and</span>
<span id="cb3-642"><a href="#cb3-642" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-643"><a href="#cb3-643" aria-hidden="true" tabindex="-1"></a>\Vstar(S_t\cap R_k) = \sum_{\substack{k'\in \cP^t<span class="sc">\\</span> R_{k'}\subseteq R_k}} \zeta_{k'}\wedge|S_t \cap R_{k'}|.</span>
<span id="cb3-644"><a href="#cb3-644" aria-hidden="true" tabindex="-1"></a>\label{eq_Pt_good_partition}</span>
<span id="cb3-645"><a href="#cb3-645" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-646"><a href="#cb3-646" aria-hidden="true" tabindex="-1"></a>Furthermore,</span>
<span id="cb3-647"><a href="#cb3-647" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-648"><a href="#cb3-648" aria-hidden="true" tabindex="-1"></a>\Vstar(S_t)  = \sum_{{k\in \cP^t}} \zeta_{k}\wedge|S_t \cap R_{k}|= \sum_{k\in\cK^1} \eta_k^t.</span>
<span id="cb3-649"><a href="#cb3-649" aria-hidden="true" tabindex="-1"></a>\label{eq_vstar_equal_sum_eta}</span>
<span id="cb3-650"><a href="#cb3-650" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-651"><a href="#cb3-651" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-652"><a href="#cb3-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-653"><a href="#cb3-653" aria-hidden="true" tabindex="-1"></a>The first equality of Equation \eqref{eq_vstar_equal_sum_eta} confirms that the minimum in \eqref{eq_vstar_Qpartition} is indeed realized on $\cP^t$, and the last equality of the same Equation justifies the simpler @alg-curve to compute the curve on the nested path of selection sets (the $V_t$ notation of @alg-curve is exactly the $\sum_{k\in\cK^1} \eta_k^t$ of @alg-formal-curve).</span>
<span id="cb3-654"><a href="#cb3-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-655"><a href="#cb3-655" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb3-656"><a href="#cb3-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-657"><a href="#cb3-657" aria-hidden="true" tabindex="-1"></a>$\bullet$ Derivation of \eqref{eq_vstar_equal_sum_eta}.</span>
<span id="cb3-658"><a href="#cb3-658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-659"><a href="#cb3-659" aria-hidden="true" tabindex="-1"></a>We first derive \eqref{eq_vstar_equal_sum_eta} from \eqref{eq_vstar_inter_Rk_equal_eta} and \eqref{eq_Pt_good_partition}. First note that for all $Q\in\mathfrak P$, </span>
<span id="cb3-660"><a href="#cb3-660" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-661"><a href="#cb3-661" aria-hidden="true" tabindex="-1"></a>Q=\bigcup_{k\in\cK^1}<span class="sc">\{</span> k' \in Q : R_{k'}\subseteq R_k<span class="sc">\}</span></span>
<span id="cb3-662"><a href="#cb3-662" aria-hidden="true" tabindex="-1"></a>\label{eq_part_K1}</span>
<span id="cb3-663"><a href="#cb3-663" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-664"><a href="#cb3-664" aria-hidden="true" tabindex="-1"></a>and the union is disjoint. From \eqref{eq_vstar_Qpartition}, let $Q^*\in\mathfrak P$ such that $\Vstar(S_t) = \sum_{k'\in Q^*} \zeta_{k'}\wedge |S_t\cap R_{k'}|$. Then by \eqref{eq_part_K1},</span>
<span id="cb3-665"><a href="#cb3-665" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb3-666"><a href="#cb3-666" aria-hidden="true" tabindex="-1"></a>\Vstar(S_t) &amp;= \sum_{k'\in Q^*} \zeta_{k'}\wedge |S_t\cap R_{k'}|\notag<span class="sc">\\</span></span>
<span id="cb3-667"><a href="#cb3-667" aria-hidden="true" tabindex="-1"></a>&amp;=\sum_{k\in\cK^1}  \sum_{\substack{k'\in Q^*<span class="sc">\\</span> R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_t\cap R_{k'}|\notag <span class="sc">\\</span></span>
<span id="cb3-668"><a href="#cb3-668" aria-hidden="true" tabindex="-1"></a>&amp;=\sum_{k\in\cK^1}  \sum_{\substack{k'\in Q^*<span class="sc">\\</span> R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_t\cap (R_{k}\cap R_{k'})| \notag<span class="sc">\\</span></span>
<span id="cb3-669"><a href="#cb3-669" aria-hidden="true" tabindex="-1"></a>&amp;=\sum_{k\in\cK^1}  \sum_{k'\in Q^*} \zeta_{k'}\wedge |(S_t\cap R_{k})\cap R_{k'}| \label{eq_delicate} <span class="sc">\\</span></span>
<span id="cb3-670"><a href="#cb3-670" aria-hidden="true" tabindex="-1"></a>&amp;\geq \sum_{k\in\cK^1} \Vstar(S_t\cap R_k),\label{eq_delicate_vstar}</span>
<span id="cb3-671"><a href="#cb3-671" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb3-672"><a href="#cb3-672" aria-hidden="true" tabindex="-1"></a>where the equality in \eqref{eq_delicate} comes from the fact that if $R_{k'}\not\subseteq R_k$, then $R_{k'}\cap R_k=\varnothing$, that is, $R_{k}\subseteq R_{k'}$ is impossible because $k\in\mathcal K^1$. Furthermore, \eqref{eq_delicate_vstar} holds again by \eqref{eq_vstar_Qpartition}. </span>
<span id="cb3-673"><a href="#cb3-673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-674"><a href="#cb3-674" aria-hidden="true" tabindex="-1"></a>Because $\cK^1\subseteq\cK_t$, by \eqref{eq_Pt_good_partition}, $\Vstar(S_t\cap R_k) = \sum_{\substack{k'\in \cP^t<span class="sc">\\</span> R_{k'}\subseteq R_k}} \zeta_{k'}\wedge|S_t \cap R_{k'}|$ for all $k\in\cK^1$. Then,</span>
<span id="cb3-675"><a href="#cb3-675" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-676"><a href="#cb3-676" aria-hidden="true" tabindex="-1"></a> \sum_{k\in\cK^1} \Vstar(S_t\cap R_k)&amp;=  \sum_{k\in\cK^1}\sum_{\substack{k'\in \cP^t<span class="sc">\\</span> R_{k'}\subseteq R_k}} \zeta_{k'}\wedge|S_t \cap R_{k'}|<span class="sc">\\</span></span>
<span id="cb3-677"><a href="#cb3-677" aria-hidden="true" tabindex="-1"></a> &amp;=\sum_{k\in\cP^t} \zeta_{k}\wedge |S_t\cap R_{k}| \text{ by \eqref{eq_part_K1}}<span class="sc">\\</span></span>
<span id="cb3-678"><a href="#cb3-678" aria-hidden="true" tabindex="-1"></a> &amp;\geq \Vstar(S_t) \text{ by \eqref{eq_vstar_Qpartition}}.<span class="sc">\\</span></span>
<span id="cb3-679"><a href="#cb3-679" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-680"><a href="#cb3-680" aria-hidden="true" tabindex="-1"></a>So we proved that $\Vstar(S_t)= \sum_{k\in\cP^t} \zeta_{k}\wedge |S_t\cap R_{k}|= \sum_{k\in\cK^1} \Vstar(S_t\cap R_k)$ and finally $\Vstar(S_t)=\sum_{k\in\cK^1} \Vstar(S_t\cap R_k)= \sum_{k\in\cK^1}  \eta_k^t$ by \eqref{eq_vstar_inter_Rk_equal_eta}, again because $\cK^1\subseteq\cK_t$. Every equality in \eqref{eq_vstar_equal_sum_eta} is proven.</span>
<span id="cb3-681"><a href="#cb3-681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-682"><a href="#cb3-682" aria-hidden="true" tabindex="-1"></a>$\bullet$ Proof of \eqref{eq_vstar_inter_Rk_equal_eta} and \eqref{eq_Pt_good_partition}.</span>
<span id="cb3-683"><a href="#cb3-683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-684"><a href="#cb3-684" aria-hidden="true" tabindex="-1"></a>We show the remainder of the statements by a strong recursion over $t$. We have $\cP^0\in\mathfrak P$ by definition, and given that $S_0=\varnothing$ and $\eta^0_k=0$ for all $k\in\cK$ (recall that $\cK_0=\cK$), everything is equal to 0 in \eqref{eq_vstar_inter_Rk_equal_eta} and \eqref{eq_Pt_good_partition}.</span>
<span id="cb3-685"><a href="#cb3-685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-686"><a href="#cb3-686" aria-hidden="true" tabindex="-1"></a>So we let $t\in<span class="sc">\{</span> 0,\dotsc,m-1<span class="sc">\}</span>$, and assume that $\cP^{t'}\in\mathfrak P$ and that \eqref{eq_vstar_inter_Rk_equal_eta} and \eqref{eq_Pt_good_partition} hold for all $t'\leq t$. In all the following, $\bar k$ is the element of $\cP^t$ such that $i_{t+1}\in R_{\bar k}$. We will distinguish two cases: if $i_{t+1}\in\bigcup_{k\in\cK^-_{t}}R_k$ or not. First we show an inequality that will be used in both cases. We have, for all $k\in\cK_t$,</span>
<span id="cb3-687"><a href="#cb3-687" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb3-688"><a href="#cb3-688" aria-hidden="true" tabindex="-1"></a>\Vstar(S_{t+1}\cap R_k)&amp;\leq \sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|.\label{eq_ineq_both_cases}</span>
<span id="cb3-689"><a href="#cb3-689" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb3-690"><a href="#cb3-690" aria-hidden="true" tabindex="-1"></a>Indeed, by \eqref{eq_vstar_Qpartition}, </span>
<span id="cb3-691"><a href="#cb3-691" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-692"><a href="#cb3-692" aria-hidden="true" tabindex="-1"></a>\Vstar(S_{t+1}\cap R_k)&amp;\leq  \sum_{k'\in\cP^{t}} \zeta_{k'}\wedge |S_{t+1}\cap R_k \cap R_{k'}|.</span>
<span id="cb3-693"><a href="#cb3-693" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-694"><a href="#cb3-694" aria-hidden="true" tabindex="-1"></a>For any $k'\in\cP^{t}$, we have either $R_{k'}\cap R_k=\varnothing$, in which case $|S_{t+1}\cap R_k \cap R_{k'}|=0$, either $R_{k'}\subseteq R_k$, in which case $|S_{t+1}\cap R_k \cap R_{k'}|=|S_{t+1} \cap R_{k'}|$, but $R_{k}\subsetneq R_{k'}$ is impossible. Indeed, by definition of $\cK_t$, there exists $\tilde k\in \cP^t$ such that $R_{\tilde k}\subseteq R_k$, so $R_{k}\subsetneq R_{k'}$ would entail $R_{\tilde k}\subsetneq R_{k'}$ which is impossible since $k', \tilde k\in \cP^t\in\mathfrak P$ and so $R_{\tilde k}$ and $R_{k'}$ are part of a partition of $\Nm^*$. This gives \eqref{eq_ineq_both_cases}.</span>
<span id="cb3-695"><a href="#cb3-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-696"><a href="#cb3-696" aria-hidden="true" tabindex="-1"></a>$\bullet\bullet$ First case: $i_{t+1}\in\bigcup_{k\in\cK^-_{t}}R_k$.</span>
<span id="cb3-697"><a href="#cb3-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-698"><a href="#cb3-698" aria-hidden="true" tabindex="-1"></a>In this case, $\cP^{t+1}=\cP^t\in\mathfrak P$ and $\cK_{t+1}=\cK_t$. For any $k\in\cK_{t+1}$ such that $i_{t+1}\not\in R_k$ (or, equivalently, such that $S_{t+1}\cap R_k=S_t\cap R_k$),</span>
<span id="cb3-699"><a href="#cb3-699" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-700"><a href="#cb3-700" aria-hidden="true" tabindex="-1"></a>\sum_{\substack{k'\in\cP^{t+1} <span class="sc">\\</span> R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|&amp;=\sum_{\substack{k'\in\cP^{t} <span class="sc">\\</span> R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| <span class="sc">\\</span></span>
<span id="cb3-701"><a href="#cb3-701" aria-hidden="true" tabindex="-1"></a>&amp;=V^*_{\Rfam}(S_t\cap R_k) \text{ by~\eqref{eq_Pt_good_partition}}<span class="sc">\\</span></span>
<span id="cb3-702"><a href="#cb3-702" aria-hidden="true" tabindex="-1"></a>&amp;=\eta_k^t \text{ by~\eqref{eq_vstar_inter_Rk_equal_eta}}<span class="sc">\\</span></span>
<span id="cb3-703"><a href="#cb3-703" aria-hidden="true" tabindex="-1"></a>&amp;=\eta_k^{t+1}</span>
<span id="cb3-704"><a href="#cb3-704" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-705"><a href="#cb3-705" aria-hidden="true" tabindex="-1"></a>because $\eta_k^t=\eta_k^{t+1}$ for all $k\in\cK$. Furthermore $S_{t+1}\cap R_k=S_t\cap R_k$ so $V^*_{\Rfam}(S_{t+1}\cap R_k)=V^*_{\Rfam}(S_t\cap R_k)$. So everything is proved for such a $k$.</span>
<span id="cb3-706"><a href="#cb3-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-707"><a href="#cb3-707" aria-hidden="true" tabindex="-1"></a>Now we let $k\in\cK_{t+1}$ such that $i_{t+1}\in R_k$ or, equivalently, such that $R_{\bar k}\subseteq R_k$. We first need to show that $\zeta_{\bar k}\leq |S_t\cap R_{\bar k}|$, and for that we need to distinguish two subcases: if $\bar k$ has been added to $\cP^t$ during a previous step of the algorithm, of if not.</span>
<span id="cb3-708"><a href="#cb3-708" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-709"><a href="#cb3-709" aria-hidden="true" tabindex="-1"></a>$\bullet\bullet\bullet$ First subcase: $\bar k$ has never been added during the process of line 17.</span>
<span id="cb3-710"><a href="#cb3-710" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-711"><a href="#cb3-711" aria-hidden="true" tabindex="-1"></a>Then $\bar k\in\cP^0$ and $R_{\bar k}$ is an atom, so $i_{t+1}\in\bigcup_{k'\in\cK^-_{t}}R_{k'}$ implies that $R_{\bar k}\subseteq \bigcup_{k'\in\cK^-_{t}}R_{k'}$ (because of the forest structure). Let $k'_{\max}$ such that</span>
<span id="cb3-712"><a href="#cb3-712" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb3-713"><a href="#cb3-713" aria-hidden="true" tabindex="-1"></a>R_{k'_{\max}}=\max\{ R_{k'}\telque k'\in\cK^-_t, R_{\bar k}\subseteq R_{k'}  <span class="sc">\}</span></span>
<span id="cb3-714"><a href="#cb3-714" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb3-715"><a href="#cb3-715" aria-hidden="true" tabindex="-1"></a>(this a maximum for the inclusion relation, and it is well defined thanks to the forest structure). By reductio ad absurdum we show that $k'_{\max}=\bar k$. If that wasn't the case, by the joint construction of $\cP^t$ and $\cK^-_t$ during the algorithm we would have $k'_{\max}\in\cP^t$ and a contradiction with the fact that $\cP^t\in\mathfrak P$: we can't have both $\bar k\in\cP^t$ and $k'_{\max}\in\cP^t$ if they are distinct. So $k'_{\max}=\bar k$, so $\bar k\in  \cK^-_t$, but it cannot have been added to $\cK^-_t$ during a previous step of the algorithm, otherwise it would have been added to $\cP^t$, too. Hence $\bar k\in \cK^-_0$ which means that $\zeta_{\bar k}=0$ and $\zeta_{\bar k}=0\leq |S_t\cap R_{\bar k}|$.</span>
<span id="cb3-716"><a href="#cb3-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-717"><a href="#cb3-717" aria-hidden="true" tabindex="-1"></a>$\bullet\bullet\bullet$ Second subcase: $\bar k$ has been added to $\cP^t$ at a previous step.</span>
<span id="cb3-718"><a href="#cb3-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-719"><a href="#cb3-719" aria-hidden="true" tabindex="-1"></a>Let $t'\leq t$ be this step. This means that $\bar k = \kth{t'}{h^f_{t'}}$ and that at that step $\eta^{t'}_{\bar k}=\zeta_{\bar k}$. Indeed, the if condition in line 13 failed so $\eta^{t'}_{\bar k}\geq\zeta_{\bar k}$, but for all $t''&lt;t'$ we had $\eta^{t''}_{\bar k}\leq\zeta_{\bar k}$ which implies equality. Also $\bar k\in \cP^{t'}$ so $\bar k\in \cK_{t'}$ so we can write </span>
<span id="cb3-720"><a href="#cb3-720" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-721"><a href="#cb3-721" aria-hidden="true" tabindex="-1"></a>\zeta_{\bar k}&amp;=\eta^{t'}_{\bar k}<span class="sc">\\</span></span>
<span id="cb3-722"><a href="#cb3-722" aria-hidden="true" tabindex="-1"></a>&amp;=\Vstar(S_{t'}\cap R_{\bar k})  \text{ by~\eqref{eq_vstar_inter_Rk_equal_eta}} <span class="sc">\\</span></span>
<span id="cb3-723"><a href="#cb3-723" aria-hidden="true" tabindex="-1"></a>&amp;\leq | S_{t'}\cap R_{\bar k} |<span class="sc">\\</span></span>
<span id="cb3-724"><a href="#cb3-724" aria-hidden="true" tabindex="-1"></a>&amp;\leq  | S_{t}\cap R_{\bar k} |.<span class="sc">\\</span></span>
<span id="cb3-725"><a href="#cb3-725" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-726"><a href="#cb3-726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-727"><a href="#cb3-727" aria-hidden="true" tabindex="-1"></a>This concludes the two subcases dichotomy: $\zeta_{\bar k}\leq |S_t\cap R_{\bar k}|$ and we can go back to our $k\in\cK_{t+1}$ such that $i_{t+1}\in R_k$ and $R_{\bar k}\subseteq R_k$.</span>
<span id="cb3-728"><a href="#cb3-728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-729"><a href="#cb3-729" aria-hidden="true" tabindex="-1"></a>We write the following chain:</span>
<span id="cb3-730"><a href="#cb3-730" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-731"><a href="#cb3-731" aria-hidden="true" tabindex="-1"></a>\Vstar(S_{t+1}\cap R_k)&amp;\leq \sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|\text{ by~\eqref{eq_ineq_both_cases} and }\cK_{t+1}\subseteq\cK_t<span class="sc">\\</span></span>
<span id="cb3-732"><a href="#cb3-732" aria-hidden="true" tabindex="-1"></a>&amp;=\sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k<span class="sc">\\</span> k'\neq\bar k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| + \zeta_{\bar k}\wedge |S_{t+1}\cap R_{\bar k}| <span class="sc">\\</span></span>
<span id="cb3-733"><a href="#cb3-733" aria-hidden="true" tabindex="-1"></a>&amp;=\sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k<span class="sc">\\</span> k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge( |S_{t}\cap R_{\bar k}| +1)<span class="sc">\\</span></span>
<span id="cb3-734"><a href="#cb3-734" aria-hidden="true" tabindex="-1"></a>&amp;=\sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k<span class="sc">\\</span> k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge|S_{t}\cap R_{\bar k}|\text{ because $\zeta_{\bar k}\leq |S_t\cap R_{\bar k}|$}<span class="sc">\\</span></span>
<span id="cb3-735"><a href="#cb3-735" aria-hidden="true" tabindex="-1"></a>&amp;=\sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| <span class="sc">\\</span></span>
<span id="cb3-736"><a href="#cb3-736" aria-hidden="true" tabindex="-1"></a>&amp;=\Vstar(S_t\cap R_k)  \text{ by~\eqref{eq_Pt_good_partition}} <span class="sc">\\</span></span>
<span id="cb3-737"><a href="#cb3-737" aria-hidden="true" tabindex="-1"></a>&amp;= \eta_k^t  \text{ by~\eqref{eq_vstar_inter_Rk_equal_eta}} <span class="sc">\\</span></span>
<span id="cb3-738"><a href="#cb3-738" aria-hidden="true" tabindex="-1"></a>&amp;= \eta_k^{t+1}.<span class="sc">\\</span></span>
<span id="cb3-739"><a href="#cb3-739" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-740"><a href="#cb3-740" aria-hidden="true" tabindex="-1"></a>But on the other hand, $S_t\subseteq S_{t+1}$ and so \eqref{eq_vstar_Qpartition} also gives $\Vstar(S_t\cap R_k) \leq \Vstar(S_{t+1}\cap R_k)$ and so in the end we have the desired outcome:</span>
<span id="cb3-741"><a href="#cb3-741" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb3-742"><a href="#cb3-742" aria-hidden="true" tabindex="-1"></a>\Vstar(S_{t+1}\cap R_k) =  \eta_k^{t+1} =  \sum_{\substack{k'\in\cP^{t+1}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| ,</span>
<span id="cb3-743"><a href="#cb3-743" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb3-744"><a href="#cb3-744" aria-hidden="true" tabindex="-1"></a>which concludes this first case.</span>
<span id="cb3-745"><a href="#cb3-745" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-746"><a href="#cb3-746" aria-hidden="true" tabindex="-1"></a>$\bullet\bullet$ Second case: $i_{t+1}\not\in\bigcup_{k\in\cK^-_{t}}R_k$.</span>
<span id="cb3-747"><a href="#cb3-747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-748"><a href="#cb3-748" aria-hidden="true" tabindex="-1"></a>We first prove that $\cP^{t+1}\in\mathfrak P$ whether it came form the adjustment in line 17 or not. If it didn't, it stayed equal to $\cP^t\in\mathfrak P$. If it did, we have</span>
<span id="cb3-749"><a href="#cb3-749" aria-hidden="true" tabindex="-1"></a>\begin{equation}\label{eq_rel_rec_p}</span>
<span id="cb3-750"><a href="#cb3-750" aria-hidden="true" tabindex="-1"></a>\cP^{t+1}=\left(\cP^t \setminus<span class="sc">\{</span>k\in\cP^t, R_k\subseteq R_{  \kth {t+1}{h^f_{t+1}}   }   <span class="sc">\}</span>  \right)\cup <span class="sc">\{</span> \kth {t+1}{h^f_{t+1}} <span class="sc">\}</span>.</span>
<span id="cb3-751"><a href="#cb3-751" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-752"><a href="#cb3-752" aria-hidden="true" tabindex="-1"></a>To prove that $\cP^{t+1}\in\mathfrak P$ in that case, it suffices to prove there are no $k'\in\cP^t$ such that $R_{  \kth {t+1}{h^f_{t+1}}} \subsetneq  R_{k'}$. If it was the case, because of the strict inclusion, we would have $k'\not\in\cP^0$, so $k'$ would have been added to $\cP^{t'}$ at a previous step $t'\leq t$ of the algorithm, but in that case it would also have been added to $\cK_{t'}^-\subseteq \cK_{t}^-$. So in the end we would have</span>
<span id="cb3-753"><a href="#cb3-753" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb3-754"><a href="#cb3-754" aria-hidden="true" tabindex="-1"></a>i_{t+1}\in R_{  \kth {t+1}{h^f_{t+1}}} \subsetneq R_{k'} \subseteq \bigcup_{k\in\cK^-_{t}}R_k</span>
<span id="cb3-755"><a href="#cb3-755" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb3-756"><a href="#cb3-756" aria-hidden="true" tabindex="-1"></a>which is a contradiction and so $\cP^{t+1}\in\mathfrak P$.</span>
<span id="cb3-757"><a href="#cb3-757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-758"><a href="#cb3-758" aria-hidden="true" tabindex="-1"></a>Like in the first case, considering a $k\in\cK_{t+1}\subseteq \cK_t$ such that $i_{t+1}\not\in R_k$ is not problematic, because in that case $k$ is not visited at all by the algorithm at step $t+1$ : $\eta^{t+1}_k=\eta^{t}_k$, $\{k'\in\cP^{t+1}\telque R_{k'}\subseteq R_k\}=\{k'\in\cP^{t}\telque R_{k'}\subseteq R_k\}$, and for all $k'\in \cK$ such that $R_{k'}\subseteq R_k$, $S_{t+1}\cap R_{k'}=S_{t}\cap R_{k'}$. Hence, from </span>
<span id="cb3-759"><a href="#cb3-759" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb3-760"><a href="#cb3-760" aria-hidden="true" tabindex="-1"></a>\Vstar(S_{t}\cap R_k) =  \eta_k^{t} =  \sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| ,</span>
<span id="cb3-761"><a href="#cb3-761" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb3-762"><a href="#cb3-762" aria-hidden="true" tabindex="-1"></a>we directly have</span>
<span id="cb3-763"><a href="#cb3-763" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb3-764"><a href="#cb3-764" aria-hidden="true" tabindex="-1"></a>\Vstar(S_{t+1}\cap R_k) =  \eta_k^{t+1} =  \sum_{\substack{k'\in\cP^{t+1}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| .</span>
<span id="cb3-765"><a href="#cb3-765" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb3-766"><a href="#cb3-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-767"><a href="#cb3-767" aria-hidden="true" tabindex="-1"></a>So we now focus on the $k\in\cK_{t+1}$ such that $i_{t+1}\in R_k$. Note that for such $k$, </span>
<span id="cb3-768"><a href="#cb3-768" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb3-769"><a href="#cb3-769" aria-hidden="true" tabindex="-1"></a>\eta^{t+1}_k=\eta^t_k+1=\Vstar(S_t\cap R_k)+1=\sum_{\substack{k'\in \cP^t\\ R_{k'}\subseteq R_k}}\zeta_{k'}\wedge|S_t\cap R_{k'}|+1</span>
<span id="cb3-770"><a href="#cb3-770" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb3-771"><a href="#cb3-771" aria-hidden="true" tabindex="-1"></a>by construction, by \eqref{eq_vstar_inter_Rk_equal_eta} and by \eqref{eq_Pt_good_partition}. Indeed, such a $k$ is equal to a $\kth{t+1}h$ with $h\leq h_{max}(t+1)$, and even $h\leq h^f_{t+1}$ if the latter exists.</span>
<span id="cb3-772"><a href="#cb3-772" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-773"><a href="#cb3-773" aria-hidden="true" tabindex="-1"></a>Also, similarly to the first case, for all $k\in\cK_{t+1}$ such that $i_{t+1}\in R_k$ (recall that this is equivalent to $R_{\bar k}\subseteq R_k$), we can write:</span>
<span id="cb3-774"><a href="#cb3-774" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb3-775"><a href="#cb3-775" aria-hidden="true" tabindex="-1"></a>\Vstar(S_{t+1}\cap R_k)&amp;\leq \sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| \text{ by \eqref{eq_ineq_both_cases} and }\cK_{t+1}\subseteq\cK_t\notag<span class="sc">\\</span></span>
<span id="cb3-776"><a href="#cb3-776" aria-hidden="true" tabindex="-1"></a>&amp;=\sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k<span class="sc">\\</span> k'\neq\bar k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| + \zeta_{\bar k}\wedge |S_{t+1}\cap R_{\bar k}| \notag<span class="sc">\\</span></span>
<span id="cb3-777"><a href="#cb3-777" aria-hidden="true" tabindex="-1"></a>&amp;=\sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k<span class="sc">\\</span> k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge( |S_{t}\cap R_{\bar k}| +1)\notag<span class="sc">\\</span></span>
<span id="cb3-778"><a href="#cb3-778" aria-hidden="true" tabindex="-1"></a>&amp;\leq \sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k<span class="sc">\\</span> k'\neq\bar k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}| + \zeta_{\bar k}\wedge|S_{t}\cap R_{\bar k}| +1\notag<span class="sc">\\</span></span>
<span id="cb3-779"><a href="#cb3-779" aria-hidden="true" tabindex="-1"></a>&amp;=\sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t}\cap R_{k'}|  + 1\notag<span class="sc">\\</span></span>
<span id="cb3-780"><a href="#cb3-780" aria-hidden="true" tabindex="-1"></a>&amp;=\Vstar(S_t\cap R_k) +1  \text{ by \eqref{eq_Pt_good_partition}}.\label{eq_ineq_}</span>
<span id="cb3-781"><a href="#cb3-781" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb3-782"><a href="#cb3-782" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-783"><a href="#cb3-783" aria-hidden="true" tabindex="-1"></a>Note that by the joint construction of $\cK^-_t$ and $\cP^t$ on lines 17 and 18, the fact that $i_{t+1}\not\in\bigcup_{k\in\cK^-_{t}}R_k$ implies that $\bar k$ is the index of an atom, so actually $h_{\max}(t+1)=\phi(\bar k)$, $\bar k = \kth{t+1}{\phi(\bar k)}$ and the $R_k$, $k\in\cK_{t}$, such that $R_{\bar k}\subseteq R_k$ are nested and are exactly indexed by the $\kth{t+1}{h}$, $1\leq h\leq \phi(\bar k)$. We now prove that for all of them, $\Vstar(S_{t+1}\cap R_k)\geq \Vstar(S_{t}\cap R_k)+1$, which will be true in particular for the ones that are in $\cK_{t+1}$, given that $\cK_{t+1}\subseteq \cK_t$. We do that by constructing some sets $A_h$ with good properties with a descending recursion on $h$, starting from $\phi(\bar k)$. We only give the first two steps of the construction, because every other step is exactly the same as the second one, which contains the recursive arguments. We go back to the real definition of $\Vstar$ to do so, for any $S\subseteq \Nm$:</span>
<span id="cb3-784"><a href="#cb3-784" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-785"><a href="#cb3-785" aria-hidden="true" tabindex="-1"></a>\label{eq_Vstar_au_max} \Vstar(S)=\max_{\substack{A\subseteq \Nm<span class="sc">\\</span>\forall k'\in\cK, |A\cap R_{k'}|\leq \zeta_{k'}}} |A\cap S| =\max_{\substack{A\subseteq S<span class="sc">\\</span>\forall k'\in\cK, |A\cap R_{k'}|\leq \zeta_{k'}}} |A|  . </span>
<span id="cb3-786"><a href="#cb3-786" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-787"><a href="#cb3-787" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-788"><a href="#cb3-788" aria-hidden="true" tabindex="-1"></a>By \eqref{eq_Vstar_au_max}, we have that $\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)}})=|A_{\phi(\bar k)}|$ for a given $A_{\phi(\bar k)}\subseteq S_t \cap R_{\kth{t+1}{\phi(\bar k)}}$ and such that $|A_{\phi(\bar k)}\cap R_{k'}|\leq \zeta_{k'}$ for all $k'\in\cK$. Now for the second set, we construct $A_{\phi(\bar k)-1}$. Note that $\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}})=|B|$ for some $B\subseteq S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}$ and such that $|B\cap R_{k'}|\leq \zeta_{k'}$ for all $k'\in\cK$. By reductio ad absurdum, if there are strictly less than $\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}) - \Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)}})=|B|-|A_{\phi(\bar k)}|$ elements in $S_t\cap R_{\kth{t+1}{\phi(\bar k)-1}} \setminus S_t\cap R_{\kth{t+1}{\phi(\bar k)}}$, then $|B|+|S_t \cap R_{\kth{t+1}{\phi(\bar k)}}|-|S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}|&gt;|A_{\phi(\bar k)}|=\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)}})$. Given that $B\cup (S_t\cap R_{\kth{t+1}{\phi(\bar k)}})\subseteq S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}$, this entails $|B\cap S_t\cap R_{\kth{t+1}{\phi(\bar k)}}| =|B|+|S_t \cap R_{\kth{t+1}{\phi(\bar k)}}| -| B\cup (S_t\cap R_{\kth{t+1}{\phi(\bar k)}})| &gt; \Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)}})$ which contradicts the maximality of $A_{\phi(\bar k)}$ in \eqref{eq_Vstar_au_max}. </span>
<span id="cb3-789"><a href="#cb3-789" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-790"><a href="#cb3-790" aria-hidden="true" tabindex="-1"></a>So we construct $A_{\phi(\bar k)-1}$ by taking the disjoint union of $A_{\phi(\bar k)}$ and $\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}) - \Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)}})$ elements of $S_t\cap R_{\kth{t+1}{\phi(\bar k)-1}} \setminus S_t\cap R_{\kth{t+1}{\phi(\bar k)}}$. We now establish the properties of $A_{\phi(\bar k)-1}$. First, $A_{\phi(\bar k)-1}\subseteq S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}$, and $|A_{\phi(\bar k)-1}|=\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}})$. For all $k'\in\cK$ such that $R_{\kth{t+1}{\phi(\bar k)-1}} \cap R_{k'}=\varnothing$, we have $|A_{\phi(\bar k)-1}\cap R_{k'}|=0\leq \zeta_k'$. Furthermore,</span>
<span id="cb3-791"><a href="#cb3-791" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-792"><a href="#cb3-792" aria-hidden="true" tabindex="-1"></a>|A_{\phi(\bar k)-1}\cap R_{   \kth{t+1}{\phi(\bar k)}   }|&amp;=|A_{\phi(\bar k)}\cap R_{   \kth{t+1}{\phi(\bar k)}   }|<span class="sc">\\</span></span>
<span id="cb3-793"><a href="#cb3-793" aria-hidden="true" tabindex="-1"></a>&amp;\leq \zeta_{ \kth{t+1}{\phi(\bar k)} }</span>
<span id="cb3-794"><a href="#cb3-794" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-795"><a href="#cb3-795" aria-hidden="true" tabindex="-1"></a>by construction of $A_{\phi(\bar k)}$. Finally, for all $k'$ such that $R_{\kth{t+1}{\phi(\bar k)-1}}\subseteq R_{k'}$, $|A_{\phi(\bar k)-1}\cap R_{k'}|=|A_{\phi(\bar k)-1}|=\Vstar(S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}})=|B|$ with the previously defined $B$, in particular $|B\cap R_{k'}|\leq \zeta_{k'}$, but given that $B\subseteq S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}$, $|B\cap R_{k'}|=|B|$. Wrapping all those equalities, it comes that $|A_{\phi(\bar k)-1}\cap R_{k'}|\leq \zeta_{k'}$. In the end, $|A_{\phi(\bar k)-1}\cap R_{k'}|\leq \zeta_{k'}$ for all $k'\in\cK$, so $A_{\phi(\bar k)-1}$ realizes the maximum in \eqref{eq_Vstar_au_max} for $S_t \cap R_{\kth{t+1}{\phi(\bar k)-1}}$.</span>
<span id="cb3-796"><a href="#cb3-796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-797"><a href="#cb3-797" aria-hidden="true" tabindex="-1"></a>By applying exactly the same method, we recursively construct a non-increasing sequence $A_{\phi(\bar k)}\subseteq\dotsb\subseteq A_1$ such that for all $\ell\in<span class="sc">\{</span>1,\dotsc, \phi(\bar k)<span class="sc">\}</span>$ and $k'\in\cK$, $A_\ell\subseteq S_t\cap R_{\kth{t+1}{\ell}}$, $\Vstar(S_t\cap R_{\kth{t+1}{\ell}})=|A_\ell|$, and $|A_\ell\cap R_{k'}|\leq \zeta_{k'}$. Furthermore for $\ell'&gt;\ell$, $A_{\ell}\setminus A_{\ell'}\subseteq S_t\cap R_{\kth{t+1}{\ell}}\setminus S_t\cap R_{\kth{t+1}{\ell'}}$. Also note that the fact that $i_{t+1}\not\in\bigcup_{k\in\cK^-_{t}}R_k$ implies that $\eta^t_{\kth{t+1}{\ell}}&lt;\zeta_{\kth{t+1}{\ell}}$ for all $\ell\in\{1,\dotsc, \phi(\bar k)\}$. So by \eqref{eq_vstar_inter_Rk_equal_eta}, $|A_\ell|&lt;\zeta_{\kth{t+1}{\ell}}$.</span>
<span id="cb3-798"><a href="#cb3-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-799"><a href="#cb3-799" aria-hidden="true" tabindex="-1"></a>Let, for any $\ell\in<span class="sc">\{</span>1,\dotsc, \phi(\bar k)<span class="sc">\}</span>$, $\widetilde A_\ell=A_\ell \cup <span class="sc">\{</span> i_{t+1}<span class="sc">\}</span>$. Given that $A_\ell\subseteq S_t\cap R_{\kth{t+1}{\ell}}$ and that $i_{t+1}\in S_{t+1}\setminus S_t$, $\widetilde A_\ell\subseteq S_{t+1}\cap R_{\kth{t+1}{\ell}}$, $|\widetilde A_\ell|=| A_\ell|+1$, and for all $\ell'\in<span class="sc">\{</span>1,\dotsc, \phi(\bar k)<span class="sc">\}</span>$, $|\widetilde A_\ell \cap R_{\kth{t+1}{\ell'}} |=| A_\ell\cap R_{\kth{t+1}{\ell'}}|+1$. Note that if, furthermore, $\ell\geq \ell'$, then $A_\ell\subseteq A_{\ell'}$, so</span>
<span id="cb3-800"><a href="#cb3-800" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-801"><a href="#cb3-801" aria-hidden="true" tabindex="-1"></a>|\widetilde A_\ell \cap R_{\kth{t+1}{\ell'}} |&amp;=| A_\ell\cap R_{\kth{t+1}{\ell'}}|+1<span class="sc">\\</span></span>
<span id="cb3-802"><a href="#cb3-802" aria-hidden="true" tabindex="-1"></a>&amp;\leq | A_{\ell'}\cap R_{\kth{t+1}{\ell'}}|+1<span class="sc">\\</span></span>
<span id="cb3-803"><a href="#cb3-803" aria-hidden="true" tabindex="-1"></a>&amp;= | A_{\ell'}|+1<span class="sc">\\</span></span>
<span id="cb3-804"><a href="#cb3-804" aria-hidden="true" tabindex="-1"></a>&amp;&lt;\zeta_{\kth{t+1}{\ell'}}+1.<span class="sc">\\</span></span>
<span id="cb3-805"><a href="#cb3-805" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-806"><a href="#cb3-806" aria-hidden="true" tabindex="-1"></a>On the contrary, if $\ell&lt; \ell'$, we write that</span>
<span id="cb3-807"><a href="#cb3-807" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-808"><a href="#cb3-808" aria-hidden="true" tabindex="-1"></a>|\widetilde A_\ell \cap R_{\kth{t+1}{\ell'}} |&amp;=| A_\ell\cap R_{\kth{t+1}{\ell'}}|+1<span class="sc">\\</span></span>
<span id="cb3-809"><a href="#cb3-809" aria-hidden="true" tabindex="-1"></a>&amp;= | (A_{\ell}\setminus A_{\ell'}) \cap R_{\kth{t+1}{\ell'}}   | + | A_{\ell'}\cap R_{\kth{t+1}{\ell'}}|+1<span class="sc">\\</span></span>
<span id="cb3-810"><a href="#cb3-810" aria-hidden="true" tabindex="-1"></a>&amp;&lt;  0 +  \zeta_{\kth{t+1}{\ell'}} +1,</span>
<span id="cb3-811"><a href="#cb3-811" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-812"><a href="#cb3-812" aria-hidden="true" tabindex="-1"></a>because $A_{\ell}\setminus A_{\ell'} \subseteq   R_{\kth{t+1}{\ell}}\setminus  R_{\kth{t+1}{\ell'}}$ hence $(A_{\ell}\setminus A_{\ell'}) \cap R_{\kth{t+1}{\ell'}}  =\varnothing$. In both cases, $|\widetilde A_\ell \cap R_{\kth{t+1}{\ell'}} |&lt; \zeta_{\kth{t+1}{\ell'}} +1$ so $|\widetilde A_\ell \cap R_{\kth{t+1}{\ell'}} |\leq \zeta_{\kth{t+1}{\ell'}}$. Additionally, for all $k'\in\cK$ such that $i_{t+1}\not\in R_{k'}$,  $|\widetilde A_\ell \cap R_{k'} |=| A_\ell \cap R_{k'} |\leq \zeta_{k'}$. </span>
<span id="cb3-813"><a href="#cb3-813" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-814"><a href="#cb3-814" aria-hidden="true" tabindex="-1"></a>In the end, $|\widetilde A_\ell \cap R_{k'} |\leq \zeta_{k'}$ for all $k'\in\cK$, so</span>
<span id="cb3-815"><a href="#cb3-815" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-816"><a href="#cb3-816" aria-hidden="true" tabindex="-1"></a>\Vstar( S_{t+1}\cap R_{\kth{t+1}{\ell}})&amp;\geq | \widetilde A_\ell | \text{ by \eqref{eq_Vstar_au_max}}<span class="sc">\\</span></span>
<span id="cb3-817"><a href="#cb3-817" aria-hidden="true" tabindex="-1"></a>&amp;=  |  A_\ell | +1<span class="sc">\\</span></span>
<span id="cb3-818"><a href="#cb3-818" aria-hidden="true" tabindex="-1"></a>&amp;= \Vstar( S_{t}\cap R_{\kth{t+1}{\ell}}) +1.</span>
<span id="cb3-819"><a href="#cb3-819" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-820"><a href="#cb3-820" aria-hidden="true" tabindex="-1"></a>So, as we wanted, $\Vstar(S_{t+1}\cap R_k)\geq \Vstar(S_{t}\cap R_k)+1$ for all $k\in\cK_{t}$ such that $i_{t+1}\in R_k$ and so for all such $k$ that are in $\cK_{t+1}$. So every inequality in \eqref{eq_ineq_} becomes an equality and we have proven that </span>
<span id="cb3-821"><a href="#cb3-821" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb3-822"><a href="#cb3-822" aria-hidden="true" tabindex="-1"></a>\Vstar(S_{t+1}\cap R_k) = \Vstar(S_{t}\cap R_k)+1 =\eta^t_k+1= \eta^{t+1}_k,</span>
<span id="cb3-823"><a href="#cb3-823" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb3-824"><a href="#cb3-824" aria-hidden="true" tabindex="-1"></a>that is, \eqref{eq_vstar_inter_Rk_equal_eta} is true at $t+1$.</span>
<span id="cb3-825"><a href="#cb3-825" aria-hidden="true" tabindex="-1"></a>Looking at the first line of \eqref{eq_ineq_} , we also proved that</span>
<span id="cb3-826"><a href="#cb3-826" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb3-827"><a href="#cb3-827" aria-hidden="true" tabindex="-1"></a>\Vstar(S_{t+1}\cap R_k) =  \sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| . \label{eq_Pt_instead}</span>
<span id="cb3-828"><a href="#cb3-828" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-829"><a href="#cb3-829" aria-hidden="true" tabindex="-1"></a>The only thing left to prove is that \eqref{eq_Pt_instead} is also true with $\cP^{t+1}$ instead of $\cP^{t}$, that is that \eqref{eq_Pt_good_partition} also holds at $t+1$, or, put differently, that</span>
<span id="cb3-830"><a href="#cb3-830" aria-hidden="true" tabindex="-1"></a>\begin{equation}\label{eq_last_goal}</span>
<span id="cb3-831"><a href="#cb3-831" aria-hidden="true" tabindex="-1"></a>\sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|=\sum_{\substack{k'\in\cP^{t+1}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|.</span>
<span id="cb3-832"><a href="#cb3-832" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb3-833"><a href="#cb3-833" aria-hidden="true" tabindex="-1"></a>If $h^f_{t+1}$ does not exist, meaning that we didn't break the loop, $\cP^{t+1}=\cP^t$ so there is nothing to prove.</span>
<span id="cb3-834"><a href="#cb3-834" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-835"><a href="#cb3-835" aria-hidden="true" tabindex="-1"></a>Now assume that $h^f_{t+1}$ exists. So \eqref{eq_rel_rec_p} holds. We will split each term in \eqref{eq_last_goal} in a sum of two terms. First, note that by \eqref{eq_rel_rec_p}, for any $k'\in\cK$ such that $R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing$, we have that $k'\in\cP^{t+1}$ if and only if $k'\in \cP^{t}$. And so,</span>
<span id="cb3-836"><a href="#cb3-836" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-837"><a href="#cb3-837" aria-hidden="true" tabindex="-1"></a> \sum_{\substack{k'\in\cP^{t+1}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| &amp;=  \sum_{\substack{k'\in\cP^{t+1}<span class="sc">\\</span>R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing <span class="sc">\\</span>R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| +  \zeta_{ \kth {t+1}{h^f_{t+1}}}\wedge |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|<span class="sc">\\</span> </span>
<span id="cb3-838"><a href="#cb3-838" aria-hidden="true" tabindex="-1"></a> &amp;=  \sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing <span class="sc">\\</span>R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| +  \zeta_{ \kth {t+1}{h^f_{t+1}}}\wedge |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|.</span>
<span id="cb3-839"><a href="#cb3-839" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-840"><a href="#cb3-840" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-841"><a href="#cb3-841" aria-hidden="true" tabindex="-1"></a>Recall that we already proved that there is no $k'\in \cP^t$ such that $R_{  \kth {t+1}{h^f_{t+1}} }\subsetneq R_{k'}$, so for any $k'\in \cP^t$, either $R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing$ or $R_{k'}\subseteq  R_{  \kth {t+1}{h^f_{t+1}}}$. Hence the split</span>
<span id="cb3-842"><a href="#cb3-842" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-843"><a href="#cb3-843" aria-hidden="true" tabindex="-1"></a> \sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| &amp;=  \sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing <span class="sc">\\</span>R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|  \;   + \sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq  R_{  \kth {t+1}{h^f_{t+1}}}<span class="sc">\\</span> R_{k'}\subseteq R_k}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|<span class="sc">\\</span></span>
<span id="cb3-844"><a href="#cb3-844" aria-hidden="true" tabindex="-1"></a> &amp;=\sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\cap  R_{  \kth {t+1}{h^f_{t+1}} } = \varnothing <span class="sc">\\</span>R_{k'}\subseteq R_k }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|  \;   + \sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq  R_{  \kth {t+1}{h^f_{t+1}}}}} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}|,</span>
<span id="cb3-845"><a href="#cb3-845" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-846"><a href="#cb3-846" aria-hidden="true" tabindex="-1"></a>where the last equality comes from the fact that $R_{  \kth {t+1}{h^f_{t+1}} }\subseteq R_k$, because $k\in\cK_{t+1}$, $i_{t+1}\in R_k$, and $\kth {t+1}{h^f_{t+1}}\in \cP^{t+1}$.</span>
<span id="cb3-847"><a href="#cb3-847" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-848"><a href="#cb3-848" aria-hidden="true" tabindex="-1"></a>Given the two previously made splits, it remains to prove that </span>
<span id="cb3-849"><a href="#cb3-849" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb3-850"><a href="#cb3-850" aria-hidden="true" tabindex="-1"></a>\sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq  R_{  \kth {t+1}{h^f_{t+1}}} }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| =  \zeta_{ \kth {t+1}{h^f_{t+1}}}\wedge |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|.</span>
<span id="cb3-851"><a href="#cb3-851" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb3-852"><a href="#cb3-852" aria-hidden="true" tabindex="-1"></a>Interestingly, this does not depend  on $k$ anymore. By \eqref{eq_Pt_instead}, the left-hand side  is equal to $\Vstar( S_{t+1}\cap  R_{  \kth {t+1}{h^f_{t+1}}  } )$. Because we are breaking the loop at step  $h^f_{t+1}$, $\eta^{t+1}_{\kth {t+1}{h^f_{t+1}} }= \zeta_{ \kth {t+1}{h^f_{t+1}}}$. Finally, because \eqref{eq_vstar_inter_Rk_equal_eta} holds at $t+1$, $\eta^{t+1}_{\kth {t+1}{h^f_{t+1}} }=\Vstar( S_{t+1}\cap  R_{  \kth {t+1}{h^f_{t+1}}  } )$. Wrapping all these assertions:</span>
<span id="cb3-853"><a href="#cb3-853" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb3-854"><a href="#cb3-854" aria-hidden="true" tabindex="-1"></a>\sum_{\substack{k'\in\cP^{t}<span class="sc">\\</span>R_{k'}\subseteq  R_{  \kth {t+1}{h^f_{t+1}}} }} \zeta_{k'}\wedge |S_{t+1}\cap R_{k'}| &amp;= \Vstar( S_{t+1}\cap  R_{  \kth {t+1}{h^f_{t+1}}  } )<span class="sc">\\</span></span>
<span id="cb3-855"><a href="#cb3-855" aria-hidden="true" tabindex="-1"></a>&amp;=\Vstar( S_{t+1}\cap  R_{  \kth {t+1}{h^f_{t+1}}  } )\wedge  |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|<span class="sc">\\</span></span>
<span id="cb3-856"><a href="#cb3-856" aria-hidden="true" tabindex="-1"></a>&amp;=\eta^{t+1}_{\kth {t+1}{h^f_{t+1}} }\wedge  |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|<span class="sc">\\</span></span>
<span id="cb3-857"><a href="#cb3-857" aria-hidden="true" tabindex="-1"></a>&amp;=  \zeta_{ \kth {t+1}{h^f_{t+1}}}\wedge |S_{t+1}\cap R_{ \kth {t+1}{h^f_{t+1}}}|,</span>
<span id="cb3-858"><a href="#cb3-858" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb3-859"><a href="#cb3-859" aria-hidden="true" tabindex="-1"></a>which achieves the second case and so the proof.</span>
<span id="cb3-860"><a href="#cb3-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-861"><a href="#cb3-861" aria-hidden="true" tabindex="-1"></a>$\square$</span>
<span id="cb3-862"><a href="#cb3-862" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-863"><a href="#cb3-863" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-864"><a href="#cb3-864" aria-hidden="true" tabindex="-1"></a>We deduce from the proof the following light corollary, that is useful for the implementation, because it makes it useless to compute $\cK^1$. It justifies the line 19 of @alg-curve.</span>
<span id="cb3-865"><a href="#cb3-865" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-866"><a href="#cb3-866" aria-hidden="true" tabindex="-1"></a>::: {#cor-easy-impl}</span>
<span id="cb3-867"><a href="#cb3-867" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-868"><a href="#cb3-868" aria-hidden="true" tabindex="-1"></a><span class="fu">## Easy computation</span></span>
<span id="cb3-869"><a href="#cb3-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-870"><a href="#cb3-870" aria-hidden="true" tabindex="-1"></a>For $t\in<span class="sc">\{</span>0,\dotsc, m-1 <span class="sc">\}</span>$, $V^*_{\Rfam}(S_{t+1})=V^*_{\Rfam}(S_{t})$ if $i_{t+1}\in \bigcup_{k\in\cK^-_t}R_k$, and  $V^*_{\Rfam}(S_{t+1})=V^*_{\Rfam}(S_{t}) + 1$ if not.</span>
<span id="cb3-871"><a href="#cb3-871" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-872"><a href="#cb3-872" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-873"><a href="#cb3-873" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-874"><a href="#cb3-874" aria-hidden="true" tabindex="-1"></a>Finally, we present @alg-curve, the alternative version of @alg-formal-curve, written with practical implementation in mind rather than formalism of notation, and using @cor-easy-impl. It is easy to see that each step $t$ has a complexity in $O(|\cK|)$ hence the total complexity is in $O(m|\cK|)$. This is because, if the regions are carefully stocked in memory, especially if their bounds (in terms of hypothesis index) are stocked, then finding $\kth th$ has a complexity in $O(|\cK^h|)$ and checking if $i_t\in\bigcup_{k\in\cK^-_{t-1}}R_k$ has a complexity in $O(|\cK|)$.</span>
<span id="cb3-875"><a href="#cb3-875" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-876"><a href="#cb3-876" aria-hidden="true" tabindex="-1"></a>::: {.content-visible when-format="html"}</span>
<span id="cb3-877"><a href="#cb3-877" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb3-878"><a href="#cb3-878" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-curve</span></span>
<span id="cb3-879"><a href="#cb3-879" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb3-880"><a href="#cb3-880" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb3-881"><a href="#cb3-881" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb3-882"><a href="#cb3-882" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb3-883"><a href="#cb3-883" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb3-884"><a href="#cb3-884" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb3-885"><a href="#cb3-885" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb3-886"><a href="#cb3-886" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb3-887"><a href="#cb3-887" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Practical computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}</span></span>
<span id="cb3-888"><a href="#cb3-888" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb3-889"><a href="#cb3-889" aria-hidden="true" tabindex="-1"></a><span class="in">\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}</span></span>
<span id="cb3-890"><a href="#cb3-890" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $V_0\gets 0$</span></span>
<span id="cb3-891"><a href="#cb3-891" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\mathcal{K}^-\gets\{k\in\mathcal{K} : \zeta_k=0  \}$</span></span>
<span id="cb3-892"><a href="#cb3-892" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\eta_k\gets 0$ for all $k\in\mathcal{K}$</span></span>
<span id="cb3-893"><a href="#cb3-893" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$t=1,\dotsc, m$}</span></span>
<span id="cb3-894"><a href="#cb3-894" aria-hidden="true" tabindex="-1"></a><span class="in">    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-}R_k$}</span></span>
<span id="cb3-895"><a href="#cb3-895" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $V_{t}\gets V_{t-1}$</span></span>
<span id="cb3-896"><a href="#cb3-896" aria-hidden="true" tabindex="-1"></a><span class="in">    \Else</span></span>
<span id="cb3-897"><a href="#cb3-897" aria-hidden="true" tabindex="-1"></a><span class="in">      \For{$h=1,\dotsc,h_{\max}(t)$}</span></span>
<span id="cb3-898"><a href="#cb3-898" aria-hidden="true" tabindex="-1"></a><span class="in">        \State find $k^{(t,h)}\in\mathcal{K}^{h}$ such that $i_t\in R_{k^{(t,h)}}$</span></span>
<span id="cb3-899"><a href="#cb3-899" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\eta_{k^{(t,h)}}\gets\eta_{k^{(t,h)}} + 1$</span></span>
<span id="cb3-900"><a href="#cb3-900" aria-hidden="true" tabindex="-1"></a><span class="in">        \If{$\eta_{k^{(t,h)}}&lt;\zeta_k$}</span></span>
<span id="cb3-901"><a href="#cb3-901" aria-hidden="true" tabindex="-1"></a><span class="in">          \State pass</span></span>
<span id="cb3-902"><a href="#cb3-902" aria-hidden="true" tabindex="-1"></a><span class="in">        \Else</span></span>
<span id="cb3-903"><a href="#cb3-903" aria-hidden="true" tabindex="-1"></a><span class="in">          \State $\mathcal{K}^- \gets \mathcal{K}^-\cup \{ k^{(t,h)} \}$</span></span>
<span id="cb3-904"><a href="#cb3-904" aria-hidden="true" tabindex="-1"></a><span class="in">          \State break the loop</span></span>
<span id="cb3-905"><a href="#cb3-905" aria-hidden="true" tabindex="-1"></a><span class="in">        \EndIf</span></span>
<span id="cb3-906"><a href="#cb3-906" aria-hidden="true" tabindex="-1"></a><span class="in">      \EndFor</span></span>
<span id="cb3-907"><a href="#cb3-907" aria-hidden="true" tabindex="-1"></a><span class="in">     \State $V_{t}\gets V_{t-1} + 1$</span></span>
<span id="cb3-908"><a href="#cb3-908" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndIf</span></span>
<span id="cb3-909"><a href="#cb3-909" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb3-910"><a href="#cb3-910" aria-hidden="true" tabindex="-1"></a><span class="in">  \Return $(V_t)_{1\leq t \leq m}$</span></span>
<span id="cb3-911"><a href="#cb3-911" aria-hidden="true" tabindex="-1"></a><span class="in">\EndProcedure</span></span>
<span id="cb3-912"><a href="#cb3-912" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb3-913"><a href="#cb3-913" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb3-914"><a href="#cb3-914" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-915"><a href="#cb3-915" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-916"><a href="#cb3-916" aria-hidden="true" tabindex="-1"></a>::: {.content-hidden when-format="html"}</span>
<span id="cb3-917"><a href="#cb3-917" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb3-918"><a href="#cb3-918" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-curve</span></span>
<span id="cb3-919"><a href="#cb3-919" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb3-920"><a href="#cb3-920" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb3-921"><a href="#cb3-921" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb3-922"><a href="#cb3-922" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb3-923"><a href="#cb3-923" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb3-924"><a href="#cb3-924" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb3-925"><a href="#cb3-925" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb3-926"><a href="#cb3-926" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb3-927"><a href="#cb3-927" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Practical computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}</span></span>
<span id="cb3-928"><a href="#cb3-928" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb3-929"><a href="#cb3-929" aria-hidden="true" tabindex="-1"></a><span class="in">\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}</span></span>
<span id="cb3-930"><a href="#cb3-930" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $V_0\gets 0$</span></span>
<span id="cb3-931"><a href="#cb3-931" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\mathcal{K}^-\gets\{k\in\mathcal{K} : \zeta_k=0  \}$</span></span>
<span id="cb3-932"><a href="#cb3-932" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\eta_k\gets 0$ for all $k\in\mathcal{K}$</span></span>
<span id="cb3-933"><a href="#cb3-933" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$t=1,\dotsc, m$}</span></span>
<span id="cb3-934"><a href="#cb3-934" aria-hidden="true" tabindex="-1"></a><span class="in">    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-}R_k$}</span></span>
<span id="cb3-935"><a href="#cb3-935" aria-hidden="true" tabindex="-1"></a><span class="in">      \State $V_{t}\gets V_{t-1}$</span></span>
<span id="cb3-936"><a href="#cb3-936" aria-hidden="true" tabindex="-1"></a><span class="in">    \Else</span></span>
<span id="cb3-937"><a href="#cb3-937" aria-hidden="true" tabindex="-1"></a><span class="in">      \For{$h=1,\dotsc,h_{\max}(t)$}</span></span>
<span id="cb3-938"><a href="#cb3-938" aria-hidden="true" tabindex="-1"></a><span class="in">        \State find $k^{(t,h)}\in\mathcal{K}^{h}$ such that $i_t\in R_{k^{(t,h)}}$</span></span>
<span id="cb3-939"><a href="#cb3-939" aria-hidden="true" tabindex="-1"></a><span class="in">        \State $\eta_{k^{(t,h)}}\gets\eta_{k^{(t,h)}} + 1$</span></span>
<span id="cb3-940"><a href="#cb3-940" aria-hidden="true" tabindex="-1"></a><span class="in">        \If{$\eta_{k^{(t,h)}}&lt;\zeta_k$}</span></span>
<span id="cb3-941"><a href="#cb3-941" aria-hidden="true" tabindex="-1"></a><span class="in">          \State pass</span></span>
<span id="cb3-942"><a href="#cb3-942" aria-hidden="true" tabindex="-1"></a><span class="in">        \Else</span></span>
<span id="cb3-943"><a href="#cb3-943" aria-hidden="true" tabindex="-1"></a><span class="in">          \State $\mathcal{K}^- \gets \mathcal{K}^-\cup \{ k^{(t,h)} \}$</span></span>
<span id="cb3-944"><a href="#cb3-944" aria-hidden="true" tabindex="-1"></a><span class="in">          \State break the loop</span></span>
<span id="cb3-945"><a href="#cb3-945" aria-hidden="true" tabindex="-1"></a><span class="in">        \EndIf</span></span>
<span id="cb3-946"><a href="#cb3-946" aria-hidden="true" tabindex="-1"></a><span class="in">      \EndFor</span></span>
<span id="cb3-947"><a href="#cb3-947" aria-hidden="true" tabindex="-1"></a><span class="in">     \State $V_{t}\gets V_{t-1} + 1$</span></span>
<span id="cb3-948"><a href="#cb3-948" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndIf</span></span>
<span id="cb3-949"><a href="#cb3-949" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb3-950"><a href="#cb3-950" aria-hidden="true" tabindex="-1"></a><span class="in">  \State\Return $(V_t)_{1\leq t \leq m}$</span></span>
<span id="cb3-951"><a href="#cb3-951" aria-hidden="true" tabindex="-1"></a><span class="in">\EndProcedure</span></span>
<span id="cb3-952"><a href="#cb3-952" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb3-953"><a href="#cb3-953" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb3-954"><a href="#cb3-954" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-955"><a href="#cb3-955" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-956"><a href="#cb3-956" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-957"><a href="#cb3-957" aria-hidden="true" tabindex="-1"></a><span class="fu"># Implementation {#sec-implementation}</span></span>
<span id="cb3-958"><a href="#cb3-958" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-959"><a href="#cb3-959" aria-hidden="true" tabindex="-1"></a>All algorithms discussed in this manuscript are already implemented in the <span class="in">`R`</span> <span class="co">[</span><span class="ot">@R-base</span><span class="co">]</span> package <span class="in">`sanssouci`</span> <span class="co">[</span><span class="ot">@sanssouci</span><span class="co">]</span> which is available on GitHub (see the References for the link) and is dedicated to the computation of confidence bounds for the number of false positives. It also hosts the implementation of the methods described in @MR4124323 and @10.1093/bioinformatics/btac693. @alg-vstar is implemented as the <span class="in">`V.star`</span> function, @alg-pruning is implemented as the <span class="in">`pruning`</span> function, and @alg-curve is implemented as the <span class="in">`curve.V.star.forest.fast`</span> function (whereas the <span class="in">`curve.V.star.forest.naive`</span> function just repeatedly calls <span class="in">`V.star`</span>). Note that the <span class="in">`pruning`</span> function has a <span class="in">`delete.gaps`</span> option that speeds up the computation even more by removing unnecessary gaps introduced in the data structure by the pruning operation, those gaps being due to the specific structure that is used to store the information of $\cK$. </span>
<span id="cb3-960"><a href="#cb3-960" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-961"><a href="#cb3-961" aria-hidden="true" tabindex="-1"></a>The functions <span class="in">`dyadic.from.leaf_list`</span>, <span class="in">`dyadic.from.window.size`</span>, and <span class="in">`dyadic.from.height`</span> return the appropriate data structure to represent a $\cK$ that can be described as a dyadic tree, based on some entry parameters that can be inferred from the names of the functions. The completion of a forest structure, mentioned in @sec-forest-structure, is done by the <span class="in">`forest.completion`</span> function. Finally, the $\zeta_k$ are computed as in @MR4178188 by the <span class="in">`zetas.tree`</span> function with <span class="in">`method=zeta.DKWM`</span>.</span>
<span id="cb3-962"><a href="#cb3-962" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-963"><a href="#cb3-963" aria-hidden="true" tabindex="-1"></a><span class="fu"># Numerical experiments {#sec-numeric}</span></span>
<span id="cb3-964"><a href="#cb3-964" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-965"><a href="#cb3-965" aria-hidden="true" tabindex="-1"></a>In this Section, we present some numerical experiments aiming to demonstrate the impact of the pruning of @alg-pruning (using the <span class="in">`delete.gaps`</span> option mentioned in @sec-implementation) and of the fast @alg-curve, in terms of computation time, compared to the only previously available method to compute a curve of confidence bounds. As mentioned in @sec-forest-structure and @sec-implementation, this naive method simply consisted in a <span class="in">`for`</span> loop repeatedly applying @alg-vstar.</span>
<span id="cb3-966"><a href="#cb3-966" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-967"><a href="#cb3-967" aria-hidden="true" tabindex="-1"></a>To compare the computation time, we use the <span class="in">`R`</span> package <span class="in">`microbenchmark`</span> version 1.5.0 <span class="co">[</span><span class="ot">@microbenchmark</span><span class="co">]</span> with <span class="in">`R`</span> version 4.4.0 (2024-04-24) and <span class="in">`sanssouci`</span> version 0.13.0, on a MacBook Air M1 (2020) running macOS 15.1.1. The package <span class="in">`microbenchmark`</span> allows to run code snippets a given number <span class="in">`n_repl`</span> of times, and to compute summary statistics on the computation time. The script executing the computation can be found in the same repository as this manuscript.</span>
<span id="cb3-968"><a href="#cb3-968" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-969"><a href="#cb3-969" aria-hidden="true" tabindex="-1"></a>Four scenarios are studied, all based on a common setting which we first describe. A number $m$ of hypotheses is tested. We use a reference family $(R_k,\zeta_k)$ such that the $R_k$'s have a forest structure of maximal depth $H=10$. The graph of the inclusion relations between the $R_k$'s is a binary tree, hence there are $2^H-1=1023$ $R_k$'s and in particular $2^{H-1}=512$ atoms. $P$-values are generated in a gaussian one-sided fashion where $\Hoi= <span class="sc">\{</span> \mathcal N(\boldsymbol{\mu}, \mathrm{Id})  :\mu_i=0 <span class="sc">\}</span>$, $H_{1,i}=<span class="sc">\{</span> \mathcal N(\boldsymbol{\mu}, \mathrm{Id}) :\mu_i=4 <span class="sc">\}</span>$, and $p_i(X)=1-\Phi(X_i)$. $\cH_1$ is comprised of the leafs 1, 5, 9 and 10, that is $\cH_1=P_1\cup P_5\cup P_9\cup P_{10}$. For each scenario, the curve $\left(\Vstar(<span class="sc">\{</span>1,\dotsc,t <span class="sc">\}</span>)\right)_{t\in\Nm^*}$ is computed. For the experiments including pruning, the pruning is done once before the <span class="in">`n_repl`</span> replications, to mimick the practice where pruning only needs to be done once and for all, while the user may be interested in computing multiple bounds and curves after that.</span>
<span id="cb3-970"><a href="#cb3-970" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-971"><a href="#cb3-971" aria-hidden="true" tabindex="-1"></a>In scenarios 1 and 2, $m=1024$ (so the atoms are of size 2), in scenarios 3 and 4, $m=10240$ (so the atoms are of size 10). In scenarios 1 and 3, the $\zeta_k$'s are estimated trivially by $\zeta_k=|R_k|$, and in scenarios 2 and 4, they are computed as in @MR4178188 with the DKWM inequality <span class="co">[</span><span class="ot">@MR0083864 ; @MR1062069</span><span class="co">]</span>. Because of the size of $m$ and the poor performances of the naive approach, we set <span class="in">`n_repl=100`</span> in scenarios 1 and 2 and <span class="in">`n_repl=10`</span> only in scenario s 3 and 4. The differences between the scenarios are summarized in @tbl-scenarios.</span>
<span id="cb3-972"><a href="#cb3-972" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-973"><a href="#cb3-973" aria-hidden="true" tabindex="-1"></a>::: {#tbl-scenarios}</span>
<span id="cb3-974"><a href="#cb3-974" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-975"><a href="#cb3-975" aria-hidden="true" tabindex="-1"></a>|parameter| Scenario 1 | Scenario 2 | Scenario 3 | Scenario 4 |</span>
<span id="cb3-976"><a href="#cb3-976" aria-hidden="true" tabindex="-1"></a>|--|------|------|------|--|</span>
<span id="cb3-977"><a href="#cb3-977" aria-hidden="true" tabindex="-1"></a>|$m$| 1024    | 1024    | 10240    |10240 |</span>
<span id="cb3-978"><a href="#cb3-978" aria-hidden="true" tabindex="-1"></a>|zeta computation| trivial    | DKWM   | trivial    |DKWM |</span>
<span id="cb3-979"><a href="#cb3-979" aria-hidden="true" tabindex="-1"></a>|<span class="in">`n_repl`</span>| 100    | 100    | 10    | 10|</span>
<span id="cb3-980"><a href="#cb3-980" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-981"><a href="#cb3-981" aria-hidden="true" tabindex="-1"></a>Differences between the scenarios</span>
<span id="cb3-982"><a href="#cb3-982" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-983"><a href="#cb3-983" aria-hidden="true" tabindex="-1"></a>::: </span>
<span id="cb3-984"><a href="#cb3-984" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-985"><a href="#cb3-985" aria-hidden="true" tabindex="-1"></a>For the trivial $\zeta_k$ computation of scenarios 1 and 3, the pruning obviously deletes all non-atom regions so $|\cK^{\pr}|=512$. Whereas, for the particular instance $\omega\in\Omega$ in the experiments, $|\cK^{\pr}|=541$ for scenario 2, and $|\cK^{\pr}|=573$ for scenario 4. Those results alone illustrate the benefits of pruning with respect to the reduction of the cardinality of the reference family: the regions above atoms with no signal (or no detectable signal in the trivial scenarios) are pruned. The fact that the regions above atoms with detectable signal are not pruned means that they are relevant for the confidences bounds (which had already been demonstrated in the simulation study of @MR4178188).</span>
<span id="cb3-986"><a href="#cb3-986" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-987"><a href="#cb3-987" aria-hidden="true" tabindex="-1"></a>The summary statistics of the computation time in each scenario are presented in @tbl-benchmark01, @tbl-benchmark02, @tbl-benchmark03, and @tbl-benchmark04, and they are also presented as boxplots in @fig-benchmark01, @fig-benchmark02, @fig-benchmark03 and @fig-benchmark04. The time unit is the second.</span>
<span id="cb3-988"><a href="#cb3-988" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-989"><a href="#cb3-989" aria-hidden="true" tabindex="-1"></a><span class="in">```{r loading, echo=FALSE}</span></span>
<span id="cb3-990"><a href="#cb3-990" aria-hidden="true" tabindex="-1"></a><span class="in">library(microbenchmark)</span></span>
<span id="cb3-991"><a href="#cb3-991" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-992"><a href="#cb3-992" aria-hidden="true" tabindex="-1"></a><span class="in">unit &lt;- "s"</span></span>
<span id="cb3-993"><a href="#cb3-993" aria-hidden="true" tabindex="-1"></a><span class="in">loaded_list &lt;- list()</span></span>
<span id="cb3-994"><a href="#cb3-994" aria-hidden="true" tabindex="-1"></a><span class="in">summary_list &lt;- list()</span></span>
<span id="cb3-995"><a href="#cb3-995" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-996"><a href="#cb3-996" aria-hidden="true" tabindex="-1"></a><span class="in">for (i in 1:4){</span></span>
<span id="cb3-997"><a href="#cb3-997" aria-hidden="true" tabindex="-1"></a><span class="in">  loaded &lt;- read.csv(paste0("benchmark_0", i, ".csv"))</span></span>
<span id="cb3-998"><a href="#cb3-998" aria-hidden="true" tabindex="-1"></a><span class="in">  class(loaded) &lt;- c("microbenchmark", class(loaded))</span></span>
<span id="cb3-999"><a href="#cb3-999" aria-hidden="true" tabindex="-1"></a><span class="in">  loaded$expr &lt;- factor(loaded$expr, levels = c("naive.not.pruned", </span></span>
<span id="cb3-1000"><a href="#cb3-1000" aria-hidden="true" tabindex="-1"></a><span class="in">                                                "naive.pruned", </span></span>
<span id="cb3-1001"><a href="#cb3-1001" aria-hidden="true" tabindex="-1"></a><span class="in">                                                # "naive.pruned.no.gaps",</span></span>
<span id="cb3-1002"><a href="#cb3-1002" aria-hidden="true" tabindex="-1"></a><span class="in">                                                "fast.not.pruned",</span></span>
<span id="cb3-1003"><a href="#cb3-1003" aria-hidden="true" tabindex="-1"></a><span class="in">                                                "fast.pruned"</span></span>
<span id="cb3-1004"><a href="#cb3-1004" aria-hidden="true" tabindex="-1"></a><span class="in">                                                # "fast.pruned.no.gaps"</span></span>
<span id="cb3-1005"><a href="#cb3-1005" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-1006"><a href="#cb3-1006" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-1007"><a href="#cb3-1007" aria-hidden="true" tabindex="-1"></a><span class="in">  loaded$time &lt;- microbenchmark:::convert_to_unit(loaded, unit)</span></span>
<span id="cb3-1008"><a href="#cb3-1008" aria-hidden="true" tabindex="-1"></a><span class="in">  loaded_list[[i]] &lt;- loaded</span></span>
<span id="cb3-1009"><a href="#cb3-1009" aria-hidden="true" tabindex="-1"></a><span class="in">  summary_list[[i]] &lt;- summary(loaded)</span></span>
<span id="cb3-1010"><a href="#cb3-1010" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb3-1011"><a href="#cb3-1011" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1012"><a href="#cb3-1012" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1013"><a href="#cb3-1013" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb3-1014"><a href="#cb3-1014" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: tbl-benchmark01</span></span>
<span id="cb3-1015"><a href="#cb3-1015" aria-hidden="true" tabindex="-1"></a><span class="in">i &lt;- 1</span></span>
<span id="cb3-1016"><a href="#cb3-1016" aria-hidden="true" tabindex="-1"></a><span class="in">knitr::kable(summary_list[[i]], caption = paste0("Scenario ", i))</span></span>
<span id="cb3-1017"><a href="#cb3-1017" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1018"><a href="#cb3-1018" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb3-1019"><a href="#cb3-1019" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: tbl-benchmark02</span></span>
<span id="cb3-1020"><a href="#cb3-1020" aria-hidden="true" tabindex="-1"></a><span class="in">i &lt;- 2</span></span>
<span id="cb3-1021"><a href="#cb3-1021" aria-hidden="true" tabindex="-1"></a><span class="in">knitr::kable(summary_list[[i]], caption = paste0("Scenario ", i))</span></span>
<span id="cb3-1022"><a href="#cb3-1022" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1023"><a href="#cb3-1023" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb3-1024"><a href="#cb3-1024" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: tbl-benchmark03</span></span>
<span id="cb3-1025"><a href="#cb3-1025" aria-hidden="true" tabindex="-1"></a><span class="in">i &lt;- 3</span></span>
<span id="cb3-1026"><a href="#cb3-1026" aria-hidden="true" tabindex="-1"></a><span class="in">knitr::kable(summary_list[[i]], caption = paste0("Scenario ", i))</span></span>
<span id="cb3-1027"><a href="#cb3-1027" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1028"><a href="#cb3-1028" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb3-1029"><a href="#cb3-1029" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: tbl-benchmark04</span></span>
<span id="cb3-1030"><a href="#cb3-1030" aria-hidden="true" tabindex="-1"></a><span class="in">i &lt;- 4</span></span>
<span id="cb3-1031"><a href="#cb3-1031" aria-hidden="true" tabindex="-1"></a><span class="in">knitr::kable(summary_list[[i]], caption = paste0("Scenario ", i))</span></span>
<span id="cb3-1032"><a href="#cb3-1032" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1033"><a href="#cb3-1033" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1034"><a href="#cb3-1034" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb3-1035"><a href="#cb3-1035" aria-hidden="true" tabindex="-1"></a><span class="in">def_mar &lt;- c(5, 4, 4, 2) + 0.1</span></span>
<span id="cb3-1036"><a href="#cb3-1036" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1037"><a href="#cb3-1037" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1038"><a href="#cb3-1038" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb3-1039"><a href="#cb3-1039" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-benchmark01</span></span>
<span id="cb3-1040"><a href="#cb3-1040" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb3-1041"><a href="#cb3-1041" aria-hidden="true" tabindex="-1"></a><span class="in">#| warning: false</span></span>
<span id="cb3-1042"><a href="#cb3-1042" aria-hidden="true" tabindex="-1"></a><span class="in">i &lt;- 1</span></span>
<span id="cb3-1043"><a href="#cb3-1043" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1044"><a href="#cb3-1044" aria-hidden="true" tabindex="-1"></a><span class="in">par(mar = def_mar + c(3.8, 0, 0, 0))</span></span>
<span id="cb3-1045"><a href="#cb3-1045" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1046"><a href="#cb3-1046" aria-hidden="true" tabindex="-1"></a><span class="in">bp &lt;- boxplot(time ~ expr, data=loaded_list[[i]], ylab="time [s]", xlab="", </span></span>
<span id="cb3-1047"><a href="#cb3-1047" aria-hidden="true" tabindex="-1"></a><span class="in">              ylim=NULL, horizontal=F, main=paste0("Microbenchmark timings, scenario ", i), </span></span>
<span id="cb3-1048"><a href="#cb3-1048" aria-hidden="true" tabindex="-1"></a><span class="in">              xaxt = "n")</span></span>
<span id="cb3-1049"><a href="#cb3-1049" aria-hidden="true" tabindex="-1"></a><span class="in">tick &lt;- seq_along(bp$names)</span></span>
<span id="cb3-1050"><a href="#cb3-1050" aria-hidden="true" tabindex="-1"></a><span class="in">axis(1, at = tick, labels = FALSE)</span></span>
<span id="cb3-1051"><a href="#cb3-1051" aria-hidden="true" tabindex="-1"></a><span class="in">text(tick, par("usr")[1] - 1.9, bp$names, srt = 60, xpd = TRUE)</span></span>
<span id="cb3-1052"><a href="#cb3-1052" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1053"><a href="#cb3-1053" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb3-1054"><a href="#cb3-1054" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-benchmark02</span></span>
<span id="cb3-1055"><a href="#cb3-1055" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb3-1056"><a href="#cb3-1056" aria-hidden="true" tabindex="-1"></a><span class="in">#| warning: false</span></span>
<span id="cb3-1057"><a href="#cb3-1057" aria-hidden="true" tabindex="-1"></a><span class="in">i &lt;- 2</span></span>
<span id="cb3-1058"><a href="#cb3-1058" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1059"><a href="#cb3-1059" aria-hidden="true" tabindex="-1"></a><span class="in">par(mar = def_mar + c(3.8, 0, 0, 0))</span></span>
<span id="cb3-1060"><a href="#cb3-1060" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1061"><a href="#cb3-1061" aria-hidden="true" tabindex="-1"></a><span class="in">bp &lt;- boxplot(time ~ expr, data=loaded_list[[i]], ylab="time [s]", xlab="", </span></span>
<span id="cb3-1062"><a href="#cb3-1062" aria-hidden="true" tabindex="-1"></a><span class="in">              ylim=NULL, horizontal=F, main=paste0("Microbenchmark timings, scenario ", i), </span></span>
<span id="cb3-1063"><a href="#cb3-1063" aria-hidden="true" tabindex="-1"></a><span class="in">              xaxt = "n")</span></span>
<span id="cb3-1064"><a href="#cb3-1064" aria-hidden="true" tabindex="-1"></a><span class="in">tick &lt;- seq_along(bp$names)</span></span>
<span id="cb3-1065"><a href="#cb3-1065" aria-hidden="true" tabindex="-1"></a><span class="in">axis(1, at = tick, labels = FALSE)</span></span>
<span id="cb3-1066"><a href="#cb3-1066" aria-hidden="true" tabindex="-1"></a><span class="in">text(tick, par("usr")[1] - 1.8, bp$names, srt = 60, xpd = TRUE)</span></span>
<span id="cb3-1067"><a href="#cb3-1067" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1068"><a href="#cb3-1068" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb3-1069"><a href="#cb3-1069" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-benchmark03</span></span>
<span id="cb3-1070"><a href="#cb3-1070" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb3-1071"><a href="#cb3-1071" aria-hidden="true" tabindex="-1"></a><span class="in">#| warning: false</span></span>
<span id="cb3-1072"><a href="#cb3-1072" aria-hidden="true" tabindex="-1"></a><span class="in">i &lt;- 3</span></span>
<span id="cb3-1073"><a href="#cb3-1073" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1074"><a href="#cb3-1074" aria-hidden="true" tabindex="-1"></a><span class="in">par(mar = def_mar + c(3.8, 0, 0, 0))</span></span>
<span id="cb3-1075"><a href="#cb3-1075" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1076"><a href="#cb3-1076" aria-hidden="true" tabindex="-1"></a><span class="in">bp &lt;- boxplot(time ~ expr, data=loaded_list[[i]], ylab="time [s]", xlab="", </span></span>
<span id="cb3-1077"><a href="#cb3-1077" aria-hidden="true" tabindex="-1"></a><span class="in">              ylim=NULL, horizontal=F, main=paste0("Microbenchmark timings, scenario ", i), </span></span>
<span id="cb3-1078"><a href="#cb3-1078" aria-hidden="true" tabindex="-1"></a><span class="in">              xaxt = "n")</span></span>
<span id="cb3-1079"><a href="#cb3-1079" aria-hidden="true" tabindex="-1"></a><span class="in">tick &lt;- seq_along(bp$names)</span></span>
<span id="cb3-1080"><a href="#cb3-1080" aria-hidden="true" tabindex="-1"></a><span class="in">axis(1, at = tick, labels = FALSE)</span></span>
<span id="cb3-1081"><a href="#cb3-1081" aria-hidden="true" tabindex="-1"></a><span class="in">text(tick, par("usr")[1] - 120, bp$names, srt = 60, xpd = TRUE)</span></span>
<span id="cb3-1082"><a href="#cb3-1082" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1083"><a href="#cb3-1083" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb3-1084"><a href="#cb3-1084" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-benchmark04</span></span>
<span id="cb3-1085"><a href="#cb3-1085" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb3-1086"><a href="#cb3-1086" aria-hidden="true" tabindex="-1"></a><span class="in">#| warning: false</span></span>
<span id="cb3-1087"><a href="#cb3-1087" aria-hidden="true" tabindex="-1"></a><span class="in">i &lt;- 4</span></span>
<span id="cb3-1088"><a href="#cb3-1088" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1089"><a href="#cb3-1089" aria-hidden="true" tabindex="-1"></a><span class="in">par(mar = def_mar + c(3.8, 0, 0, 0))</span></span>
<span id="cb3-1090"><a href="#cb3-1090" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1091"><a href="#cb3-1091" aria-hidden="true" tabindex="-1"></a><span class="in">bp &lt;- boxplot(time ~ expr, data=loaded_list[[i]], ylab="time [s]", xlab="", </span></span>
<span id="cb3-1092"><a href="#cb3-1092" aria-hidden="true" tabindex="-1"></a><span class="in">              ylim=NULL, horizontal=F, main=paste0("Microbenchmark timings, scenario ", i), </span></span>
<span id="cb3-1093"><a href="#cb3-1093" aria-hidden="true" tabindex="-1"></a><span class="in">              xaxt = "n")</span></span>
<span id="cb3-1094"><a href="#cb3-1094" aria-hidden="true" tabindex="-1"></a><span class="in">tick &lt;- seq_along(bp$names)</span></span>
<span id="cb3-1095"><a href="#cb3-1095" aria-hidden="true" tabindex="-1"></a><span class="in">axis(1, at = tick, labels = FALSE)</span></span>
<span id="cb3-1096"><a href="#cb3-1096" aria-hidden="true" tabindex="-1"></a><span class="in">text(tick, par("usr")[1] - 170, bp$names, srt = 60, xpd = TRUE)</span></span>
<span id="cb3-1097"><a href="#cb3-1097" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-1098"><a href="#cb3-1098" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1099"><a href="#cb3-1099" aria-hidden="true" tabindex="-1"></a>On each scenario, using the fast algorithm is much faster than the naive approach, while pruning always gives a slight improvement over not pruning. </span>
<span id="cb3-1100"><a href="#cb3-1100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1101"><a href="#cb3-1101" aria-hidden="true" tabindex="-1"></a>Comparing scenarios 1 and 2 first, we see that, as expected, there is no significant change in computation time for <span class="in">`naive.not.pruned`</span>, while <span class="in">`naive.pruned`</span> is faster in scenario 1, given that we prune more. But, on the other hand, <span class="in">`fast.not.pruned`</span> and <span class="in">`fast.pruned`</span> are both faster in scenario 2, even if we prune less. This is because, for the regions with signal, said signal is detected and so those regions are quickly saturated, in the sense that we quickly have $\eta_k^t=\zeta_k$ and $k$ added $\cK^-_k$, which saves a lot of time. </span>
<span id="cb3-1102"><a href="#cb3-1102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1103"><a href="#cb3-1103" aria-hidden="true" tabindex="-1"></a>The comparison between scenarios 3 and 4 is similar, except that this time we prune even less in scenario 4 and so the effect of the saturation is not enough to compensate. Although, with only <span class="in">`n_repl=10`</span>, the statistics seem less accurate, this can be confirmed with additional experiments (<span class="in">`n_repl`</span> can also be set to 100 without problem is we don't include <span class="in">`naive`</span> methods).</span>
<span id="cb3-1104"><a href="#cb3-1104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1105"><a href="#cb3-1105" aria-hidden="true" tabindex="-1"></a>Finally, comparing scenarios 3 &amp; 4 with scenarios 1 &amp; 2, we see that multiplying the number of hypotheses by 10 effectively multiplies the computation time by $\sim10$ when using @alg-curve and by $\sim100$ when using @alg-vstar naively, which illustrates the stated complexities of $O(m|\cK|)$ and $O(m^2|\cK|)$, respectively.</span>
<span id="cb3-1106"><a href="#cb3-1106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1107"><a href="#cb3-1107" aria-hidden="true" tabindex="-1"></a><span class="fu"># Conclusion</span></span>
<span id="cb3-1108"><a href="#cb3-1108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1109"><a href="#cb3-1109" aria-hidden="true" tabindex="-1"></a>In conclusion, we effectively introduced a new algorithm to compute a curve of confidence upper bounds, much faster the previous alternative, with one power of $m$ less in the complexity.</span>
<span id="cb3-1110"><a href="#cb3-1110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1111"><a href="#cb3-1111" aria-hidden="true" tabindex="-1"></a>To develop new confidence upper bounds methodology and test them on simulations, it was previously not conceivable to replicate experiments a sufficient number of times while computing whole curves. For instance, in the simulation study of @MR4178188, the number of replications chosen was 10 and the whole curve was not computed, only ten values along the curve were computed, for an <span class="in">`m`</span> set to 12800, that is 0.078% of the curve had been computed. Now, simulation studies with an adequate number of replications and 100% of the curve become feasible.</span>
<span id="cb3-1112"><a href="#cb3-1112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1113"><a href="#cb3-1113" aria-hidden="true" tabindex="-1"></a>A lot of work remains to be done on the <span class="in">`sanssouci`</span> package. For example, to make the data format of a forest structure $(R_k)_{k\in\cK}$ less convoluted and more user-friendly is an interesting project. Another one would be to implement inside the package the methods of the paper @blain22notip, which are currently only available in the Python language <span class="co">[</span><span class="ot">@10.5555/1593511</span><span class="co">]</span>, and the methods of the paper @JMLR:v25:23-1025.</span>
<span id="cb3-1114"><a href="#cb3-1114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1115"><a href="#cb3-1115" aria-hidden="true" tabindex="-1"></a>Other current works include the development of new reference families with theoretical JER control that could better account for realistic models, such as models with dependence between the $p$-values, see for example @perrot2023selective, or models with discreteness.</span>
<span id="cb3-1116"><a href="#cb3-1116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1117"><a href="#cb3-1117" aria-hidden="true" tabindex="-1"></a><span class="fu"># Acknowledgements</span></span>
<span id="cb3-1118"><a href="#cb3-1118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1119"><a href="#cb3-1119" aria-hidden="true" tabindex="-1"></a>This work has been supported by ANR-20-IDEES-0002 (PIA), ANR-19-CHIA-0021 (BISCOTTE), ANR-23-CE40-0018 (BACKUP) and ANR-21-CE23-0035 (ASCAI). Thanks to Romain Périer for being the first to extensively use the new implemented algorithms.</span>
<span id="cb3-1120"><a href="#cb3-1120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1121"><a href="#cb3-1121" aria-hidden="true" tabindex="-1"></a><span class="fu"># References {.unnumbered}</span></span>
<span id="cb3-1122"><a href="#cb3-1122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1123"><a href="#cb3-1123" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb3-1124"><a href="#cb3-1124" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-1125"><a href="#cb3-1125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1126"><a href="#cb3-1126" aria-hidden="true" tabindex="-1"></a><span class="fu"># Session information {.appendix .unnumbered}</span></span>
<span id="cb3-1127"><a href="#cb3-1127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-1128"><a href="#cb3-1128" aria-hidden="true" tabindex="-1"></a><span class="in">```{r session-info}</span></span>
<span id="cb3-1129"><a href="#cb3-1129" aria-hidden="true" tabindex="-1"></a><span class="in">sessionInfo()</span></span>
<span id="cb3-1130"><a href="#cb3-1130" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
    <script type="text/javascript">
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let pseudocodeOptions = {
          indentSize: el.dataset.indentSize || "1.2em",
          commentDelimiter: el.dataset.commentDelimiter || "//",
          lineNumber: el.dataset.lineNumber === "true" ? true : false,
          lineNumberPunc: el.dataset.lineNumberPunc || ":",
          noEnd: el.dataset.noEnd === "true" ? true : false,
          titlePrefix: el.dataset.captionPrefix || "Algorithm"
        };
        pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
      });
    })(document);
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let captionSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
        if (captionSpan !== null) {
          let captionPrefix = el.dataset.captionPrefix + " ";
          let captionNumber = "";
          if (el.dataset.pseudocodeNumber) {
            captionNumber = el.dataset.pseudocodeNumber + " ";
            if (el.dataset.chapterLevel) {
              captionNumber = el.dataset.chapterLevel + "." + captionNumber;
            }
          }
          captionSpan.innerHTML = captionPrefix + captionNumber;
        }
      });
    })(document);
    </script>
  




</body></html>